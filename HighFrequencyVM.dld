'CR6 Series Datalogger
'Adapted from USGS Sacramento Hydrodynamics group program version 4.22
'Original authors Michael Simpson, Trevor Violette, Jim Derose, and Mark Inc, USGS
'Program Version Date
Const ProgramVersionDate = 20190904
Const ProgramVersion = "P2.00"
'Last Modified by: Trevor Violette

'-----------------IMPORTANT IMPORTANT-----------------------------------------------
'BEFORE COMPILING:
' 1 SET DLD DATALOGGER TYPE IN TOOLS MENU FOR THE TARGET DATALOGGER
' 2 CHOOSE CUSTOMIZE CONSTANTS IN TOOLS MENU, SELECT PROPER CONSTANTS FOR THE TARGET STATION
' 3 CHOOSE CONDITIONAL COMPILE AND SAVE IN THE COMPILE MENU. RENAME THE FILE WITH STATION ID AND DATE IN FILENAME USING CR6 or CR1 file extension
' 4 LOAD THE SAVED FILE INTO THE STATION DATALOGGER OR YOU CAN LOAD THE ORIGINAL DLD FILE IF SPACE PERMITS.
' 5 DO NOT USE A MAX232 ADAPTER ON THE CSI/0 (ComME) port


'If using BEAM coordinate transformation on a Channel Master, You MUST obtain an external HEADING determination as there is NO internal compass!
'If using a Bi-directional rating (Ebb/Flood) with different bins for each direction you must be using a channel master with insturment coordinates, you must set Birating to true in the startup parameters.
'You also must set StartBin, EndBin, StartEbbBin, EndEbbBin, StartFldBin, and EbbFldBin to appropriate values (ebb = pos) (Fld = neg)  Startbin and Endbin should include all the bins used
'for both ebb and flood calculations. You also have to set BiRatTran to the velocity That you wish calculations to switch from Ebb bins to Flood Bins. The program will make sure you are using
'a Channel Master with instrument coords before applying the Ebb/Flood bin differences. If you are using any other VM or coord system, it will use the standard method to calculate iVel.
'You can include V2 (Y velocity) in the IndexVel calculation if you wish to use it. Just make sure UseV2 is True.

'_______________________________PROGRAM UPDATES_________________________________________
'20190813 - MRI P0.9 Took USGS Sacramento master code from version 4.22 to act as a base. Paired down to ADVM (CM), pressure sensors, and CDMA.
'20190814 - MRI P0.95 Cleaned and refined data. Added Accubar bubbler into all stage related fields. Need to adjust USR drive routines and see if bubbler has a retrievable serial number.
'20190816 - MRI P0.96 Removed noisefloor section. Board configured and all components seem to be working correctly with bubbler, modem relay, and ADVM.
'20190819 - MRI P0.97 Expanded Beamcheck to handle maxbins instead of just 27. Added single BBLStage sample to data out. Adjusted CDMA power routine. Added timer to GetStage as Bubbler takes a long time to process. May need to move until after ADVM check.
'20190820 - MRI P0.98 Added ADVM timing and refined debugger table
'20190822 - MRI P1.00 Altered scan timing so all velocity data is captured prior to bubbler which was causing too large of a delay and skipping scans. Tested in the field with 27 bins and all data looked to be coming in correctly.
'20190904 - TAV P2.00 Edited and commented out subroutines and variables not necessary for the high frequency VM testing. Set ScanRate at 5 seconds for a starting point

'IMPORTANT - ADCP should be set for 1 minute TE and WP 60.

SequentialMode 'must not use pipeline mode or averages are missedb

'_____________________________Declare Public Variables___________________________________
Const Yes = True
Const No = False
'-------------------------------------------------------------------------------------------
'------------------------------------------------------------------------------------
'Customize constants explanation:
'"VMBaud" select baud rate of ADVM. Recommend 38400
'"HasVM" Choose if there is a Velocity meter at this station
'"MaxBins" what is the maximum number of bin the CM is programmed to collect.
'VMDeadCntMax"  number of scans (1 min) of no VM data before cycling power To the VM (5 To 120)
'"StoreAllToCard"  Store all beam data (RSSI, Corr, Velocity) to Micro SD card (CR6) or CF card (CR1000)
'"Debugging" display the debugger timers in the public table. Generally easier to just use the debugger table
'"SeeAllVel" Show all Velocity data in the public table. Data is shown in dataout table  by default.

'Change these values in the Tools/Customize Constants dropdown dialog
'do not change commented items in this customization section!!!!!!

'Start of Constants Customization Section
Const VmBaud = 38400
'value = 9600
'value = 19200
'value = 38400
'value = 57600
'value = 115200
Const HasVM = True
'value = True
'value = False
Const MaxBins = 27 'you need to make sure this number matches the number of bins sent to the ADVM with the script file or all velocity data will be discarded.
'Min = 1
'Max = 100
'Inc = 1
Const VMDeadCntMax = 20
'Min = 5
'Max = 120
'Inc = 5
Const StoreAllToCard = False
'value = True
'value = False
Const Debugging = False
'Value = True
'Value = False
Const SeeAllVel = True
'Value = True
'Value = False
'End of Constants Customization Section

'------------------------------------------------------------------------------------------
'Port constants to determine locations on CR1000
'in this preliminary version it's assumed that the CDMA uses SW12 no 1 on both dataloggers
'-------------------------------------------------------------------------------------------------------------------------------------------
  Const AdcpPort = ComC1
  Const VMSwitchPort = U4
  Const PS1Com3 = U3
  Const PS1Com5 = U5
  Const PS2Com3 = U3
  Const PS2Com5 = U5
  Const BBLCom7 = U7
    
'Declare Constants
Const VelocityScaleWater = 1/304.8 'converts mm/sec to ft/sec
'constants for selecting different stage devices
Const ScanRate = 5
Const ScanUnit = 2
Const FastScanRate = 15
Const FastScanUnit = 2
Const UPbeam = 1 'accoustic upbeam
Const VMpress = 2 'internal pressure sesnor in CM is not reliable
Const PSpress = 3
Const PSpress2 = 4
Const BBL = 5 'to be used with the Accubar bubbler

'Generally don't need to change anything below this point. Click "Go to" (above) -> "Navigation" -> "Subroutine Section" or just Ctrl + Shift + S
'_____________________________________________________________________________________________________________________________________
'data ID's
Const FixedLeaderID = 0 'data IDs located at the start of each data stream
Const VariableLeaderID = 128
Const CorrelationProfileID = 512
Const RSSIProfileID = 768
Const PGoodProfileID = 1024
Const VelocityProfileID = 256
Const VMStageID = 16384
Const BottomID = 1536
'Const MaxBins = 27 'Changed back to 27 per JBD
Const MaxBeams = 4
Const BadVel = -32768 'bad velocity indicator from adcp
Const BadDataIndicator = NAN
Const Meters_to_Feet = 3.280839895
Const DegToRad = (3.14159265358979323846/180) 'degrees to radians

'Declare Misc Veriables
Public SiteID As String * 6 '3 character station identification
Public SiteNum As String * 16 'station number
Public CR1Volts As Float 'power supply voltage to cr10000
Public ExtWHConvertVolt As Float 'get volts from external power supply or battery pack
Public ExtSolarVolt As Float 'get volts from solar panel
Public PTempC As Float 'CR1000 panel temperature in DegC
Public PTempF As Float 'CR1000 panel temperature in Degf
Public RecCalibData As Boolean 'flag to record data at 1 minute interval when measurements are being done.
Public OneMinConsistent As Boolean 'flag to record data at 1 minute interval for prolonged periods of time
Public StoreVariablesFlg As Boolean
Public GetVariablesFlg As Boolean
Dim Rec15minFlag As Boolean 'set when Dataout table is stored
Public RecAQFlag As Boolean 'Set when problem with Sonde but still want to record to the Aquarius table
Dim Rec24HrFlag As Boolean 'set when QAQC table is stored
Dim Rec1MinFlag As Boolean 'set when recording Calibration data
Dim OneMinCount As Long 'used to turn off calibration data after 24 hours (1439 minnutes)
Dim RecDataFlag As Boolean 'used to check timing of ensemble data
Public RecAllVelFlag As Boolean 'used to set timing for velocity collecting in Special studies
Public Prompt As String *5
Dim RecBeamCheckFlag As Boolean 'flag to turn beamcheck table on or off
Public LowRatVel As Float' user input of lowest velocity covered by rating
Dim InitialLRV As Float ' used for changing LowMeas flag to false if there's been a change to the LowRatVel
Public HighRatVel As Float' user input of Highest velocity covered by rating
Dim InitialHRV As Float 'used for changing HighMeas flag to false if there's been a change to the HighRatVel
Public LowMeas As Boolean 'flag indicating low flow measurement needed
Public HighMeas As Boolean 'flag indicating high flow measurement needed
Dim LowCount As Long 'counter for number of times velocity is below the Lower limit
Dim HighCount As Long 'Counter for number of times velocity is above the upper limit
Public VMPower As Boolean 'flag to turn VM on and Off manually
Public isVMNClosed As Boolean 'is the VM powered using a Normally clo9sed relay
Public VmDeadCount As Long 'number of times VM has bad data
'Declare variables to hold time values
Dim rTime(9) As Float 'this array holds time values returned from the realtime statement
Alias rTime(3) = DOM 'FOR BEAM CHECK
Alias rTime(4) = Hour
Alias rTime(5) = Minute
Alias rTime(6) = Second
Alias rTime(7) = MicroSecond
Public LastScan As String * 6 'when did the datalogger most recently scan?
Dim RealSeconds As Long 'used for computing elapsed time intervals
Dim Mod5Minutes As Long 'used for computing elapsed time intervals
Dim Mod15Minutes As Float 'used for computing elapsed time intervals
Dim Mod60Minutes As Float 'used for computing elapsed time intervals
Dim ModDay As Float 'used for computing elapsed time intervals
#If Debugging = True Then
  Public VMYear As Long 'Date time from the Velocity meter clock
  Public VMMonth As Long 'Date time from the Velocity meter clock
  Public VMDay As Long 'Date time from the Velocity meter clock
  Public VMHour As Long 'Date time from the Velocity meter clock
  Public VMMinute As Long 'Date time from the Velocity meter clock
  Public VMSecond As Long 'Date time from the Velocity meter clock
  Public VMTime As String * 25 'Date time from the Velocity meter clock
  Public SetVMTimeFlg As Boolean 'used it setting VM Time
  Public VMTimeString As String * 25 'used it setting VM Time
  Public SplitTime(6) As Float 'used it setting VM Time
  Public RawSetTime As String * 25 'used it setting VM Time and EXO time
  Public FSplitTime(6) As Float 'used it setting VM Time
#Else
  Dim VMYear As Long 'Date time from the Velocity meter clock
  Dim VMMonth As Long 'Date time from the Velocity meter clock
  Dim VMDay As Long 'Date time from the Velocity meter clock
  Dim VMHour As Long 'Date time from the Velocity meter clock
  Dim VMMinute As Long 'Date time from the Velocity meter clock
  Dim VMSecond As Long 'Date time from the Velocity meter clock
  Dim VMTime As String * 25 'Date time from the Velocity meter clock
  Dim SetVMTimeFlg As Boolean 'used it setting VM Time
  Dim VMTimeString As String * 25 'used it setting VM Time
  Dim SplitTime(6) As Float 'used it setting VM Time
  Dim RawSetTime As String * 25 'used it setting VM Time and EXO time
  Dim FSplitTime(6) As Float 'used it setting VM Time
#EndIf

'spike filter variables
#If HasVM Then
  Dim RSSIspike(MaxBins,4,16) As Float 'array to hold RSSI data Queue
  Dim Corrspike(MaxBins,4,16) As Float 'array to hold Correlation data Queue
  Dim Velspike(MaxBins,4,16) As Float 'array to hold Velocity data Queue
  Dim StageSpike(16) As Float 'array to hold Stage data Queue
  Public QueueDQI As Float 'data quality indicator for Queue
  Public RSSIStdNo As Long = 2  ' standard deviations from mean for spike
  Public CorrStdNo As Long = 2
  Public VelStdNo As Long = 2
  Public SpikeFileName As String * 64
  Dim FileHandle As Long
  Public FileHeader As String * 500
  Public SpikeCounter As Long
  Public SendHeader As Boolean = True
  Public TestTime As String * 20
  Public CardError As String * 25
#EndIf

'Declare variables for CDMA
Dim CdmaScans As Long 'number of times the datalogger has unsuccessfully attempted to connect to the loggernet server
Public HrsCdmaOff As Long 'how many hours to allow to pass before trying to restart the CDMA if there are connection issues
Dim LoggernetAddr As Long 'LoggerNet server PakBus address (generally 4094). if datalogger doesn't see this address as a "neighbor" it assumes connection failure
'which is used for knowing when to reset CDMA (using the variables above)
Public CdmaWorks As Boolean 'using the above variable "LoggernetAddr", does the datalogger see 4094 as a neighbor? if not, it's assumed CDMA does not work
Dim CDMAFailure As Boolean 'indicator of a CDMA failure for triggering a reset
Public CycleCdmaPwr As Boolean 'cycle the power to the CDMA
Public IsCDMAOn As Boolean 'Is the CDMA powered? (based on the switch 12V port status, (on or off), and the "IsNClosed" variable
Public IsCDMANClosed As Boolean 'Is there a Normally Closed Relay installed in the CDMA circuit, if yes, SW12V port stays OFF to keep power to CDMA. if no, SW12V port
'stays ON to power the CDMA
Public KeepCDMAon As Boolean 'keep CDMA 24/7 (true) or turn on at the top of the hour for 10 minutes to save battery power (false)

'Declare variables to hold system status information
Public Tech As String * 3 'user initials so we know who was there for a visit
Public VisitReason As String *100 'what is the purpose of the visit
Public SerNum As Long 'datalogger computer serial number
Public OSVers As String * 18 'datalogger Operating System version
Public Program As String * 25 'Program version
Public ProgVersDate As String * 8 'date of the program version, based on the constant "ProgramVersionDate"
Public ProgVersion As String * 5 'program version number, based on constant "ProgramVersion"
Public ProgErrors As Long 'from "Status" table, The number of compile or runtime errors for the current program.
Public Low12Volts As Long 'from "status" table, how many times has there been low voltage (based on CR1000 threshold of 9.6v when the CR1000 goes into a lower power
'mode and discontinues it's measurement tasks until power is restored)
Public LithBat As Float 'voltage of the internal lithium battery. (this battery keeps memory in case of external power issues)
Public SkipScans As Long 'number of times a complete scan has been skipped (with the exception of intentionally skipped scans based on ExitScan and Do/Loops
Public FreeCFMem As Float 'how much memory does the external CF card have remaining

Public Coord As String * 20 'which coordinate system is the ADCP using?
Dim ADCPSN01 As Long 'the following "ADCPSNxx" are used to have a record of which serial number is being used and if it's been changed
Dim ADCPSN02 As Long
Dim ADCPSN03 As Long
Dim ADCPSN04 As Long
Public AdcpSN As Long
Dim InitialAdcpSN As Long 'used to hold the previous day's serial number and flag it if the instrument has changed
Public NewADCP As Boolean 'is it a new ADCP?
Public PS1SN As String * 40 'used to get pressure sensor brand, model, and serial number
Dim InitialPS1SN As String * 40 'used to hold the previous day's serial number and flag it if the instrument has changed
Public NewPS1 As Boolean 'is it a new pressure sensor?
Public PS2SN As String * 40 'used to get pressure sensor brand, model, and serial number
Dim InitialPS2SN As String * 40 'used to hold the previous day's serial number and flag it if the instrument has changed
Public NewPS2 As Boolean 'is it a new pressure sensor?
Public BBLSN As String * 40 'used to get bubbler brand, model, and serial number
Dim InitialBBLSN As String * 40 'used to hold the previous day's serial number and flag it if the instrument has changed
Public NewBBL As Boolean 'is it a new bubbler?

'Decoding Velocity variables
Public BadChecksum As Long 'if
Public HeaderMismatch As Long
Dim NumbytesZero As Long
Public CalcCheckSum As Float
Public EnsChecksum As Float
Dim TempL As Long
Public Numbytes
Public BadEnsemble As Long
Public ScanNo As Long
Dim Longarray(2000) As Long 'Array for the Raw Ensemble
Dim Nums(2) As Long
Public EnsembleLen As Long
Dim Datatypes As Long
Dim Offsets(25) As Long 'offsets to the start of the datatype locations
Public BinSize As Long 'ADCP bin size in centimeters
Public NumADCPBins As Long 'ADCP number of bins
Public Numbins As Long 'number of adcp bins used
Public EnsPings As Long 'Number of acoustic pings per ensemble
Public NumBeams As Long 'Number of beams on ADCP
Public BlankDist As Long 'Blanking distance of ADCP
Public EX As Long 'coordinate transformation
Public ES As Long 'Salinity
Public Decode As String * 70
Public FramingError As Long
Dim FixedLeadOffset As Long
Dim MSB As Long
Dim MSB1 As Long
Dim LSB As Long
Dim ReceivedBytes As Long
Dim TempId As Long 'for testing
'Dim UseAutoLastBin As Boolean
Public UseDir As Boolean 'does the user want to use compass direction of flow to indicate flood or ebb?
Public PosFlowDir As Float 'what is the compass bearing that indicates a positive flow? (outgoing flow)
Public RecordAll As Boolean
Public PreserveFile As String * 500
'Declare Vel and Q variables
Public CalcQ As Boolean 'user select whether to calculate discharge or not
Public UseV2 As Boolean
Public IndexVel As Float 'index velocity based on rating
Public MeanVel As Float 'average channel velocity based on all bin data
Public Qcfs As Float 'total discharge
Public BadQCount As Long 'how many times has the datalogger been unable to calculate discharge? (either bad stage value or bad velocity value)
Public MinExpVel As Long 'minimum velocity expected at site
Public MaxExpVel As Long 'maximum velocity expected at site
Public FlowSign As Long 'positive or negative multipler depending on which side of the channel the instrument is on
Public BadVelCount As Long 'how many times has there been bad velocity?
Public BadBinCnt As Long
Public DataErr As Long
Public BadVelFlag As Boolean 'indicates there was a data punch with invalid velocity
Public BadQFlag As Boolean 'indicates there was a data punch with invalid discharge
Dim VelDatOffset As Long 'Velocity offset (location of the beginning of velocity data
Dim Bin As Long 'counters for bins
Public StartBin As Long 'where the datalogger begins its iVel calculation
Public StartEbbBin As Long' Use if using ebb and flood rating
Public EndEbbBin As Long' Use if using ebb and flood rating
Public StartFldBin As Long' Use if using ebb and flood rating
Public EndFldBin As Long' Use if using ebb and flood rating
Public EndBin As Long 'where the datalogger ends its iVel calculation
Public BiRating As Boolean = False 'Use this flag if using Ebb/Flood rating
Public BiRatOK As Boolean = False 'Used by program to determin if BiRating can be done
Public UseBiRat As Boolean = False 'flag set if both the above are true
Public BiRatTran As Float  'Transition velocity for ebb/flood Rating
Dim Beam As Long 'counters for beams
Dim temp As Long 'temporary variable
Dim Index As Long 'temporary variable
Dim BinVel As Float 'test variable
Dim BinStep As Long 'counter variable
Dim EnsBin As Long 'counter variable
Dim ensVelocity(MaxBins,4)As Float '30 bins, and 4 beams max Velocity Data
#If SeeAllVel = True Then
  Public V1(MaxBins) As Float 'Can be either Beam 1 velocity, X velocity, or East velocity
  Public V2(MaxBins) As Float 'Can be either Beam 2 velocity, Y velocity, or North velocity
  Public V3(MaxBins) As Float 'Can be either Beam 3 velocity, Z velocity, or UP velocity
  Public V4(MaxBins) As Float 'Can be either Beam 4 velocity, or Error velocity
  Public VMBinVel(MaxBins) As Float 'Up/Dowm stream velocity in each bin
#Else
  Dim V1(MaxBins) As Float 'Can be either Beam 1 velocity, X velocity, or East velocity
  Dim V2(MaxBins) As Float 'Can be either Beam 2 velocity, Y velocity, or North velocity
  Dim V3(MaxBins) As Float 'Can be either Beam 3 velocity, Z velocity, or UP velocity
  Dim V4(MaxBins) As Float 'Can be either Beam 4 velocity, or Error velocity
  Dim VMBinVel(MaxBins) As Float 'Up/Dowm stream velocity in each bin
#EndIf

Dim VelCount As Long 'counter for number of velocity measurements
Dim BadBinCount As Long

'Velocity Averaging Variables  NOTE! EBB FLOOD RATINGS CAN ONLY BE USED WITH CHANNEL MASTERS SET TO INSTRUMENT COORDINATES
Dim V1Sum As Float 'sum of bins in each ensemble for V1
Dim V1EbbSum As Float ' sum of bins in each ensemble for V1 in positive dir
Dim V1FldSum As Float ' sum of bins in each ensemble for V1 in Neg dir
Dim V2Sum As Float 'sum of bins in each ensemble for V2
Dim V2EbbSum As Float ' sum of bins in each ensemble for V2 in positive dir
Dim V2FldSum As Float ' sum of bins in each ensemble for V2 in Neg dir
Dim V3Sum As Float 'sum of bins in each ensemble for V3
Dim V4Sum As Float 'sum of bins in each ensemble for V4
Dim V1Disable(MaxBins) As Boolean
Dim V2Disable(MaxBins) As Boolean
Dim V3Disable(MaxBins) As Boolean
Dim V4disable(MaxBins) As Boolean
Dim VmBinVelDisable(MaxBins) As Boolean
Public V1AVG As Float 'average of bins in each ensemble for V1
Dim V1EbbAvg As Float 'average of bins in each ensemble for V1 for pos dir
Dim V2EbbAvg As Float 'average of bins in each ensemble for V2 for pos dir
Public V2AVG As Float 'average of bins in each ensemble for V2
Dim V1FldAvg As Float 'average of bins in each ensemble for V1 for Neg dir
Dim V2FldAvg As Float 'average of bins in each ensemble for V2 for Neg dir
Public V3AVG As Float 'average of bins in each ensemble for V3
Public V4AVG As Float 'average of bins in each ensemble for V4
Dim Cnt As Long
Public V1Cnt As Long
Dim V1EbbCnt As Long
Dim V2EbbCnt As Long
Dim V1FldCnt As Long
Dim V2FldCnt As Long
Dim V2Cnt As Long
Dim V3Cnt As Long
Dim V4Cnt As Long
Const rad = 3.14159/180
Const deg = 180/3.14159

'Decoding Variable leader
Dim VarLeadOffset As Long '---data variables from variable leader---
Public BIT As Long
Public EnsembleNo As Long

'Decoding RSSI Data
Dim RSSIDatOffset As Long   'location of start of RSSI data
Dim ensRSSI(MaxBins,4) As Long  'MaxBins bins and 4 beams max  RSSI Data
Dim nRSSI As Long 'for RSSI average calc
Dim AccumRSSI As Long 'for RSSI average calc
Dim AvgRSSI(MaxBins) As Long 'average of all beams for that bin per ensemble
Public AvgRSSIStartBin As Long
Public AvgRSSIEndBin As Long
Dim AvgRSSIcounter As Long
Dim AvgRSSIAccum As Long
Public AvgSwathRSSI As Float

'Decoding Correlation Magnitude
Dim CorrDatOffset As Long 'location of start of correlation data
Dim ensCorr(MaxBins,4) As Long '25 bins and 4 beams max Correlation Data
'Dim TempCorr(4) 'temporary array for calculating standard deviation of Correllation
Dim nCorr As Long
Dim AccumCorr As Long
Dim AvgCorr(MaxBins) As Long 'average of all beams for that bin per ensemble
'Dim StdDevCorr(MaxBins) As Float 'holder for std dev of 4 beam correlation

'Decoding Channel Master and Workhorse Stage
Public VMStageDatOffset As Long
Dim L1SB As Long
Dim M1SB As Long
Dim TempM As Float
#If Debugging = True Then
  Public VMTemp As Long 'temporary debugging variable
  Public VMPSTemp As Long 'temporary debugging variable
#Else
  Dim VMTemp As Long 'temporary debugging variable
  Dim VMPSTemp As Long 'temporary debugging variable
#EndIf

'System Identification
Public IsCM As Boolean

'Data Filtering Variables
Public SelectFilter As Long
Public RangedBin As Long = 0 'holder for last bin before surface corruption
Public DucerDepthOffset As Float' difference between depth sensor and transducer face. (+/-) - if lower than ducer + if higher
Public RangeSource As Long 'sensor source for ducer depth calculation
Public CutOffBins As Long 'user enterable value for number of bins to discard when using AutoRange feature for uplookers
Public RSSIThreshold As Float 'allows user to set RSSI Threshold
Public CorrThreshold As Float
Dim BadEnsCount As Long
Dim LoopInterval As Long
Dim FastLoopInterval As Long

'Declare Event variable flags
Dim EventCDMAFlag As Boolean 'added so cdma cycle is only recorded every 24 hours
Dim EventVoltFlag As Boolean '  '   '  Low Voltage  "       "       "      "
Dim EventQFlag As Boolean    '   "   " BadQ = 200    "     "        "      "

'Declare Stage and Area Variables
Public PSPressPort As Long 'port Pressure sensor 1 is plugged into (3 or 5)
Public PSPressAddr As Long 'SDI12 address for Pressure sensor 1
Public PSPressDataIn As Boolean 'are there data from Pressure sensor 1?
Public PsPress1Stg(2) As Float 'array to hold the values pressure sensor 1 is outputting (temp and feet)
Alias PsPress1Stg(1) = PS1RawDepthFt 'Label array as easy-to-read values for techs
Alias PsPress1Stg(2) = PS1TempC
Public PSpress2Stg(2) As Float 'array to hold values pressure sensor 2 is outputting
Alias PSpress2Stg(1) = PS2RawDepthFt 'Label array as easy-to-read values for techs
Alias PSpress2Stg(2) = PS2TempC
Public PSpress2Port As Long 'port pressure sensor 2 is plugged into (3 or 5)
Public PSpress2Addr As Long 'SDI12 address for pressure sensor 2
Public PSpress2DataIn As Boolean 'are there data from pressure sensor 2?
Public BBLPort As Long 'Accubar will be in port 7
Public BBLAddr As Long 'SDI12 address for Accubar
Public BBLDataIn As Boolean 'are there data from the Accubar?
Public BBLstg(2) As Float 'array to hold the values the Accubar is outputting (temp and feet)
Alias BBLstg(1) = BBLRawDepthFt 'Label array as easy-to-read values for techs
Alias BBLstg(2) = BBLUnit 'unit of 10 means non-zero offset and depth in feet
Public BBLUnits As Float
Public StagePrime As Float 'stage value used in calculating discharge
Public StageSecnd As Float 'stage value used in calculating stage difference
Public StgDiff As Float 'absolute value of difference between StagePrime and the user selected instrument stage
Public UpBeamStg As Float 'stage value (after offset applied) for ADCP vertical beam
Public VMPressStg As Float 'stage value (after offset applied) for ADCP pressure sensor
Public PS1Stg As Float ''stage value (after offset applied) for pressure sensor 1
Public PS2Stg As Float ''stage value (after offset applied) for pressure sensor 2
Public BBLstage As Float ''stage value (after offset applied) for Accubar
Public TrueUpBeamStg As Float 'user input stage reference to calculate (and apply) offset to raw upbeam data to output "UpBeamStg"
Public TrueVMPressStg As Float 'user input stage reference to calculate (and apply) offset to raw ADCP pressure sensor data to output "VMPressStg"
Public TruePS1Stg As Float 'user input stage reference to calculate (and apply) offset to raw Pressure sensor 1 data to output "PS1Stg"
Public TruePS2Stg As Float 'user input stage reference to calculate (and apply) offset to raw pressure sensor 2 data to output "PS2Stg"
Dim SelStgPrime As String 'which of the 5 stage options is used to calculate discharge
Public SelStgSecnd As String 'Which of the 5 stage options is used to calculate stage difference
Public UpBeamOffset As Float 'offset applied to raw data to get stage value
Public VMPressOffset As Float'offset applied to raw data to get stage value
Public PS1Offset As Float'offset applied to raw data to get stage value
Public PS2Offset As Float'offset applied to raw data to get stage value
Public BBLOffset As Float'offset applied to raw data to get stage value
Public StgSelect As String 'numerical indicator of which instrument is being used to calculate discharge within the datalogger
Public Area As Float 'calculated channel area based on stage-area rating
Public BadStgFlag As Boolean 'indicates bad stage value
Public BadStgCount As Long 'indicates number of times bad stage values have occured
Public MaxExpStg As Long 'maximum expected stage
Public MinExpStg As Long 'minimum expected stage

'Declare Rating Variables
'Should we make these arrays for easier output?
Public StgOffset As Float 'stage-area equation coefficient
Public StgCoef As Float 'stage-area equation coefficient
Public StgCoef2 As Float 'stage-area equation coefficient
Public VelOffset As Float 'iVel equation coefficient
Public VelCoef As Float 'iVel equation coefficient
Public VelCoef2 As Float 'iVel equation coefficient
Public VelCoef3 As Float 'iVel equation coefficient
Public UpVelOffset As Float 'iVel equation coefficient for velocities above transition point (in break point rating)
Public UpVelCoef As Float 'iVel equation coefficient for velocities above transition point (in break point rating)
Public UpVelCoef2 As Float 'iVel equation coefficient for velocities above transition point (in break point rating)
Public UpVelCoef3 As Float 'iVel equation coefficient for velocities above transition point (in break point rating)
Public LowVelOffset As Float 'iVel equation coefficient for velocities below transition point (in break point rating)
Public LowVelCoef As Float 'iVel equation coefficient for velocities below transition point (in break point rating)
Public LowVelCoef2 As Float 'iVel equation coefficient for velocities below transition point (in break point rating)
Public LowVelCoef3 As Float 'iVel equation coefficient for velocities below transition point (in break point rating)
Public Trans As String * 4 'Transition point in velocity where iVel calulation decides to use upper or lower rating equation
'                           Float was used, changed to a 3 character string in case someone accidentally types a number in, this will allow user to revert back to "NAN" -TAV 20141208

    
'variables for aquarius table
Public AvgIndexVel As Float
Public AvgVMTemp As Float
Public AvgVMPitch As Float
Public AvgVMRoll As Float
Public AvgPS1Stg As Float
Public AvgPS2Stg As Float
Public AvgBBLstage As Float
Public AvgUpBeamStg As Float

'Declare variables for velocity meter data
Public VMtempF As Float
Public VMupBeam As Float
Public VMpressure As Float
Public VMHeading As Float
Public VMpitch As Float
Public VMroll As Float
Public VMVolts As Float
Public VMtempC As Float
Public VMdataIn As Boolean
'------------------------String used to send specific data through serial communications to another logger-------------------
'Public OutString As String * 1000 'string of variables/values to be sent out to another datalogger
Public SendFlowData As Boolean 'user selectable flag to send only flow data


'-------------------------------------------------------DEBUGGIMG!!!!!-------------------------------------------------
#If Debugging = True Then
  Public DepthMSB As Long 'debugging variables
  Public DepthMSB1 As Long'debugging variables
  Public DepthLSB As Long'debugging variables
  Public DepthLSB1 As Long'debugging variables
  Public IDwords(14) As Long
  Public LSBTemp As Long
  Public LSB1Temp As Long
  Public MSBTemp As Long
  Public MSB1Temp As Long
  Public Subscans As Long
  Public EnsBytes As Long
  Public MissedEns As Long
  Public ADCPLoop As Long
  Public ADCPDone As Boolean
  Public ScanDiff As Long
  Public ScanStart
  Public ScanEnd
  Public GetStageStart
  Public GetStageEnd
  Public GetStageTotTime
  Public WakeVMStart
  Public WakeVMEnd
  Public WakeVMTotTime
  Public VMInfoStart
  Public VMInfoEnd
  Public VMInfoTotTime
  Public VMLoopStart
  Public VMLoopEnd
  Public VMLoopTotTime
  Public CDMACheckStart
  Public CDMACheckEnd
  Public CDMACheckTotTime
  Public ZeroVMTimeStart
  Public ZeroVMTimeEnd
  Public ZeroVMTotTime
  Public ChkSumChkStart
  Public ChkSumChkEnd
  Public ChkSumChkTotTime
  Public MainDecodeStart
  Public MainDecodeEnd
  Public MainDecodeTotTime
  Public CalcRangeStart
  Public CalcRangeEnd
  Public CalcRangeTotTime
  Public OneMinCalcStart
  Public OneMinCalcEnd
  Public OneMinCalcTotTime
  Public CalcQStart
  Public CalcQEnd
  Public CalcQTotTime
  Public GetVMMemStart
  Public GetVMMemEnd
  Public GetVMMemTotTime
  Public VMTimeStart
  Public VMTimeEnd
  Public VMTotTime
  Public CallBmChkStart
  Public CallBmChkEnd
  Public CallBmChkTotTime
  Public DataTabsStart
  Public DataTabsEnd
  Public DataTabsTotTime
  Public DataOutStart
  Public DataOutEnd
  Public DataOutTotTime
  Public Data1mStart
  Public Data1mEnd
  Public Data1mTotTime
  Public AQTabStart
  Public AQTabEnd
  Public AQTabTotTime
  Public StoreToCrdStart
  Public StoreToCrdEnd
  Public StoreToCrdTotTime
  Public ChkSpikeStart
  Public ChkSpikeEnd
  Public ChkSpikeTotTime
  Public AddSpikeStart
  Public AddSpikeEnd
  Public AddSpikeTotTime
  Public ProcessTime
  Public DataOutCount
  Public AQcount
  Public Data1mCount
  Public CardBadCount
  Public CardOkCount
  Dim DebugTimer
#Else
  Dim DepthMSB As Long 'debugging variables
  Dim DepthMSB1 As Long'debugging variables
  Dim DepthLSB As Long'debugging variables
  Dim DepthLSB1 As Long'debugging variables
  Dim IDwords(14) As Long
  Dim LSBTemp As Long
  Dim LSB1Temp As Long
  Dim MSBTemp As Long
  Dim MSB1Temp As Long
  Dim Subscans As Long
  Dim EnsBytes As Long
  Dim MissedEns As Long
  Dim ADCPLoop As Long
  Dim ADCPDone As Boolean
  Dim ScanDiff As Long
  Dim ScanStart
  Dim ScanEnd
  Dim GetStageStart
  Dim GetStageEnd
  Dim GetStageTotTime
  Dim WakeVMStart
  Dim WakeVMEnd
  Dim WakeVMTotTime
  Dim VMInfoStart
  Dim VMInfoEnd
  Dim VMInfoTotTime
  Dim VMLoopStart
  Dim VMLoopEnd
  Dim VMLoopTotTime
  Dim CDMACheckStart
  Dim CDMACheckEnd
  Dim CDMACheckTotTime
  Dim ZeroVMTimeStart
  Dim ZeroVMTimeEnd
  Dim ZeroVMTotTime
  Dim ChkSumChkStart
  Dim ChkSumChkEnd
  Dim ChkSumChkTotTime
  Dim MainDecodeStart
  Dim MainDecodeEnd
  Dim MainDecodeTotTime
  Dim CalcRangeStart
  Dim CalcRangeEnd
  Dim CalcRangeTotTime
  Dim OneMinCalcStart
  Dim OneMinCalcEnd
  Dim OneMinCalcTotTime
  Dim CalcQStart
  Dim CalcQEnd
  Dim CalcQTotTime
  Dim GetVMMemStart
  Dim GetVMMemEnd
  Dim GetVMMemTotTime
  Dim VMTimeStart
  Dim VMTimeEnd
  Dim VMTotTime
  Dim CallBmChkStart
  Dim CallBmChkEnd
  Dim CallBmChkTotTime
  Dim DataTabsStart
  Dim DataTabsEnd
  Dim DataTabsTotTime
  Dim DataOutStart
  Dim DataOutEnd
  Dim DataOutTotTime
  Dim Data1mStart
  Dim Data1mEnd
  Dim Data1mTotTime
  Dim AQTabStart
  Dim AQTabEnd
  Dim AQTabTotTime
  Dim StoreToCrdStart
  Dim StoreToCrdEnd
  Dim StoreToCrdTotTime
  Dim ChkSpikeStart
  Dim ChkSpikeEnd
  Dim ChkSpikeTotTime
  Dim AddSpikeStart
  Dim AddSpikeEnd
  Dim AddSpikeTotTime
  Dim ProcessTime
  Dim DataOutCount
  Dim AQcount
  Dim Data1mCount
  Dim CardBadCount
  Dim CardOkCount
  Dim DebugTimer
#EndIf
'---------------------------------------------------------DEBUGGING!---------------------------------------------------------

#If HasVM Then
  '---------VM Diagnostic Variables
  'Public PowerSwitch As Boolean 'does user want to allow power to be cycled on ADCP
  Public Banner As String * 200 'ADCP response from sending a break
  Public Warning As String * 2000 'echo of ADCP response for anything other than a break
  Public CMD As String 'user entered command for the ADCP, ex: make bin size 250cm = "ws250"
  Public CSCmd As String * 10 'echo of CS (deploy command) to ensure ADCP deployed properly
  Public SendCMD As Boolean 'after command is input in "CMD" user must turn this to "true" to actually send the command to ADCP
  Public WakeUpVM As Boolean 'send a break/cycle power to ADCP in case it went to sleep. manual switch
  Public VMRestartAttempts As Long 'how many times has the ADCP tried to restart
  Public VMLowMem As Boolean 'indicator if ADCP internal  memory is below user threshold
  Public VMLowMemCount As Float 'how many times ADCP internal memory is below user threshold
  Public VMMemFree As Float 'how much internal memory does the ADCP have remaining
  Public VMLowMemVal As Float 'user threshold for "low internal memory"
  Public RecErased As Boolean 'flag indicating the internal memory was erased
  Public RecEraseString As String * 200 'echo of response from ADCP when internal memory is erased (also acts as indicator to trigger "RecErased" flag)
#EndIf

PreserveVariables 'preserve values in case of power outages
SetStatus ("USRDriveSize",16384)

'15 MINUTE DATA OUTPUT TABLE
'data output table has no DataInterval instruction
'execution of table is controlled completely by main code logic below.
  DataTable (DataOut,Rec15minFlag,-1)'records data only when Record Flag = yes
    OpenInterval 'tells table to process from last execution of table
    CardOut (0,17280) 'sends copy of data to CF card
    Sample (1,SiteID,String)
    Sample (1,SiteNum,String)
    Sample (1,IndexVel,IEEE4)
    Average (1,IndexVel,IEEE4,BadVelFlag)
    Average (1,MeanVel,IEEE4,BadQFlag)
    Average (1,Qcfs,IEEE4,BadQFlag)
    Sample (1,StagePrime,IEEE4)
    Average (1,StagePrime,IEEE4,BadStgFlag)
    Sample (1,StageSecnd,FP2)
    Average (1,StageSecnd,IEEE4,false)
    Average (1,PS1Stg,IEEE4,false)
    Average (1,PS2Stg,IEEE4,false)
    Sample (1, BBLstage,IEEE4)
    Average (1,BBLstage,IEEE4,false)
    Average (1,UpBeamStg,IEEE4,false)
    Average (1,VMPressStg,IEEE4,false)
    Average (1,StgDiff,IEEE4,False)
    Sample (1,StgSelect,String)
    Average (1,VMpitch,FP2,False)
    Average (1,VMroll,FP2,False)
    Average (1,VMtempC,FP2,False)
    Sample (1,VMHeading,FP2)
    Minimum (1,CR1Volts,FP2,False,False)
    Minimum (1,VMVolts,FP2,False,False)
    Sample (1,BadStgCount,FP2)
    Sample (1,BadVelCount,FP2)
    Sample (1,BadQCount,FP2)
    Sample (1,LowRatVel,FP2)
    Sample (1,HighRatVel,FP2)
    Minimum (1,ExtSolarVolt,FP2,False,False)
    Average (MaxBins,VMBinVel(),IEEE4,VmBinVelDisable())
    Average(MaxBins,V1(),FP2,V1Disable())
    Average(MaxBins,V2(),FP2,V2Disable())
    Average(MaxBins,V3(),FP2,V3Disable())
    Average(MaxBins,V4(),FP2,V4disable())
    Average(1,AvgSwathRSSI,FP2,False)
  EndTable

  DataTable (Aquarius,Rec15minFlag,-1)
    CardOut (0,17280)
    OpenInterval
    Minimum (1,CR1Volts,FP2,False,False)
    Sample (1,AvgPS1Stg,IEEE4)
    Sample (1,AvgPS2Stg,IEEE4)
    Sample(1,AvgBBLstage,IEEE4)
    Sample (1,AvgUpBeamStg,IEEE4)
    Sample (1,AvgIndexVel,IEEE4)
    Minimum (1,VMVolts,FP2,False,False)
    Sample (1,AvgVMTemp,IEEE4)
    Sample (1,AvgVMPitch,IEEE4)
    Sample (1,AvgVMRoll,IEEE4)
  EndTable

'And it is called at Midnight
'QAQC table that is called at midnight and gets pertainent information
DataTable  (QAQCInfo,Rec24HrFlag,-1)
  CardOut (0,180) 'sends copy of data to CF card (Will store a lot of data on card)
  'Store system info here
  Sample (1,SiteID,String)
  Sample (1,SiteNum,String)
  Sample (1,Tech,String)
  Sample (1,VisitReason,String
  Sample (1,Program,String)
  Sample (1,ProgVersDate,String)
  Sample (1,ProgVersion, String)
  Sample (1,SerNum,Long)
  Sample (1,OSVers,String)
  Sample (1,AdcpSN,Long)
  Sample (1,IsCM,Boolean)
  Sample (1,NewADCP,Boolean)
  Sample (1,PS1SN,String)
  Sample (1,NewPS1,Boolean)
  Sample (1,PS2SN,String)
  Sample (1,NewPS2,Boolean)
  Sample (1,BBLSN, String)
  Sample (1,NewBBL, Boolean)
  Sample (1,BBLUnits,Float) 
  Sample (1,EX,Long)'how is the vm setup
  Sample (1,Coord,String)
  Sample (1,Decode,String)
  Sample (1,ProgErrors,Long)
  Sample (1,Low12Volts,Long)
  Sample (1,LithBat,FP2)
  Sample (1,SkipScans,Long)
  Sample (1,FreeCFMem,IEEE4)
  Sample (1,LowMeas,Boolean)
  Sample (1,HighMeas, Boolean)
  Sample (1,BadQCount,Long)
  Sample (1,BadVelCount,Long)
  Sample (1,BadBinCnt,Long)
  Sample (1,BadEnsCount,FP2)
  Sample (1,BadStgCount,Long)
  Sample (1,VMRestartAttempts,FP2)
  Sample (1,IndexVel,FP2)
  Sample (1,StagePrime,IEEE4)
  Sample (1,StageSecnd,IEEE4)
  Sample (1,SelStgPrime,FP2)
  Sample (1,SelStgSecnd,FP2)
  Sample (1,UpBeamStg,IEEE4)
  Sample (1,VMPressStg,IEEE4)
  Sample (1,PS1Stg,IEEE4)
  Sample (1,PS2Stg,IEEE4)
  Sample (1,BBLstage,IEEE4)
  Sample (1,UpBeamOffset,IEEE4)
  Sample (1,VMPressOffset,IEEE4)
  Sample (1,PS1Offset,IEEE4)
  Sample (1,PS2Offset,IEEE4)
  Sample (1,BBLOffset,IEEE4)
  Sample (1,VMtempC,FP2)
  Sample (1,VMpitch,FP2)
  Sample (1,VMroll,FP2)
  Sample (1,CR1Volts,FP2)
  Sample (1,ExtWHConvertVolt,FP2)
  Maximum (1,PTempC,FP2,false,false)
  Minimum (1,PTempC,FP2,false,false)
  Sample (1,NumADCPBins,FP2)
  Sample (1,NumBeams,FP2)
  Sample (1,EnsPings,FP2)
  Sample (1,BinSize,FP2)
  Sample (1,BlankDist,FP2)
  Sample (1,StartBin,FP2)
  Sample (1,EndBin,FP2)
  Sample (1,StartEbbBin,FP2)
  Sample (1,EndEbbBin,FP2)
  Sample (1,StartFldBin,FP2)
  Sample (1,EndFldBin,FP2)
  Sample (1,BiRatTran,FP2)
  Sample (1,UseBiRat,Boolean)
  Sample (1,CutOffBins,FP2)
  Sample (1,VMHeading,FP2)
  Sample (1,UseV2,Boolean)
  Sample (1,FlowSign,Long)
  Sample (1,CdmaWorks,Boolean)
  Sample (1,StgOffset,IEEE4)
  Sample (1,StgCoef,IEEE4)
  Sample (1,StgCoef2,IEEE4)
  Sample (1,VelOffset,IEEE4)
  Sample (1,VelCoef,IEEE4)
  Sample (1,VelCoef2,IEEE4)
  Sample (1,VelCoef3,IEEE4)
  Sample (1,UpVelOffset,IEEE4)
  Sample (1,UpVelCoef,IEEE4)
  Sample (1,UpVelCoef2,IEEE4)
  Sample (1,UpVelCoef3,IEEE4)
  Sample (1,LowVelOffset,IEEE4)
  Sample (1,LowVelCoef,IEEE4)
  Sample (1,LowVelCoef2,IEEE4)
  Sample (1,LowVelCoef3,IEEE4)
  Sample (1,Trans,FP2)
  Sample (1,VMLowMemCount,FP2)
  Sample (1,VMLowMem,Boolean)
  Sample (1,VMMemFree,FP2)
  Sample (1,RecErased,Boolean)
EndTable

'1 MINUTE DATA OUTPUT TABLE
DataTable (Data1m,Rec1MinFlag OR OneMinConsistent,-1)'if either flag is true the one min data table will be written
  OpenInterval
  CardOut (0,169600)'trippled allocation from 43,200 to allow for continous 1min data collection. Roughly 2 to 3 months of data
  Sample (1,SiteID,String)
  Sample (1,SiteNum,String)
  Sample (1,StagePrime,IEEE4)
  Sample (1,SelStgPrime,FP2)
  Sample (1,StageSecnd,IEEE4)
  Sample (1,SelStgSecnd,FP2)
  Sample (1,IndexVel,IEEE4)
  Sample (1,MeanVel,IEEE4,)
  Sample (1,Qcfs,IEEE4)
  Sample (MaxBins,VMBinVel(),IEEE4)
  Sample (MaxBins,V1(),IEEE4)
  Sample (MaxBins,V2(),IEEE4)
  Sample (MaxBins,V3(),IEEE4)
  Sample (MaxBins,V4(),IEEE4)
  Sample (1,RangedBin,FP2)
  Sample (1,CutOffBins,FP2)
  Sample (1,LowRatVel,FP2)
  Sample (1,HighRatVel,FP2)
EndTable

'BEAMCHECK DATA OUTPUT TABLE
DataTable (BeamCheck,RecBeamCheckFlag,-1)
  OpenInterval
  CardOut (0,17280)
  Sample (1,SiteID,String)
  Sample (1,StagePrime,IEEE4)
  Sample (1,NumBeams,Long)
  Sample (1,NumADCPBins,Long)
  Sample (1,BinSize,Long)
  Sample (1,StartBin,Long)
  Sample (1,EndBin,Long)
  Sample (1,VMpitch,FP2)
  Sample (1,VMroll,FP2)
  Average (MaxBins*4,ensRSSI(),UINT2,False)
  Average (MaxBins*4,ensCorr(),UINT2,False)
  Sample (1,VMupBeam,IEEE4)
  Average (1,VMupBeam,IEEE4,False)
  Sample (1,VMtempC,IEEE4)
  Average (1,VMtempC,IEEE4,False)
  Sample (1,VMVolts,IEEE4)
  Average (1,VMVolts,IEEE4,False)
EndTable

'___________Field Readings Table____________
'This table will only store a single record.
'Techs can access it for field readings in SVMaq rather than scrolling through the Public Table
DataTable (SVMaq,True,1)
  Sample (1,SiteID,String)
  Sample (1,SiteNum,String)
  Sample (1,Program,String)
  Sample (1,ProgVersDate,String)
  Sample (1,ProgVersion, String)
  Sample (1,CR1Volts,FP2)
  #If HasVM <> False Then
    Sample (1,StagePrime,FP2)
    Sample (1,StageSecnd,FP2)
    Sample (1,PS1Stg,FP2)
    Sample (1,PS2Stg,IEEE4)
    Sample (1,BBLstage, IEEE4)
    Sample (1,UpBeamStg,IEEE4)
    Sample (1,VMPressStg,IEEE4)
    Sample (1,IndexVel,FP2)
    Sample (1,VMpitch,FP2)
    Sample (1,VMroll,FP2)
    Sample (1,VMtempC,FP2)
    Sample (1,VMVolts,FP2)
    Sample (1,PS1Offset,IEEE4)
    Sample (1,PS2Offset,IEEE4)
    Sample (1,BBLOffset,IEEE4)
    Sample (1,UpBeamOffset,IEEE4)
    Sample (1,VMPressOffset,IEEE4)
  #EndIf
EndTable

DataTable (Debugger,True,-1)
  OpenInterval
  CardOut (0,1440)
  Sample (1,ScanStart,FP2)
  Sample (1,ScanEnd,FP2)
  Sample (1,GetStageStart, FP2)
  Sample (1,GetStageEnd, FP2)
  Sample (1,GetStageTotTime, FP2)
  Sample (1,WakeVMStart,FP2)
  Sample (1,WakeVMEnd,FP2)
  Sample (1,WakeVMTotTime,FP2)
  Sample (1,VMInfoStart,FP2)
  Sample (1,VMInfoEnd,FP2)
  Sample (1,VMInfoTotTime,FP2)
  Sample (1,VMLoopStart,FP2)
  Sample (1,VMLoopEnd,FP2)
  Sample (1,VMLoopTotTime,FP2)
  Sample (1,CDMACheckStart,FP2)
  Sample (1,CDMACheckEnd,FP2)
  Sample (1,CDMACheckTotTime,FP2)
  Sample (1,ZeroVMTimeStart,FP2)
  Sample (1,ZeroVMTimeEnd,FP2)
  Sample (1,ZeroVMTotTime,FP2)
  Sample (1,ChkSumChkStart,FP2)
  Sample (1,ChkSumChkEnd,FP2)
  Sample (1,ChkSumChkTotTime,FP2)
  Sample (1,MainDecodeStart,FP2)
  Sample (1,MainDecodeEnd,FP2)
  Sample (1,MainDecodeTotTime,FP2)
  Sample (1,CalcRangeStart,FP2)
  Sample (1,CalcRangeEnd,FP2)
  Sample (1,CalcRangeTotTime,FP2)
  Sample (1,OneMinCalcStart,FP2)
  Sample (1,OneMinCalcEnd,FP2)
  Sample (1,OneMinCalcTotTime,FP2)
  Sample (1,CalcQStart,FP2)
  Sample (1,CalcQEnd,FP2)
  Sample (1,CalcQTotTime,FP2)
  Sample (1,GetVMMemStart,FP2)
  Sample (1,GetVMMemEnd,FP2)
  Sample (1,GetVMMemTotTime,FP2)
  Sample (1,VMTimeStart,FP2)
  Sample (1,VMTimeEnd,FP2)
  Sample (1,VMTotTime,FP2)
  Sample (1,CallBmChkStart,FP2)
  Sample (1,CallBmChkEnd,FP2)
  Sample (1,CallBmChkTotTime,FP2)
  Sample (1,DataTabsStart,FP2)
  Sample (1,DataTabsEnd,FP2)
  Sample (1,DataTabsTotTime,FP2)
  Sample (1,DataOutStart,FP2)
  Sample (1,DataOutEnd,FP2)
  Sample (1,DataOutTotTime,FP2)
  Sample (1,Data1mStart,FP2)
  Sample (1,Data1mEnd,FP2)
  Sample (1,Data1mTotTime,FP2)
  Sample (1,AQTabStart,FP2)
  Sample (1,AQTabEnd,FP2)
  Sample (1,AQTabTotTime,FP2)
  Sample (1,StoreToCrdStart,FP2)
  Sample (1,StoreToCrdEnd,FP2)
  Sample (1,StoreToCrdTotTime,FP2)
  Sample (1,ChkSpikeStart,FP2)
  Sample (1,ChkSpikeEnd,FP2)
  Sample (1,ChkSpikeTotTime,FP2)
  Sample (1,AddSpikeStart,FP2)
  Sample (1,AddSpikeEnd,FP2)
  Sample (1,AddSpikeTotTime,FP2)
  Sample (1,ProcessTime,FP2)
  Sample (1,DataOutCount,FP2)
  Sample (1,Data1mCount,FP2)
  Sample (1,AQcount,FP2)
  Sample (1,CardBadCount,FP2)
  Sample (1,CardOkCount,FP2)
  Sample (1,OneMinCount,FP2)
EndTable

'____________________________________SUBROUTINES__________________________________________

'________________________________Get Startup Information__________________________________
Sub GetStartup
  'look at startup table to see if user set UseDefaults to no
  '  If Startup.StartPrams(1,1) <> "false" Then 'insert default values
  '    UseDefaults = "false"
  ProgVersDate = ProgramVersionDate
  ProgVersion =ProgramVersion
  LastScan = "00:00"
  '******************Below are the default stations Parameters (~ line 740) *********************
  Tech = "TEC"
  SiteID = "xxx"
  SiteNum = "12345678"
  VisitReason = "Program update"
  'Default Flow setup values
  'Note if using bi-rating start and end must include all EBB and FLOOD bins
  StartBin = 1
  EndBin = 27
  StartEbbBin = 1 'used for bi-directional rating
  EndEbbBin = 27 'used for bi-directional rating
  StartFldBin = 1 'used for bi-directional rating
  EndFldBin = 27  'used for bi-directional rating
  BiRating = False 'set to true if using bi-directional rating
  BiRatTran = 0 'set to transition velocity for bi-directional rating
  MinExpStg = 0
  MaxExpStg = 30
  MinExpVel = -5
  MaxExpVel = 6
  LowRatVel = 0
  HighRatVel = 0
  FlowSign = 1
  SelStgPrime = BBL
  SelStgSecnd = UPbeam
  UpBeamOffset = 0
  VMPressOffset = 0
  PS1Offset = 0
  PS2Offset = 0
  BBLoffset = 0
  'default communication setup
  PSPressPort = 3
  PSPressAddr = 0
  PSpress2Port = 5
  PSpress2Addr = 0
  BBLPort = 7
  BBLAddr =0
  'Default rating variables
  CalcQ = Yes 'change to yes if Q calculations are needed
  'Area Rating:
  StgOffset = 0
  StgCoef = 0
  StgCoef2 = 0
  'meanvel rating:
  VelOffset = 0
  VelCoef = 0
  VelCoef2 = 0
  VelCoef3 = 0
  UpVelOffset = 0
  UpVelCoef = 0
  UpVelCoef2 = 0
  UpVelCoef3 = 0
  LowVelOffset = 0
  LowVelCoef = 0
  LowVelCoef2 = 0
  LowVelCoef3 = 0
  Trans = NAN
  'Misc settings
  AvgRSSIStartBin = StartBin
  AvgRSSIEndBin  = EndBin
  '****************Above are the default stations Parameters************************
  '________________________________________________________________________________________________________
  '
  'initialize other important program variables (typically don't need to be changed)
  BiRatOK  = False 'Used by program to determin if BiRating can be done (if using CM with Instrument Coords). do not change manually, SET TO FALSE HERE
  UseBiRat = False 'flag set BY PROGRAM if both the above are true.  do not change manually, SET TO FALSE HERE
  InitialHRV = HighRatVel
  InitialLRV = LowRatVel
  InitialAdcpSN = 0
  InitialPS1SN = 0
  InitialPS2SN = 0
  InitialBBLSN = 0
  VMPower = Yes
  IsCDMANClosed = Yes 'Default setting is for the existance of a normally closed cdma power relay
  isVMNClosed = Yes 'Default setting for the existance of a normally Closed VM power Relay
  KeepCDMAon = Yes 'CDMA is initially setup to stay on
  UseV2 = No 'switch to yes if you want Y velocities
  UseDir = No
  IsCM = Yes
  PosFlowDir = 0
  TrueUpBeamStg = BadDataIndicator
  TrueVMPressStg = BadDataIndicator
  TruePS1Stg = BadDataIndicator
  TruePS2Stg = BadDataIndicator
  RSSIThreshold = 8
  CorrThreshold = 15
  SelectFilter = 1
  HrsCdmaOff = 4
  CDMAFailure = No
  SendFlowData = False
  'since the first time the data tables are called there is no data, then
  'initially set all the bad data flags to true so no processing occurs
  'Set ODD store data flags to no
  Rec1MinFlag = No
  OneMinCount = 0
  RecordAll = No
  RecDataFlag = False
  BadStgFlag = Yes
  BadVelFlag = Yes
  BadQFlag = Yes
  LowCount = 0 'counter for # of times Ivel is below rating
  HighCount = 0 'counter for # of times Ivel is above rating
  LowMeas = No 'below rating flag
  HighMeas = No 'above rating flag
  VMLowMemVal = 0
  If IsCDMANClosed Then
      SW12(1,0) 'turn on telemetery if there is a Normally closed relay present.
  Else
      SW12(1,1) 'turn on telemetery if there's no NC relay present
  EndIf
  IsCDMAOn = Yes
EndSub

'____________________________________LastScan Subroutine__________________________________
'now lets create the LastScan variable for keypad menu
'Stores current hour and minute in the LastScan Variable
Sub GetLastScan
  RealTime (rTime()) 'get real time array
  If Minute >= 0 AND Minute < 10 Then
    LastScan = Hour + ":0" + Minute
  Else
    LastScan = Hour + ":" + Minute
  EndIf
EndSub

'_______________________________ Initialize variables ___________________________________________________
Sub Initialize
  VMdataIn = No
  ScanNo = 0
  BadChecksum = 0
  HeaderMismatch = 0
  NumbytesZero = 0
  ReceivedBytes = 0
  WakeUpVM = No
  SetVMTimeFlg = No
  StoreVariablesFlg = No
  GetVariablesFlg = True
  VMRestartAttempts = 0
  AvgRSSIcounter = 0
  AvgRSSIAccum = 0
  AvgSwathRSSI = 0

  'An array of longs is needed to collect the data because the campbell cannot read the
  'binary PD0 ensemble into a string.  When it hits a blank (HEX 00) it terminates the
  'string cutting off the rest of the ensemble'
  'so to get around this, we read in the data (one byte at a time) and put it into an
  'array of longs.  But at this point there is another problem. RDI transmits binary
  'data in "little indian" fashon (least significant byte first), but longs (two bytes)
  'are stored by campbell "big indian" (most significant byte first), so after we read
  'the byte in (to a temporary long),it is in the most significant byte.  We then must use the
  'MoveBytes statement to move it into the least significant position and store it in
  'the long array.
  Erase(Longarray())
  EndSub

'______________________________Get System Information_____________________________________
Sub GetSysInfo
  Battery (CR1Volts) 'get battery volts
  SerNum = Status.SerialNumber(1,1)
  OSVers = Status.OSVersion(1,1)
  Program = Status.ProgName(1,1)
  ProgErrors = Status.ProgErrors(1,1)
  Low12Volts = Status.Low12VCount(1,1)
  LithBat = Status.LithiumBattery(1,1)
  SkipScans = Status.SkippedScan(1,1)
  FreeCFMem = Status.CardBytesFree(1,1)
EndSub

'__________________________________CDMA Check Subroutine__________________________________
Sub CdmaCheck
  Select Case IsCDMANClosed
  Case Yes'if relay exists
    If KeepCDMAon = Yes Then 'if want CDMA on
        SW12(1,0)
      IsCDMAOn = Yes
      EndIf
  Case No 'if relay does not exist
    If KeepCDMAon = Yes Then 'want CDMA to stay on
        SW12(1,1)
      IsCDMAOn = Yes
      EndIf
  EndSelect
  If CycleCdmaPwr = Yes Then
    If IsCDMANClosed Then
      SW12(1,1)
    Else
        SW12(1,0)
    EndIf  'manual cycle power Open the circuit to the CDMA
    IsCDMAOn = No
    CycleCdmaPwr = No
  EndIf
  LoggernetAddr = Route(4094)
  If LoggernetAddr = 4094 Then
    CdmaWorks = Yes
    CdmaScans = 0
    CDMAFailure = No
  Else 'cycle power to CDMA
    CdmaWorks = No
    CdmaScans = CdmaScans + 1
    If (CdmaScans >= HrsCdmaOff * (FastLoopInterval * 4)) AND (EventCDMAFlag = No) Then 'Fastloop interval is no of Subscans per 15 min so * 4 is scans per hour
      If IsCDMANClosed Then
          SW12(1,1)
      Else
          SW12(1,0)
      EndIf  'cycle cdma off after 4 hours (Open the Circuit to the CDMA)
      IsCDMAOn = No
      CDMAFailure = Yes
      CdmaScans = 0
    EndIf
  EndIf
EndSub

#If HasVM = True Then
'---------------------Send a command to the ADCP -- Check Responses
'This subroutine is primarily used for 'expert' operators to issue command changes to the ADCP.  As written, only one command at a time can be issued from the
'user interface.  The ADCP echos and responsed are viewed from the "banner", "warning" and "CS" response variables. This capability is not available from the
'keypad, and can only be used from loggernet! Because of CR1000 limitations, the ADCP must have it's power cycled to simulate the RDI "Break" signal!
'Sub (SendSetup)
'  If (SendCMD) Then
'    Banner = ""
'    Warning = ""
'    CSCmd = ""
'    If CMD = "" Then
'      SendCMD = False
'      ExitSub
'    EndIf
'    SerialFlush (AdcpPort)
'    'Turn Power on and off to ADCP
'    Call CycleVMPower
'    Call OpenADCPPort
'    ''SerialOut (COMRS232,"+++","",0,100)'send alt break command
'    Delay (1,1,Sec)'wait for reply
'    SerialIn (Banner,AdcpPort,500,">",200)'get banner from ADCP
'    'SerialIn (Prompt,AdcpPort,100,13,100)'ge
'    SerialFlush (AdcpPort)
'    ''send commands to HADCP
'    Delay (1,1,Sec)'wait for reply
'    'send a command
'    SerialOut (AdcpPort,"+++" + CHR(13) + CHR(10),"",0,100)'Send
'    SerialIn (Banner,AdcpPort,500,">",200)'get banner from ADCP
'    SerialIn (Prompt,AdcpPort,100,-1,100)
'    SerialFlush (AdcpPort)
'    Delay (1,500,mSec)'wait for reply
'    SerialOut (AdcpPort,CMD + CHR(13) + CHR(10),"",0,100)'Send
'    SerialIn (Warning,AdcpPort,150,-1,2000)'Get Warning (if any) from ADCP
'    SerialFlush (AdcpPort)
'    SerialOut (AdcpPort,"CS" + CHR(13) + CHR(10),"",0,100)'CS command to start pinging
'    SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
'    SerialFlush (AdcpPort)
'    SendCMD = False
'    Call EraseWH
'  EndIf
'EndSub
'Open ADCP port
'----------------------------------------------
Sub OpenADCPPort
      SerialOpen (AdcpPort,VmBaud,3,0,2000) 'open ADCP PORT with 2000 byte buffer using format 3
EndSub
#EndIf'end of "If Has VM"

'_________________________Erase WH Recorder___________________________________
'Sub EraseWH
'  If CMD = "RE ErAsE" Then 'If command to erase WH recorder is sent then...
'    RecEraseString = Mid (Warning,23,15)  'Parse string to get "Recorder erased" from response
'  Else
'    RecEraseString = ""
'  EndIf
'  If RecEraseString = "Recorder erased" Then 'if the recorder was successfully erased, flag it in data table
'    RecErased = True
'  EndIf
'  If IfTime (10,1440,min) AND RecErased = True Then 'Reset Recorder erase flag to false at 00:10 (allows time for flag to be written to QAQC table).
'    RecErased = False
'  EndIf
'EndSub

'_____________________________Wake VM________________________
#If HasVM Then
  Sub WakeVM
    'send a CS command To wake up VM in Case it has gone To sleep
    Banner = ""
    CSCmd = ""
    Call CycleVmPower 'give it a jolt and then send a CS command
    Call OpenAdcpPort
      Delay (1,1,Sec)'wait for reply
      SerialIn (Banner,AdcpPort,100,-1,100)'get banner from ADCP
      SerialFlush (AdcpPort)
      SerialOut (AdcpPort,"CS"+ CHR(13) + CHR(10),"",0,100)
      SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
      SerialFlush (AdcpPort)
      VMRestartAttempts = VMRestartAttempts + 1
    VmDeadCount = 0 'set to zero and try again
  EndSub
#EndIf

'the program uses less ADCP processing time if the ADCP and Logger times are synchronized
'So this Sub is called to Sychronize the logger and VM times
'--------------------------------------------------------------------
Sub SetVMTime
  VMTimeStart = Timer(DebugTimer,msec,4)
  VMTimeStart = VMTimeStart/1000
  Call CycleVmPower
  'The set time command to the VM Requires leading zeros, so the logger timestamp is split out and leading zeros added if needed
  RawSetTime = Status.Timestamp 'get latest time from datalogger
  SplitStr (SplitTime(),RawSetTime," ",6,0) 'take apart the time string
  #If Debugging = True Then
    Public SendVMMonth As String
    Public SendVMDay As String
    Public SendVmHour As String
    Public SendVmMin As String
    Public SendVmSec As String
    Public SendVmYear As String
  #Else
    Dim SendVMMonth As String
    Dim SendVMDay As String
    Dim SendVmHour As String
    Dim SendVmMin As String
    Dim SendVmSec As String
    Dim SendVmYear As String
  #EndIf
  If SplitTime(1) < 10 Then  'add leading zeros if needed
    SendVMMonth = "0" + SplitTime(1)
  Else
    SendVMMonth = SplitTime(1)
  EndIf
  If SplitTime(2) < 10 Then
    SendVMDay = "0" + SplitTime(2)
  Else
    SendVMDay = SplitTime(2)
  EndIf
  If SplitTime(4) < 10 Then
    SendVmHour = "0" + SplitTime(4)
  Else
    SendVmHour = SplitTime(4)
  EndIf
  If SplitTime(5) < 10 Then
    SendVmMin = "0" + SplitTime(5)
  Else
    SendVmMin = SplitTime(5)
  EndIf
  If Round(SplitTime(6),0) < 10 Then
    SendVmSec = "0" + Round(SplitTime(6),0) 'eliminate fractional seconds
  Else
    SendVmSec = Round(SplitTime(6),0)
  EndIf
  SendVmYear = Right(SplitTime(3),2)
  VMTimeString = "TS" + SendVmYear + "/" + SendVMMonth + "/" + SendVMDay + "," + SendVmHour + ":" + SendVmMin + ":" + SendVmSec 'Reconstruct time string

  Call OpenADCPPort
    SerialOut (AdcpPort,"+++","",0,100)'send alt break command
    Delay (1,1,Sec)'wait for reply
    SerialIn (Banner,AdcpPort,100,-1,100)'get banner from ADCP
    SerialFlush (AdcpPort)
    SerialOut (AdcpPort,VMTimeString + CHR(13) + CHR(10),"",0,100)
    SerialIn (Warning,AdcpPort,100,-1,100) 'get echo of CS command
    Delay (1,1,Sec)'wait for reply
    SerialOut (AdcpPort,"CS"+ CHR(13) + CHR(10),"",0,100)
    SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
  SetVMTimeFlg = false 'set the flag back to false until next time sychro
  VMTimeEnd = Timer(DebugTimer,msec,4)
  VMTimeEnd = VMTimeEnd/1000
  VMTotTime = VMTimeEnd - VMTimeStart
EndSub

'________________________________Cycle VM Power -- This is used similarly to the 'break' command because the CR1000 does not seem to have the ability to
'generate a break signal from its existing firmware -- I'm sure it's available in the UART, it's just not implimented!! _________________________________
'If power switch is installed then cycle VM power
Sub CycleVMPower
    SerialFlush (AdcpPort)
    'Turn Power on and off to ADCP assuming NC relay
    If isVMNClosed Then
      PortSet (VMSwitchPort,1 )
      Delay (1,3,Sec)
      PortSet (VMSwitchPort,0)
    Else
      PortSet (VMSwitchPort,0 )
      Delay (1,3,Sec)
      PortSet (VMSwitchPort,1)
    EndIf
EndSub
'_________________________________Turns VM Off if user selected VMPower = false __________________________________________________________________
Sub ToggleVMPower
  '  If PowerSwitch = True
    If VMPower = True Then
      ExitSub
    EndIf
    If VMPower = False Then
      SerialFlush (AdcpPort)
      'Turn Power on and off to ADCP
      If isVMNClosed Then
        PortSet (VMSwitchPort,1) 'assumes NC relay
      Else
        PortSet (VMSwitchPort,0) 'NO relay
      EndIf
    EndIf
EndSub

'__________________________Get Instrument Serial Numbers_________________
'Sub GetSN
'  If (ModDay > 79270) AND (ModDay < 79390) AND RecCalibData = False Then 'if 2200hrs + 1-3 minutes and not Calbrating then get serial numbers of all
'    AdcpSN = AdcpSN
'    If AdcpSN <> InitialAdcpSN Then
'      NewADCP = True
'      InitialAdcpSN = AdcpSN 'set the new s/n to initial
'    Else
'      NewADCP = False
'    EndIf
'    Select Case PSPressPort
'    Case 3
'      SDI12Recorder (PS1SN,PS1Com3,PSPressAddr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from pressure sensors.
'      If PS1SN <> InitialPS1SN Then
'        NewPS1 = True
'        InitialPS1SN = PS1SN 'Set the new sn to initial
'      Else
'        NewPS1 = False
'      EndIf  'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
'    Case 5
'      SDI12Recorder (PS1SN,PS1Com5,PSPressAddr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from pressure sensors.
'      If PS1SN <> InitialPS1SN Then
'        NewPS1 = True
'        InitialPS1SN = PS1SN 'Set the new sn to initial
'      Else
'        NewPS1 = False
'      EndIf                                      'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
'    EndSelect
'    Select Case PSpress2Port
'    Case 3
'      SDI12Recorder (PS2SN,PS2Com3,PSpress2Addr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from pressure sensors.
'      If PS2SN <> InitialPS2SN Then
'        NewPS2 = True
'        InitialPS2SN = PS2SN 'Set the new sn to initial
'      Else
'        NewPS2 = False
'      EndIf                                     'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
'    Case 5
'      SDI12Recorder (PS2SN,PS2Com5,PSpress2Addr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from pressure sensors.
'      If PS2SN <> InitialPS2SN Then
'        NewPS2 = True
'        InitialPS2SN = PS2SN 'Set the new sn to initial
'      Else
'        NewPS2 = False
'      EndIf                                     'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
'    EndSelect
'     SDI12Recorder (BBLSN,BBLCom7,BBLAddr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from bubbler.
'      If BBLSN <> InitialBBLSN Then
'        NewBBL = True
'        InitialBBLSN = BBLSN 'Set the new sn to initial
'      Else
'        NewBBL = False
'      EndIf  'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
'  EndIf 'end if midnight
'EndSub

'____________________________________Calculates interval for filter loops
Sub CalcLoopInterval
  Dim UnitMult As Float
  Select Case ScanUnit
  Case = 1
    UnitMult = 60000  'milliseconds in minute
  Case = 2
    UnitMult = 60     'seconds in minute
  Case = 3
    UnitMult = 1    'minutes in minute
  Case = 4
    UnitMult = 0.0166666666  'hours in minute (ok we'll probably never use this scan rate but just to be safe!!!!)
  Case = 5
    UnitMult = 0.0006944444  'days in minute (Only if we're measuring lake evaportation!!!!)
  EndSelect
  LoopInterval = (UnitMult/ScanRate) * 15 'number of scans in 15 minutes

  Select Case FastScanUnit
  Case = 1
    UnitMult = 60000  'milliseconds in minute
  Case = 2
    UnitMult = 60     'seconds in minute
  Case = 3
    UnitMult = 1    'minutes in minute
  Case = 4
    UnitMult = 0.0166666666  'hours in minute (ok we'll probably never use this scan rate but just to be safe!!!!)
  Case = 5
    UnitMult = 0.0006944444  'days in minute (Only if we're measuring lake evaportation!!!!)
  EndSelect
  FastLoopInterval = (UnitMult/FastScanRate) * 15 'number of scans in 15 minutes
EndSub

'______________________________Main Decoder___________________________________________________________
'Main Decoder for Workhorse PD0 file.  This Is run after incoming data has passed checks in main program scan.
'This decoder parses out the various data types and the varibles that are contained in the fixed header data type.
'The variable data types are decoded in separate subroutines and those subroutines are called from this subroutine.
Sub MainDecode
  Dim OffsetCounter As Long
  Dim TypeCounter As Long
  Dim IdCounter As Long
  'First decode PD0 header
  Datatypes = Longarray(6)
  Datatypes = Datatypes + 1 'Include the vertical data"
  OffsetCounter = 1
  'Get data offsets for each data type
  For TypeCounter = 1 To (Datatypes*2) Step 2
    LSB = Longarray(TypeCounter+6)
    MSB = Longarray(TypeCounter+7)
    Offsets(OffsetCounter)=(LSB + (MSB*256)) + 1
    OffsetCounter = OffsetCounter + 1
  Next TypeCounter
  'Get fixed leader offset
  FixedLeadOffset = Offsets(1)
  'Get variable leader offset
  VarLeadOffset = Offsets(2)
  'Now decode the fixed leader
  'get number of Beams
  NumBeams = Longarray(FixedLeadOffset + 8)
  'Get number of Bins
  NumADCPBins = Longarray(FixedLeadOffset + 9)
  If NumADCPBins >= MaxBins Then
    Numbins = MaxBins
  EndIf
  'Get Pings per Ensemble
  LSB = Longarray(FixedLeadOffset + 10)
  MSB = Longarray(FixedLeadOffset + 11)
  EnsPings = LSB + (MSB * 256)
  'Get Bin Size
  LSB = Longarray(FixedLeadOffset + 12)
  MSB = Longarray(FixedLeadOffset + 13)
  BinSize = LSB + (MSB * 256)
  'Get Blanking distance
  LSB = Longarray(FixedLeadOffset + 14)
  MSB = Longarray(FixedLeadOffset + 15)
  BlankDist = LSB + (MSB * 256)
  EX = Longarray(FixedLeadOffset + 25)
  If EX <= 7 Then
    Coord = "BEAM"
    Select Case NumBeams
    Case 2
      Decode = "Radial Velocities - V1=Beam1 V2=Beam2 disregard V3 and V4"
    Case 3
      Decode = "Radial Velocities - V1=Beam1 V2=Beam2 V3=Beam3 disregard V4"
    Case 4
      Decode = "Radial Velocities - V1=Beam1 V2=Beam2 V3=Beam3 V4=Beam4"
    Case Else
      Decode = "System could not be decoded"
    End Select
    RecordAll = true 'Beam coordinates are only used by special studies
    UseDir = false
  EndIf
  If (EX <= 15) AND (EX > 7) Then
    Coord = "INST"
    Select Case NumBeams
    Case 2
      Decode = "Instrument Coordinates - V1=X V2=Y disregard V3 and V4"
      BiRatOK = True 'sets flag indication that this is a channel master in instrument coordinates and it's ok to use a bi-directional rating if needed
    Case 3
      Decode = "Instrument Coordinates - V1=X V2=Y disregard V3 V4=Error"
        BiRatOK = True 'It's ok to use the bi-rating if it is a 3-beam system and NOT an uplooker
    Case 4
      Decode = "Instrument Coordinates - V1=X V2=Y V3=Z and V4=Error"
      BiRatOK = False 'Don't allow use of bi-rating with uplookers.
    Case Else
      Decode = "System could not be decoded"
    End Select
    UseDir = false
  EndIf
  If (EX <= 23) AND (EX > 15) Then
    Coord = "SHIP"
    Select Case NumBeams
    Case 2
      Decode = "Error! --  Cannot set CM to ship coordinates"
    Case 3
      Decode = "Ship Coordinates - V1=Port V2=Starbord V3=Z and V4=Error"
    Case 4
      Decode = "Ship Coordinates - V1=Port V2=Starbord V3=Z and V4=Error"
    Case Else
      Decode = "System could not be decoded"
    End Select
    UseDir = false
  EndIf
  If (EX <= 31) AND (EX > 23) Then
    Coord = "EARTH"
    Select Case NumBeams
    Case 2
      Decode = "Error! --  Cannot set CM to Earth coordinates"
    Case 3
      Decode = "Earth Coordinates - V1=East V2=North V3=Z and V4=Error"
      RecordAll = true 'Special studies also uses earth coordinates
      UseDir = false
    Case 4
      Decode = "Earth Coordinates - V1=East V2=North V3=Z and V4=Error"
      RecordAll = true 'Special studies also uses earth coordinates
    Case Else
      Decode = "System could not be decoded"
    End Select
  EndIf
  'get instrument s/n
  ADCPSN01 = Longarray(FixedLeadOffset + 57)
  ADCPSN02 = Longarray(FixedLeadOffset + 56)
  ADCPSN03 = Longarray(FixedLeadOffset + 55)
  ADCPSN04 = Longarray(FixedLeadOffset + 54)
  AdcpSN = ADCPSN04 + (ADCPSN03*256) + (ADCPSN02*65536) +(ADCPSN01*16777216)
  '  TestADCPSN = ADCPSN04 + (ADCPSN03*256) + (ADCPSN02*65536) +(ADCPSN01*16777216)

  'get Variable Header Data
  Call VarLeadDecode
  'Loop through remaining data types, verify thier profile IDs and assign proper offsets'  Other data can be accomodated here if need be IE percent good etc
  'If profile IDs match the required data types, then call the appropriate decoders
  IsCM = No
  For IdCounter = 3 To Datatypes
    LSB = Longarray(Offsets(IdCounter))
    MSB = Longarray(Offsets(IdCounter) + 1)
    TempId = LSB + (MSB * 256)
    IDwords(IdCounter) = TempId
    Select Case TempId
    Case CorrelationProfileID
      'Ok it matches Correlation ID
      CorrDatOffset = Offsets(IdCounter)
      Call CorrelationDecode
    Case RSSIProfileID
      'OK it matches RSSI ID
      RSSIDatOffset = Offsets(IdCounter)
      Call RSSIDecode
    Case VelocityProfileID
      'OK it matches Velocity ID
      VelDatOffset = Offsets(IdCounter)
      Call VelDecode
    Case VMStageID
      'Ok it matches Surface track (vertical beam) Status ID
      VMStageDatOffset = Offsets(IdCounter)
      If NumBeams = 2 Then
        IsCM = Yes
      EndIf
      Call VMStageDecode
    EndSelect
  Next IdCounter
  'After calling all the decoders, Zero out the LongArray
  Erase (Longarray())
EndSub
'__________________________Variable Leader Decoder______________________________________
'This Sub decodes the variable leader from the longArray
Sub(VarLeadDecode)
  VarLeadOffset = VarLeadOffset - 1 'to line up with RDI Documentation
  'When you decode 2 byte binary data, you have to multiply the most significant byte
  'by 256
  LSB = 0
  MSB = 0
  temp = 0
  'get Ensemble Number
  LSB = Longarray(VarLeadOffset + 3)
  MSB = Longarray(VarLeadOffset + 4)
  MSB1 = Longarray(VarLeadOffset + 12)
  EnsembleNo = (65536 * MSB1) + (256 * MSB) + LSB
  'get Vm time
  VMYear = Longarray(VarLeadOffset + 5)
  VMMonth = Longarray(VarLeadOffset + 6)
  VMDay = Longarray(VarLeadOffset + 7)
  VMHour = Longarray(VarLeadOffset + 8)
  VMMinute = Longarray(VarLeadOffset + 9)
  VMSecond = Longarray(VarLeadOffset + 10)
  VMTime = VMYear + "/" + VMMonth + "/" + VMDay + " " + VMHour + ":" + VMMinute + ":" + VMSecond
  'get Buit in test results
  LSB = Longarray(VarLeadOffset + 13)
  MSB = Longarray(VarLeadOffset + 14)
  BIT = (256 * MSB) + LSB
  'get Heading
  LSB = Longarray(VarLeadOffset + 19)
  MSB = Longarray(VarLeadOffset + 20)
  VMHeading = ((256 * MSB) + LSB) * 0.01 'Heading scale factor
  'get Pitch
  LSB = Longarray(VarLeadOffset + 21)
  MSB = Longarray(VarLeadOffset + 22)
  temp = (256 * MSB) + LSB
  If temp > 32767 Then
    temp = temp - 65536
  EndIf
  VMpitch = temp * 0.01 'Pitch scale factor
  'get Roll
  LSB = Longarray(VarLeadOffset + 23)
  MSB = Longarray(VarLeadOffset + 24)
  temp = (256 * MSB) + LSB
  If temp > 32767 Then
    temp = temp - 65536
  EndIf
  VMroll = temp * 0.01 'Roll scale factor
  'Get Salinity
  LSB = Longarray(VarLeadOffset + 25)
  MSB = Longarray(VarLeadOffset + 26)
  temp = (256 * MSB) + LSB
  ES = temp
  'Get Temperature
  LSB = Longarray(VarLeadOffset + 27)
  MSB = Longarray(VarLeadOffset + 28)
  temp = (256 * MSB) + LSB
  If temp > 32767 Then
    temp = temp - 65536
  EndIf
  VMtempC = temp * 0.01 'Temperature scale factor
  VMtempF = VMtempC * 9/5 + 32
  
  ScanDiff = EnsembleNo - ScanNo
EndSub

'_______________Decode Correlation data and averages beams for each bin_________________
Sub(CorrelationDecode)
  'initialize output Arrays
  For Bin = 1 To MaxBins
    For Beam = 1 To MaxBeams
      ensCorr(Bin,Beam) = 0
    Next Beam
  Next Bin
  BinStep = 1
  EnsBin = 0
  CorrDatOffset = CorrDatOffset + 1 'to get past 2 byte ID
  For Bin = 1 To Numbins 'Start at Bin 1 Beam 1
    nCorr = 0
    AccumCorr = 0
    temp = CorrDatOffset + (4 * EnsBin) 'jump down 4 bytes each bin
    EnsBin = EnsBin + BinStep
    For Beam = 1 To NumBeams 'only grab one byte each loop
      AccumCorr = AccumCorr + Longarray(temp + Beam)
      nCorr = nCorr + 1
      ensCorr(Bin,Beam) = Longarray(temp + Beam) 'could also average here
    Next Beam
    Select Case nCorr 'average beams for each bin
    Case 0
      AvgCorr(Bin)= 0
    Case 1
      AvgCorr(Bin) = AccumCorr
    Case 2 To 4
      AvgCorr(Bin) = AccumCorr / nCorr
    Case Else
      AvgCorr(Bin) = 0
    EndSelect
  Next Bin
  'Call CorrspikeAdd
EndSub

'_________Decode Backscattered Amplitude data and averages beams for each bin___________
Sub(RSSIDecode)
  'initialize output Arrays
  For Bin = 1 To MaxBins
    For Beam = 1 To MaxBeams
      ensRSSI(Bin,Beam) = 0
    Next Beam
  Next Bin
  BinStep = 1
  EnsBin = 0
  RSSIDatOffset = RSSIDatOffset + 1 'to get past 2 byte ID
  For Bin = 1 To Numbins 'Start at Bin 1 Beam 1
    nRSSI = 0 'zero beamwise rssi counter
    AccumRSSI = 0 'zero beamwise rssi accumulator
    AvgRSSIAccum = 0 'zero binwise rssi accumulator
    AvgRSSIcounter = 0 'zero binwise rssi counter
    temp = RSSIDatOffset + (4 * EnsBin) 'jump down 4 bytes each bin
    EnsBin = EnsBin + BinStep
    For Beam = 1 To NumBeams 'only grab one byte each loop
      AccumRSSI = AccumRSSI + Longarray(temp + Beam)
      nRSSI = nRSSI + 1
      ensRSSI(Bin,Beam) = Longarray(temp + Beam) 'could also average here
    Next Beam
    Select Case nRSSI 'average beams for each bin
    Case 0
      AvgRSSI(Bin)= 0
    Case 1
      AvgRSSI(Bin) = AccumRSSI
    Case 2 To 4
      AvgRSSI(Bin) = AccumRSSI / nRSSI
    Case Else
      AvgRSSI(Bin) = 0
    EndSelect
  Next Bin
  'Call RSSIspikeAdd
  'calculate average RSSI from Swath of data (User Selected Bins)
  For Bin = AvgRSSIStartBin To AvgRSSIEndBin
    If AvgRSSI(Bin) <> 0 Then 'average the bins
      AvgRSSIAccum = AvgRSSIAccum + AvgRSSI(Bin)
      AvgRSSIcounter = AvgRSSIcounter + 1
    EndIf
  Next Bin
  If (AvgRSSIAccum <> 0) AND (AvgRSSIcounter <> 0) Then 'if either the accumulator is zero or the counter is zero then set avgrssi to bad
    AvgSwathRSSI = AvgRSSIAccum/AvgRSSIcounter
  Else
    AvgSwathRSSI = BadDataIndicator
  EndIf
EndSub

'_________________________________Channel Master Stage Decoder___________

Sub(VMStageDecode)
  VMStageDatOffset = VMStageDatOffset - 1 'to line up with RDI Documentation
  'When you decode 4 byte binary data, you have to multiply the most significant byte
  'by 16777216
  '--------------Debugging variables
  DepthLSB = 0
  DepthLSB1 = 0
  DepthMSB = 0
  DepthMSB1 = 0
  '---------------Debugging variables
  temp = 0
  TempM = 0
  LSBTemp = 0
  LSB1Temp = 0
  MSBTemp = 0
  MSB1Temp = 0
  '---------------------Get get corrected Surface track (depth) from ensemble
  DepthLSB = Longarray(VMStageDatOffset + 3)
  DepthLSB1 = Longarray(VMStageDatOffset + 4)
  DepthMSB = Longarray(VMStageDatOffset + 5)
  DepthMSB1 = Longarray(VMStageDatOffset + 6)
  VMTemp = (16777216 * DepthMSB1) + (65536 * DepthMSB) + (256 * DepthLSB1) + DepthLSB
  If VMTemp <> 0 Then
    TempM = VMTemp/10000
  Else
    TempM = BadDataIndicator
  EndIf
  VMupBeam = TempM 'This is the range to the surface from the upward beam
  '-----------------------------------------------------get uncorrected depth
  LSBTemp = Longarray(VMStageDatOffset + 7)
  LSB1Temp = Longarray(VMStageDatOffset + 8)
  MSBTemp = Longarray(VMStageDatOffset + 9)
  MSB1Temp = Longarray(VMStageDatOffset + 10)
  '    RawDepth = (16777216 * MSB1Temp) + (65536 * MSBTemp) + (256 * LSB1Temp) + LSBTemp
  '----------------Get Signal Amplitude at Surface
  LSBTemp = Longarray(VMStageDatOffset + 12)
  '    DepthSig = LSBTemp
  '--------------------------------Get Percent Good of Surface Track
  LSBTemp = Longarray(VMStageDatOffset + 13)
  '    PercGoodSurface = LSBTemp
  LSB = 0
  L1SB = 0
  MSB = 0
  M1SB = 0
  temp = 0
  TempM = 0
  'Get corrected Max pressure (depth) from ensemble
  LSB = Longarray(VMStageDatOffset + 43)
  L1SB = Longarray(VMStageDatOffset + 44)
  MSB = Longarray(VMStageDatOffset + 45)
  M1SB = Longarray(VMStageDatOffset + 46)
  VMPSTemp = (16777216 * M1SB) + (65536 * MSB) + (256 * L1SB) + LSB 'this seems quite large, Better call RDI
  If VMPSTemp <> 0 Then
    TempM = VMPSTemp/10000
  Else
    TempM = BadDataIndicator
  EndIf
  VMpressure = TempM
  VMupBeam = VMupBeam * Meters_to_Feet 'convert to Feet
  VMpressure = VMpressure * Meters_to_Feet 'convert to Feet
EndSub

'________________________________Velocity Decoder_______________________________________
Sub(VelDecode)
  'initialize output Arrays
  If FlowSign = 0 Then FlowSign = 1
  For Bin = 1 To MaxBins
    For Beam = 1 To MaxBeams
      ensVelocity(Bin,Beam) = NAN
    Next Beam
    V1(Bin) = NAN
    V2(Bin) = NAN
    V3(Bin) = NAN
    V4(Bin) = NAN
    V1Disable(Bin) = False
    V2Disable(Bin) = False
    V3Disable(Bin) = False
    V4disable(Bin) = False
  Next Bin
  BinStep = 1
  EnsBin = 0
  For Bin = 1 To Numbins 'Start at Bin 1 Beam 1
    temp = VelDatOffset + 8 * EnsBin 'jump down 8 bytes each bin
    EnsBin = EnsBin + BinStep
    For Beam = 1 To NumBeams
      Index = temp + 2 * Beam 'index down Two bytes each beam
      LSB = Longarray(Index)
      MSB = Longarray(Index + 1)
      BinVel = (256 * MSB) + LSB
      If BinVel = 32768 Then
        ensVelocity(Bin, Beam) = NAN 'bad data
      Else
        If BinVel > 32767 Then 'Handle twos compliment (negative velocity)
          BinVel = BinVel - 65536
          If BinVel < -32767 Then 'smallest allowable velocity
            BinVel = NAN 'bad data
          Else 'apply flow sign
            BinVel = BinVel * VelocityScaleWater
            BinVel = BinVel * FlowSign
          EndIf
          ensVelocity(Bin,Beam) = BinVel
        Else
          If BinVel > 32767 Then 'largest allowable velocity
            BinVel = NAN
          Else 'apply flow sign
            BinVel = BinVel * VelocityScaleWater
            BinVel = BinVel * FlowSign
          EndIf
          ensVelocity(Bin,Beam) = BinVel
        EndIf
      EndIf
    Next Beam
    'uplooker will use Zvel and Evel
    V1(Bin) = ensVelocity(Bin,1) 'Separate the big array into sub arrays
    If V1(Bin) = NAN Then V1Disable(Bin) = True 'disable the median or average calc
    V2(Bin) = ensVelocity(Bin,2) 'Could also use a small temp array for 'ensVelocity()
    If V2(Bin) = NAN Then V2Disable(Bin) = True 'disable the median or average calc
    V3(Bin) = ensVelocity(Bin,3)
    If V3(Bin) = NAN Then V3Disable(Bin) = True 'disable the median or average calc
    V4(Bin) = ensVelocity(Bin,4)
    If V4(Bin) = NAN Then V4disable(Bin) = True 'disable the median or average calc
  Next Bin
EndSub

'____________________________1 Minute Velocity Average__________________________________
'subroutine averages all good bins for each ensemble for V1,V2, V3,and V4
'Min and Max acceptable Vel ranges are set by user with keypad
'defaults values are -5 and 5 respectively
Sub(OneMinuteCalcs)
  Dim TotBins As Long
  Dim BinVelCount As Long
  Public MidBin As Long
  Public EbbDir As Boolean = true
  ' If IfTime (0,1440,Min) Then BadVelCount = 0 'initialize counter
  V1Cnt = 0
  V1EbbCnt = 0
  V1FldCnt = 0
  V2Cnt = 0
  V2EbbCnt = 0
  V2FldCnt = 0
  V3Cnt = 0
  V4Cnt = 0
  V1Sum = 0
  V1EbbSum = 0
  V1FldSum = 0
  V2Sum = 0
  V2EbbSum = 0
  V2FldSum = 0
  V3Sum = 0
  V4Sum = 0
  IndexVel = 0
  For BinVelCount = 1 To MaxBins
    VMBinVel(BinVelCount) = NAN
    VmBinVelDisable(BinVelCount) = False
  Next BinVelCount
  VelCount = 0 'Zero out VelCount variable
  If (BiRatOK = True) AND (BiRating = True) Then 'Ok the user wants a bi-directional rating and we are using a channel master (instrument coordinates)
    UseBiRat = True 'we can do it
  Else
    UseBiRat = False'we can't do it (or user doesn't want it
  EndIf
  TotBins = EndBin - StartBin
  'lets deterimine flow dir from V1 just in case we are using bi-rating
  MidBin = TotBins/2
  If V1(MidBin) > BiRatTran Then 'Calculate flow direction (CM) if using Ebb/Flood rating (only used for CM with Instrument velocities)
    EbbDir = true 'flow is positive
  Else
    EbbDir = false 'flow is negative
  EndIf
  For Cnt = StartBin To EndBin
    If (V1(Cnt) <> NAN) AND (V1(Cnt)>= MinExpVel) AND (V1(Cnt)<= MaxExpVel) 'its probably good
      V1Sum = V1Sum + V1(Cnt)
      V1Cnt = V1Cnt + 1
      If UseBiRat = true Then 'Ok we have a bi-directional rating
        If EbbDir Then 'flow is positive (ebb) use the EBB bins
          'Calc Ebb bin sum here
          If (Cnt >= StartEbbBin) AND (Cnt <= EndEbbBin) Then 'let's do this bin
            V1EbbSum += V1(Cnt)
            V1EbbCnt += 1
          EndIf 'if it's in range
        Else 'Ok it's Flood direction (negative)
          'Calc Fld bin sum here
          If (Cnt >= StartFldBin) AND (Cnt <= EndFldBin)Then 'lets do this one
            V1FldSum += V1(Cnt)
            V1FldCnt += 1
          EndIf 'if it's in-range
        EndIf 'direction
      EndIf 'if Birating
    Else
      BadBinCnt = BadBinCnt + 1
      V1(Cnt) = BadDataIndicator
    EndIf
  Next
  If V1Sum <> 0 Then
    V1AVG = V1Sum/V1Cnt 'Calculate normal V1
  Else
    V1AVG = 0
  EndIf
  If V1EbbSum <> 0 Then
    V1EbbAvg = V1EbbSum/V1EbbCnt 'Calculate Bi-rating Ebb bin average
  Else
    V1EbbAvg = 0
  EndIf
  If V1FldSum <> 0 Then
    V1FldAvg = V1FldSum/V1FldCnt 'Calculate Bi-rating Flood bin average
  Else
    V1FldAvg = 0
  EndIf
  For Cnt = StartBin To EndBin 'OK, in case we are using both X(V1) and Y(V2) velocities to calculate iVel then we have to calc V2 averages
    If (V2(Cnt) <> NAN) AND (V2(Cnt)>= MinExpVel) AND (V2(Cnt)<= MaxExpVel)
      V2Sum = V2Sum +  V2(Cnt) 'Calculate normal V2
      V2Cnt = V2Cnt + 1
      If UseBiRat = true Then 'Ok we have a bi-directional rating
        If EbbDir Then
          'Calc Ebb bin sum here
          If (Cnt >= StartEbbBin) AND (Cnt <= EndEbbBin) Then 'let's do this bin
            V2EbbSum += V2(Cnt)
            V2EbbCnt += 1
          EndIf 'if it's in range
        Else 'Ok it's Flood direction
          'Calc Fld bin sum here
          If (Cnt >= StartFldBin) AND (Cnt <= EndFldBin)Then 'ok let's do this bin
            V2FldSum += V2(Cnt)
            V2FldCnt += 1
          EndIf 'if it's in-range
        EndIf 'direction
      EndIf 'if Birating
    Else
      BadBinCnt = BadBinCnt + 1
      V2(Cnt) = BadDataIndicator
    EndIf
  Next
  If V2Sum <> 0 Then
    V2AVG =  V2Sum/V2Cnt 'Calculate normal V2
  Else
    V2AVG = 0
  EndIf
  If V2EbbSum <> 0 Then
    V2EbbAvg = V2EbbSum/V2EbbCnt 'Calculate Bi-rating Ebb bin average (V2)
  Else
    V2EbbAvg = 0
  EndIf
  If V2FldSum <> 0 Then
    V2FldAvg = V2FldSum/V2FldCnt  'Calculate Bi-rating Flood bin average (V2)
  Else
    V2FldAvg = 0
  EndIf
  For Cnt = StartBin To EndBin
    If (V3(Cnt) <> NAN) AND (V3(Cnt)>= MinExpVel) AND (V3(Cnt)<= MaxExpVel)
      V3Sum = V3Sum +  V3(Cnt)
      V3Cnt = V3Cnt + 1
    Else
      BadBinCnt = BadBinCnt + 1
      V3(Cnt) = BadDataIndicator
    EndIf
  Next
  If V3Sum <> 0 Then
    V3AVG =  V3Sum/V3Cnt
  Else
    V3AVG = 0
  EndIf
  For Cnt = StartBin To EndBin
    If (V4(Cnt) <> NAN) AND (V4(Cnt)>= MinExpVel) AND (V4(Cnt)<= MaxExpVel)
      V4Sum = V4Sum +  V4(Cnt)
      V4Cnt = V4Cnt + 1
    Else
      BadBinCnt = BadBinCnt + 1
      V4(Cnt) = BadDataIndicator
    EndIf
  Next
  If V4Sum <> 0 Then
    V4AVG =  V4Sum/V4Cnt
  Else
    V4AVG = 0
  EndIf

  If UseV2 = Yes Then
    If BiRating Then 'calculate proper direction
      If EbbDir Then
        IndexVel = SQR(V1EbbAvg^2 + V2EbbAvg^2) 'pos flow
      Else
        IndexVel = SQR(V1FldAvg^2 + V2FldAvg^2) 'neg flow
      EndIf
    Else
      IndexVel = SQR(V1AVG^2 + V2AVG^2)'reg calc
    EndIf 'birating = true
    For Cnt = 1 To MaxBins
      If (V1(Cnt)<> BadDataIndicator) AND (V2(Cnt)<> BadDataIndicator) Then
        VMBinVel(Cnt) = SQR (V1(Cnt)^2 + V2(Cnt)^2)
        If ((Cnt >= StartBin) AND (Cnt <= EndBin)) Then
          VelCount = VelCount + 1
        EndIf
      Else
        VMBinVel(Cnt) = BadDataIndicator
        VmBinVelDisable(Cnt) = True
      EndIf
    Next
  ElseIf UseDir = Yes Then
    IndexVel = (V1AVG * SIN(DegToRad * PosFlowDir)) + (V2AVG * COS(DegToRad * PosFlowDir))
    For Cnt = 1 To MaxBins
      If (V1(Cnt)<> BadDataIndicator) AND (V2(Cnt)<> BadDataIndicator) Then
        VMBinVel(Cnt) = (V1 * SIN(DegToRad * PosFlowDir)) + (V2 * COS(DegToRad * PosFlowDir))
        If ((Cnt >= StartBin) AND (Cnt <= EndBin)) Then
          VelCount = VelCount + 1
        EndIf
      Else
        VMBinVel(Cnt) = BadDataIndicator
        VmBinVelDisable(Cnt) = True
      EndIf
    Next
  Else 'just normal computation using V1
    If BiRating Then 'we're using Ebb and Flood
      If EbbDir Then
        IndexVel = V1EbbAvg
      Else 'if flood
        IndexVel = V1FldAvg
      EndIf
    Else 'bi-rating is false
      IndexVel = V1AVG
    EndIf
    For Cnt = 1 To MaxBins
      If V1(Cnt) <> BadDataIndicator Then
        VMBinVel(Cnt) = V1(Cnt)
        If ((Cnt >= StartBin) AND (Cnt <= EndBin)) Then
          VelCount = VelCount + 1
        EndIf
      Else
        VMBinVel(Cnt) = BadDataIndicator
        VmBinVelDisable(Cnt) = True
      EndIf
    Next
  EndIf
  If VelCount >=  EndBin - StartBin Then 'if VelCount < EndBin, then must have been some bad bins (allow one missing bin)
    BadVelFlag = No 'initialize flag to false again
    Call VelFilter 'call velocity filter
  Else 'if VelCount isn't close to number of bins, then
    BadVelFlag = Yes 'set flag to true
    IndexVel = BadDataIndicator
    BadVelCount = BadVelCount + 1
    '  VelLoop = 0 'initialize variable for Vel Filter below
  EndIf
  'now lets count the bad velocity bins to keep track of them
  BadBinCount = (((EndBin+1)-StartBin)- VelCount)
  'check for above and below rating for more than 60 readings if below 60 readings then reset flag
  If ((IndexVel<>BadVel) AND (IndexVel<LowRatVel)) Then 'Ok we are below the rating
    LowCount = LowCount + 1
  ElseIf ((IndexVel<>BadVel) AND (IndexVel>HighRatVel)) Then 'Ok we a above the rating
    HighCount = HighCount + 1
  Else
    If HighCount > 0 Then HighCount = HighCount - 1
    If LowCount > 0 Then LowCount = LowCount - 1
  EndIf
  If HighCount > 60 Then HighMeas = true
  If LowCount > 60 Then LowMeas = true
  'Call VelspikeAdd
EndSub

'_________________________________Velocity Filter_________________________________________
Sub VelFilter
  If IndexVel <> 0 OR BadDataIndicator Then 'if there is data, then probably good to go...
    If (IndexVel >= MinExpVel) AND (IndexVel <= MaxExpVel) Then 'if  Vel is in range, then
      BadVelFlag = False 'We have valid data but maybe it's a spike
    Else 'if vel not in range...
      BadVelFlag = Yes
      BadVelCount = BadVelCount + 1
      IndexVel = BadDataIndicator
      ExitSub 'dont pass out of range data through filter
    EndIf
  Else 'otherwise, if no data in buffer, or serial error then
    DataErr = DataErr + 1
    BadVelFlag = Yes
    BadVelCount = BadVelCount + 1
    IndexVel = BadDataIndicator
    ExitSub 'don't pass bad data through filter
  EndIf
EndSub

Function Ftime (TimeIn As String * 25) As String * 25 'converts datalogger time string into MM/DD/YYYY HH:MM:SS
  'RawTime = Public.Timestamp

  SplitStr (FSplitTime(),TimeIn," ",6,0)
  Dim SendMonth As String
  Dim SendDay As String
  Dim SendHour As String
  Dim SendMin As String
  Dim SendSec As String
  Dim SendYear As String

  If FSplitTime(1) < 10 Then
    SendMonth = "0" + FSplitTime(1)
  Else
    SendMonth = FSplitTime(1)
  EndIf
  If FSplitTime(2) < 10 Then
    SendDay = "0" + FSplitTime(2)
  Else
    SendDay = FSplitTime(2)
  EndIf
  If FSplitTime(4) < 10 Then
    SendHour = "0" + FSplitTime(4)
  Else
    SendHour = FSplitTime(4)
  EndIf
  If FSplitTime(5) < 10 Then
    SendMin = "0" + FSplitTime(5)
  Else
    SendMin = FSplitTime(5)
  EndIf

  If Round(FSplitTime(6),0) < 10 Then
    SendSec = "0" + Round(FSplitTime(6),0)
  Else
    SendSec = Round(FSplitTime(6),0)
  EndIf
  SendYear = Right(FSplitTime(3),4)
  ftime = SendMonth + "/" + SendDay + "/" + SendYear + " " + SendHour + ":" + SendMin + ":" + SendSec
End Function

#If HasVM Then
  Sub CheckSpikes 'change name later
    'check the RSSI, Correlation, and velocity queues against incoming data for spikes.  Queues must be full before call
    'Outputs the spike data to a file on the Card.
    Dim BinCount As Long
    Dim BeamCount As Long
    Dim TimeOut As String * 25
    Dim RSSIStd As Float
    Dim RSSIAvg As Float
    Dim CorrStd As Float
    Dim CorrAvg As Float
    Dim VelStd As Float
    Dim DataLine As String * 500
    Dim velAvg As Float
    Dim Top As Float = 0
    Dim Bottom As Float = 0
    Dim QueueCorrSpikes As Long = 0
    Dim QueueRSSISpikes As Long = 0
    Dim QueueVelSpikes As Long = 0
    Dim RSSITemp(16) As Float
    Dim CorrTemp(16) As Float
    Dim VelTemp(16) As Float
    Dim Binspikes(MaxBins) As Long
    Dim BinResults(2) As Long
    Dim n As Long
    Dim QueueAvgStage As Float = 0
    Dim QueueVel As Float = 0
    If InStr(1,Status.CardStatus,"No Card",2) = 0 Then 'if the cards not there no point in checking spikes
      SpikeFileName = "CRD:VmSpikes-" & SiteID & ".csv"
      FileHandle = FileOpen (SpikeFileName,"a+b",-1)'open the spike file here
      If SendHeader Then
        FileHeader = "Type," & "Timestamp," & "NumBeams," & "NumBins," & "StartBin,"& "EndBin,"& "BinSize," & "Ivel," & "Stage Avg,"& "Corr spikes," & "RSSI Spikes," & "Vel Spikes," & "DQI," & ">1 spikes," & "Bin"
        FileWrite (FileHandle, FileHeader & CHR(13) & CHR(10),0)
        SendHeader = False
      EndIf
      QueueCorrSpikes = 0
      QueueRSSISpikes = 0
      QueueVelSpikes = 0
      QueueAvgStage = 0
      QueueDQI = 0
      QueueVel = 0
      Erase Binspikes()
      ' Dim SampleCount As Long
      'should use startbin to endbin to eliminate unwanted spikes
      For BinCount = StartBin To EndBin
        For BeamCount = 1 To NumBeams
          Erase RSSITemp()
          Erase VelTemp()
          Erase CorrTemp()
          For n = 1 To 16
            RSSITemp(n) = RSSIspike(BinCount,BeamCount,n)
            Veltemp(n) = Velspike(BinCount,BeamCount,n)
            CorrTemp(n)= Corrspike(BinCount,BeamCount,n)
          Next n
          'StdDevSpa(RSSIStd,15,RSSIspike(BinCount,BeamCount,1) 'compute standard deviation of RSSI Queue
          StdDevSpa(RSSIStd,15,rssitemp(1))
          If RSSIStd = 0 Then RSSIStd = 0.1 'set to minimum if zero
          'AvgSpa(RSSIAvg,15,RSSIspike(BinCount,BeamCount,1)
          AvgSpa(RSSIAvg,15,RSSITemp(1))
          Top = RSSIAvg + (RSSIStd * RSSIStdNo)
          Bottom = RSSIAvg - (RSSIStd * RSSIStdNo)
          If (ensRSSI(BinCount,BeamCount) < Bottom) OR (ensRSSI(BinCount,BeamCount) > Top) Then
            SpikeCounter = SpikeCounter + 1
            Binspikes(BinCount) = Binspikes(BinCount) + 1
            QueueRSSISpikes = QueueRSSISpikes + 1
            TimeOut = Ftime(Public.Timestamp)
            TestTime = TimeOut
            'commented out for spike test-----------------------------------------
            'DataLine = "Spike: ," & TimeOut & "," & "RSSI" & "," & ensRSSI(BinCount,BeamCount) & "," & BinCount & "," & BeamCount & "," & Round(RSSIStd,2) & "," & Round(RSSIAvg,2) & "," & RSSIStdNo & "," & Round(iVel,3) & "," & Round(StagePrime,2)
            'FileWrite (FileHandle,DataLine & CHR(13) & CHR(10),0)
          EndIf
          'StdDevSpa(CorrStd,15,Corrspike(BinCount,BeamCount,1) 'compute standard deviation of Correlation Queue
          StdDevSpa(CorrStd,15,corrtemp(1))
          If CorrStd = 0 Then CorrStd = 0.1 'set to minimum if zero
          'AvgSpa(CorrAvg,15,Corrspike(BinCount,BeamCount,1)
          AvgSpa(CorrAvg,15,CorrTemp(1))
          Top = CorrAvg + (CorrStd * CorrStdNo)
          Bottom = CorrAvg - (CorrStd * CorrStdNo)
          If (ensCorr(BinCount,BeamCount) < Bottom) OR (ensCorr(BinCount,BeamCount) > Top) Then
            SpikeCounter = SpikeCounter + 1
            Binspikes(BinCount) = Binspikes(BinCount) + 1
            QueueCorrSpikes = QueueCorrSpikes + 1
            TimeOut = Ftime(Public.Timestamp)
            'commented out for spike test----------------------------------------
            'DataLine = "Spike: ," & TimeOut & "," & "Corr" & "," & ensCorr(BinCount,BeamCount) & "," & BinCount & "," & BeamCount & "," & Round(CorrStd,2) & "," & Round(CorrAvg,2) & "," & CorrStdNo & "," & Round(iVel,3) & "," & Round(StagePrime,2)
            'FileWrite (FileHandle,DataLine & CHR(13) & CHR(10),0)
          EndIf
          StdDevSpa(VelStd,15,veltemp(1))
          If VelStd = 0 Then VelStd = .1
          'AvgSpa(velAvg,15,Velspike(BinCount,BeamCount,1) 'Velocity average for Queue
          AvgSpa(velAvg,15,veltemp(1))
          Top = velAvg + (VelStd * VelStdNo)
          Bottom = velAvg - (VelStd * VelStdNo)
          If (ensVelocity(BinCount,BeamCount) < Bottom) OR (ensVelocity(BinCount,BeamCount) > Top) Then
            'for future use, we can set the disable variables here, but we need to call this before calling the velocity output table
            SpikeCounter = SpikeCounter + 1
            Binspikes(BinCount) = Binspikes(BinCount) + 1
            QueueVelSpikes = QueueVelSpikes + 1
            TimeOut = Ftime(Public.Timestamp)
            'commented out for spike test------------------------------------------------
            'DataLine = "Spike: ," & TimeOut & "," & "Velocity" & "," & Round(ensVelocity(BinCount,BeamCount),2) & "," & BinCount & "," & BeamCount & "," & Round(VelStd,2) & "," & Round(velAvg,2) & "," & VelStdNo & "," & Round(iVel,3) & "," & Round(StagePrime,2)
            'FileWrite (FileHandle,DataLine & CHR(13) & CHR(10),0)
          EndIf
          'StdDevSpa(VelStd,15,Velspike(BinCount,BeamCount,1) 'compute standard deviation of Velocity Queue

          'need to output Velocity average here every 15 mins regardless of spikes to provide a velocity scale for visualization
        Next BeamCount
      Next BinCount
      QueueDQI = (QueueCorrSpikes + QueueRSSISpikes + QueueVelSpikes)/15 'number of ensembles per period
      QueueDQI = Round(QueueDQI,2)
      velAvg = Round(velAvg,2)
      AvgSpa(QueueAvgStage,15,StageSpike(1)
      QueueAvgStage = Round(QueueAvgStage,2)
      QueueVel = Round(IndexVel,2)
      TimeOut = Ftime(Public.Timestamp)
      MaxSpa(BinResults(),MaxBins,Binspikes())
      If BinResults(1) < 2 Then
        BinResults(1) = 0
        BinResults(2) = 0
      EndIf
      'DataLine = "Stats: ," & TimeOut & "," & velAvg & "," & QueueAvgStage & "," & QueueCorrSpikes & "," & QueueRSSISpikes & "," & QueueVelSpikes & "," & QueueDQI
      DataLine = "Stats: ," & TimeOut & "," & NumBeams & "," & Numbins & "," & StartBin & "," & EndBin & "," & BinSize & ","& QueueVel & "," & QueueAvgStage & "," & QueueCorrSpikes & "," & QueueRSSISpikes & "," & QueueVelSpikes & "," & QueueDQI & "," & BinResults(1) & "," & BinResults(2)
      FileWrite (FileHandle,DataLine & CHR(13) & CHR(10),0)
      FileClose(FileHandle)
    EndIf
    CardError = Status.CardStatus
  End Sub

#EndIf 'if hasvm
'----------------------------------------------------------------------------
'add spikes to correlation,RSSI and Velocity fifo Queues and advance to next queue position. Note: call after checkspikes
'---------------------------------------Sub AddSpikes-------------------------------------------------------------------
#If HasVM Then
  Sub AddSpikes
    Dim BinCount As Long
    Dim BeamCount As Long
    Dim SampleCount As Long
    If BadVelFlag Then Exit Sub
    For BinCount = 1 To Numbins 'get all bins for storage
      For BeamCount = 1 To NumBeams
        Corrspike(BinCount,BeamCount,16) = ensCorr(BinCount,BeamCount) 'add new to end
        RSSIspike(BinCount,BeamCount,16) = ensRSSI(BinCount,BeamCount) 'add new to end
        Velspike(BinCount,BeamCount,16) = ensVelocity(BinCount,BeamCount) 'add new to end
        For SampleCount = 1 To 15
          'Jack out first and copy in last
          Corrspike(BinCount,BeamCount,SampleCount) = Corrspike(BinCount,BeamCount,SampleCount + 1)
          RSSIspike(BinCount,BeamCount,SampleCount)=RSSIspike(BinCount,BeamCount,SampleCount + 1)
          Velspike(BinCount,BeamCount,SampleCount) = Velspike(BinCount,BeamCount,SampleCount + 1)
        Next SampleCount
      Next BeamCount
    Next BinCount
    'add stage to stagespike queue
    StageSpike(16) = StagePrime
    For SampleCount = 1 To 15
      StageSpike(SampleCount) = StageSpike(SampleCount + 1)
    Next SampleCount
  End Sub
#EndIf

'--------------Store all 1 minute data to Card ----------------------------------------------
#If (StoreAllToCard = true) AND HasVM Then
  Sub StoreAllData
    Dim CorrDataLine As String * 1000
    Dim VelDataLine As String * 1000
    Dim RSSIDataLine As String * 1000
    Dim BeamCount As Long
    Dim BinCount As Long
    If InStr(1,Status.CardStatus,"Card OK.",2) = 0 Then 'if the cards not there no point in checking spikes
      CardBadCount = CardBadCount + 1
      ExitSub
    Else
      CardOkCount = CardOkCount + 1
      SpikeFileName = "CRD:VmSpikes-" & SiteID & ".csv"
      FileHandle = FileOpen (SpikeFileName,"a+b",-1)'open the spike file here
      'compose dataline and write here.
      For BeamCount = 1 To NumBeams
        Erase CorrDataLine
        Erase VelDataLine
        Erase RSSIDataLine
        CorrDataLine = CorrDataLine & "Corr: ," & BeamCount
        VelDataLine = VelDataLine & "Velocity: ," & BeamCount
        RSSIDataLine = RSSIDataLine & "RSSI: ," & BeamCount
        For BinCount = 1 To Numbins
          CorrDataLine = CorrDataLine & "," & ensCorr(BinCount,BeamCount)
          VelDataLine = VelDataLine & "," & Round(ensVelocity(BinCount,BeamCount),3)
          RSSIDataLine = RSSIDataLine & "," & ensRSSI(BinCount,BeamCount)
        Next BinCount
        FileWrite (FileHandle,RSSIDataLine & CHR(13) & CHR(10),0)
        FileWrite (FileHandle,CorrDataLine & CHR(13) & CHR(10),0)
        FileWrite (FileHandle,VelDataLine & CHR(13) & CHR(10),0)
      Next BeamCount
      FileClose(FileHandle)
    EndIf
    CardError = Status.CardStatus
  End Sub
#EndIf
'__________________________________Calculate Q Subroutine_________________________________
'Sub SubCalcQ 'calculate discharge
'  If CalcQ = Yes Then ' if Q calculations are wanted
'    If Trans = BadDataIndicator Then 'if there is no valid transition point
'      'then use standard velocity rating info for meanvel calculation
'      MeanVel = VelOffset + (VelCoef * IndexVel) + (VelCoef2 * IndexVel^2) + (VelCoef3 * IndexVel^3)
'    Else 'if there is a valid transition point
'      If IndexVel >= Trans Then 'if iVel is greater or equal to the transition point
'        'then use upper meanvel rating information
'        MeanVel = UpVelOffset + (UpVelCoef * IndexVel) + (UpVelCoef2 * IndexVel^2) + (UpVelCoef3 * IndexVel^3)
'      ElseIf IndexVel <= Trans Then 'if iVel is less than the transition point
'        'then use lower meanvel rating information
'        MeanVel = LowVelOffset + (LowVelCoef * IndexVel) + (LowVelCoef2 * IndexVel^2) + (LowVelCoef3 * IndexVel^3)
'      EndIf
'    EndIf
'    If BadVelFlag = False AND  BadStgFlag = False Then 'Ok, now if both iVel and Stage are still good, then
'      BadQFlag = False 'then Q data is still good
'      'user enters rating values with keypad
'      Area = StgOffset + (StgCoef*StagePrime) + (StgCoef2 * StagePrime^2)
'      'check to see if iVel data is good
'      Qcfs = Area * MeanVel 'calculate Q
'      If Qcfs = 0 Then 'if calculated Q is exactly zero
'        'then don't believe it (probably no rating data entered)
'        BadQFlag = True 'Q data is now bad, so don't average it
'        BadQCount = BadQCount + 1 'Q is now bad
'        Qcfs = BadDataIndicator
'      EndIf
'    Else 'if stage or velocity were bad, then
'      BadQFlag = True 'Q data is now bad, so don't average it
'      BadQCount = BadQCount + 1 'and increment counter
'      Qcfs = BadDataIndicator
'    EndIf
'  Else ' if Q calculations are not wanted (CalcQ = no)
'    BadQCount = 0
'    Area = NAN
'    MeanVel = NAN
'    Qcfs = 0
'    BadQFlag = True
'  EndIf
'EndSub

'____________________________________Zero all Velocity Meter Arrays__________________________
#If HasVM = True Then
  Sub ZeroVMArrays
    Dim ZeroCounter As Long
    'Zero The raw data array
    Erase (Longarray())
    'Zero the bin velocity arrays
    For Bin = 1 To MaxBins
      For Beam = 1 To MaxBeams
        ensVelocity(Bin,Beam) = Nan
      Next Beam
    Next Bin
    For ZeroCounter = 1 To MaxBins
      V1(ZeroCounter) = Nan
      V2(ZeroCounter) = Nan
      VMBinVel(ZeroCounter) = Nan
    Next ZeroCounter
    IndexVel = NaN
    '  For Bin = 1 To MaxBins
    '    For Beam = 1 To MaxBeams
    '      ensCorr(Bin,Beam) = 0
    '    Next Beam
    '    AvgCorr(Bin) = 0
    '  Next Bin
    Erase (ensCorr())
    '  For Bin = 1 To MaxBins
    '    For Beam = 1 To MaxBeams
    '      ensRSSI(Bin,Beam) = 0
    '    Next Beam
    '    AvgRSSI(Bin) = 0
    '  Next Bin
    Erase (AvgRSSI())
    Erase Velspike()
    Erase RSSIspike()
    Erase Corrspike()
  EndSub
#EndIf
'----------------------------------------------------
'Read variables in from USR file (preserved variables)
'Sub ReadVariables
'  Public PreserveHandle As Long
'  Public PreserveFileLen As Long
'  Public Closeerror
'  PreserveHandle = FileOpen("USR:VariableStore.txt","r",-1) 'open the preserve variable file here
'  Delay (1,30,mSec)
'  PreserveFileLen = FileRead(PreserveHandle,PreserveFile,500)
'  Closeerror = FileClose(PreserveHandle)
'  If PreserveFileLen = 0 Then
'    '    'set error txt
'    ExitSub
'  EndIf
'  Dim InVar(38) As String
'  SplitStr(InVar,PreserveFile,",",38,0)
'  StartBin = InVar(1)
'  EndBin = InVar(2)
'  StartEbbBin = InVar(3)
'  EndEbbBin = InVar(4)
'  StartFldBin = InVar(5)
'  EndFldBin = InVar(6)
'  BiRating = InVar(7)
'  BiRatTran = InVar(8)
'  LowRatVel = InVar(9)
'  HighRatVel = InVar(10)
'  SelStgPrime = InVar(11)
'  SelStgSecnd = InVar(12)
'  UpBeamOffset = InVar(13)
'  VMPressOffset = InVar(14)
'  PS1Offset = InVar(15)
'  PS2Offset = InVar(16)
'  BBLOffset = InVar(17)
'  CalcQ = InVar(18)
'  StgOffset = InVar(19)
'  StgCoef = InVar(20)
'  StgCoef2 = InVar(21)
'  VelOffset = InVar(22)
'  VelCoef = InVar(23)
'  VelCoef2 = InVar(24)
'  VelCoef3 = InVar(25)
'  UpVelOffset = InVar(26)
'  UpVelCoef = InVar(27)
'  UpVelCoef2 = InVar(28)
'  UpVelCoef3 = InVar(29)
'  LowVelOffset = InVar(30)
'  LowVelCoef = InVar(31)
'  LowVelCoef2 = InVar(32)
'  LowVelCoef3 = InVar(33)
'  RangeSource = InVar(34)
'  DucerDepthOffset = InVar(35)
'  isVMNClosed = InVar(36)
'  OneMinConsistent= InVar(37) 'if you want constant 1min data this will keep it on in case of power cycle
'  FlowSign = InVar(38)
'EndSub
'
''Store Variables to USR File (preserve variables)
''--------------------------------------------------
'Sub StoreVariables
'  'store variables out
'  Dim Var(38) As String
'  Public SendVarString As String * 500
'  Public VarStringLen As Long
'  Public VarHandle = Long
'  Public Varbytes = Long
'  Public StoreCloseErr As Long
'  Dim VarCnt As Long
'  Var(1) = StartBin
'  Var(2) = EndBin
'  Var(3) = StartEbbBin
'  Var(4) = EndEbbBin
'  Var(5) = StartFldBin
'  Var(6) = EndFldBin
'  Var(7) = BiRating
'  Var(8) = BiRatTran
'  Var(9) = LowRatVel
'  Var(10) = HighRatVel
'  Var(11) = SelStgPrime
'  Var(12) = SelStgSecnd
'  Var(13) = UpBeamOffset
'  Var(14) = VMPressOffset
'  Var(15) = PS1Offset
'  Var(16) = PS2Offset
'  Var(17) = BBLOffset
'  Var(18) = CalcQ
'  Var(19) = StgOffset
'  Var(20) = StgCoef
'  Var(21) = StgCoef2
'  Var(22) = VelOffset
'  Var(23) = VelCoef
'  Var(24) = VelCoef2
'  Var(25) = VelCoef3
'  Var(26) = UpVelOffset
'  Var(27) = UpVelCoef
'  Var(28) = UpVelCoef2
'  Var(29) = UpVelCoef3
'  Var(30) = LowVelOffset
'  Var(31) = LowVelCoef
'  Var(32) = LowVelCoef2
'  Var(33) = LowVelCoef3
'  Var(34) = RangeSource
'  Var(35) = DucerDepthOffset
'  Var(36) = isVMNClosed
'  Var(37) = OneMinConsistent
'  Var(38) = FlowSign
'  'build send string
'  SendVarString = Var(1)
'  For VarCnt = 2 To 38
'    SendVarString = SendVarString + "," + Var(VarCnt)
'  Next VarCnt
'  VarStringLen = Len(SendVarString)
'  VarHandle = FileOpen("USR:VariableStore.txt","w",-1)
'  Delay(1,100,mSec)
'  Varbytes = FileWrite(VarHandle,SendVarString,VarStringLen + 50)
'  StoreCloseErr = FileClose(VarHandle)
'  StoreVariablesFlg = False
'EndSub

'_______________________________________________________Calculate a Checksum for the ensemble and extract ensemble checksum ____________________________________
#If HasVM = True Then
  Sub ChecksumCheck
    'Get ensemble length (from the header)
    Dim CkSumCount As Long
    LSB = Longarray(3)
    MSB = Longarray(4)
    EnsembleLen = LSB + (MSB*256)
    'calculate checksum here to see if it matches the checksum sent by the ADCP
    CalcCheckSum = 0
    CkSumCount = 0
    For CkSumCount = 1 To EnsembleLen
      CalcCheckSum = CalcCheckSum + Longarray(CkSumCount)
    Next CkSumCount
    CalcCheckSum = 65535 AND CalcCheckSum
    EnsChecksum = Longarray(CkSumCount)
    TempL = Longarray(CkSumCount + 1)
    EnsChecksum = EnsChecksum + TempL * 256
  EndSub
#EndIf

'_____________________________________Zero Counters___________________________________________________________
Sub ZeroErrCounters
  BadBinCnt = 0
  BadEnsemble = 0
  BadEnsCount = 0
  VMRestartAttempts = 0
  BadStgCount = 0 'initialize bad stage counter
  BadQCount = 0
  BadVelCount = 0 'initialize counter
  EventVoltFlag  = No ' reset the catastrophic event flags
  EventQFlag  = No
  EventCDMAFlag = No
  CDMAFailure = No
  NewADCP = False
  NewPS1 = False
  NewPS2 = False
EndSub

  '_______________________________________Main Program____________________________________
  'Main Program
  BeginProg
    'INITIALIZE variables here that will hold their value from scan to scan
    MissedEns = 0
    ScanDiff = 0
    #If HasVM Then
      SpikeCounter = 0
      SendHeader = True
    #EndIf
    PanelTemp(PTempC,250)
    PTempF = PTempC * 9/5 + 32
    Call GetStartup 'setup all the statup\default info
    Call CalcLoopInterval 'calculate the loop interval from the ScanRate and ScanUnit
    Call Initialize 'initialize important variables
    SetVMTimeFlg = false
    RecDataFlag = No
    OneMinConsistent = False 'during initialization make sure the continous 1min data is not enabled. Only user selections should activate it.
    CMD = ""
    SendCMD = FALSE
    '---------------------------------------------------------------------
    ' This must be done inside scan
    '  If GetVariablesFlg = True Then
    '    Call ReadVariables
    '    GetVariablesFlg = False
    '  EndIf
    '--Start Scan ----------------------------------------------------------------------
    'The Scan starts here and we initialize variables that are changed during every scan
    '-----------------------------------------------------------------------------------
    Scan (ScanRate,ScanUnit,5,0)'set to scan every 60 seconds
      ScanStart = Timer(DebugTimer,mSec,2) 'Start a timer to time all functions
      ScanStart = ScanStart/1000 'convert mSec to seconds
      RealTime (rTime)' get current time from datalogger real time clock
      RealSeconds = (Hour * 3600) + (Minute * 60) + Second
      'see if time is close to 15 minute or Day Interval
      Mod5Minutes = RealSeconds MOD 300
      Mod15Minutes = RealSeconds MOD 900
      Mod60Minutes = RealSeconds MOD 3600
      ModDay = RealSeconds MOD 86400
      '-------------------------------------------------------------------------------------------------------
      If ModDay = 0 Then 'At midnight
        SetVMTimeFlg = True
        Rec24HrFlag = True 'Trigger for QAQC table
        CallTable QAQCInfo
        StoreVariablesFlg = True 'set flag to store the necessary variables to the USR drive
      Else
        Rec24HrFlag = False
      EndIf
      If ModDay = 300 Then 'Reset bad data counter at 5 minutes after Midnight
        'Reset all Daily flags or zero variables here
        Call ZeroErrCounters 'Reset Counters at midnight
        #If HasVM Then
          SpikeCounter = 0
        #EndIf
      EndIf
      If Mod15Minutes = 0 Then 'at the 15 minute mark
        Rec15minFlag = True ' set flag to record AQ and DataOut tables
        RecBeamCheckFlag = True 'set flag to record BeamCheck Table
        If RecordAll = True Then RecAllVelFlag = True 'set flag to record VelData table for special studies
      Else
        Rec15minFlag = False
        RecAllVelFlag = False
        RecBeamCheckFlag = False
      EndIf
      If RecCalibData = True Then 'if we want 1 min data
        Rec1MinFlag = True
      Else 'if the user set it back to false
        Rec1MinFlag = False 'stop recording 1min data
        OneMinCount = 0 'reset the counter
      EndIf
      If Rec1MinFlag = True Then
        OneMinCount = OneMinCount + 1
        If OneMinCount > 1439 Then 'If 24hours has been recorded
          RecCalibData = False
          Rec1MinFlag = False
          OneMinCount = 0
        EndIf
      EndIf
      Dim InCount As Long
      EnsBytes = 0
      Subscans = 0
      ScanNo = ScanNo + 1
      'Set the baudrates and open the serial ports
      Call OpenADCPPort
'      If GetVariablesFlg = True Then
'        Call ReadVariables
'        GetVariablesFlg = False
'      EndIf
'      If (SendCMD) Then Call SendSetup
'      CMD = ""
      Call ToggleVMPower 'if set to VMpower = yes then ok otherwise turns off VM
      'commented out truestage subroutine. If enabled in subroutine uncomment this
      'Call TrueStage
'      UpBeamStg = VMupBeam + UpBeamOffset
'      VMPressStg = VMpressure + VMPressOffset
'      PS1Stg = PsPress1Stg(1) + PS1Offset
'      PS2Stg = PSpress2Stg(1) + PS2Offset

      'If user elects to wake up Channel Master because it has gone to sleep for some reason
      #If HasVM Then
      WakeVMStart = Timer(DebugTimer,msec,4)
      WakeVMStart = WakeVMStart/1000
        If WakeUpVM Then
          Call WakeVM
          WakeUpVM = No
        EndIf
      WakeVMEnd = Timer(DebugTimer,msec,4)
      WakeVMEnd = WakeVMEnd/1000
      WakeVMTotTime = WakeVMEnd-WakeVMStart
      #EndIf
      VMInfoStart = Timer(DebugTimer,msec,4)
      VMInfoStart = VMInfoStart/1000
      Call GetLastScan
      Call GetSysInfo
      VMInfoEnd = Timer(DebugTimer,msec,4)
      VMInfoEnd = VMInfoEnd/1000
      VMInfoTotTime = VMInfoEnd-VMInfoStart
      'The following code looks for the incoming data stream,stores the data in an array of longs, and passes the data through
      'a series of checks.  If those checks fail then the scan is truncated, the resulting
      'data is flagged, and the serial port is flushed.  On the next scan the next valid ensemble
      'is read, if there is good data in the buffer then that should be reflected in the output.
      ADCPDone = False
      Numbytes = 0 'Zero counters for ADCP Decoder
      InCount=0
      VMLoopStart = Timer(DebugTimer,msec,4)
      VMLoopStart = VMLoopStart/1000
      #If HasVM = true Then
        For ADCPLoop = 1 To 2
          Do While SerialInChk(AdcpPort)
            InCount=InCount+1
            SerialInBlock(AdcpPort,Nums(1),1)
            MoveBytes(Longarray(InCount),3,Nums(1),0,1)'this is required because ADCP outputs bytes (little indean - big indian) in the reverse order that is done in the cr10000 (Big-indian Little indian)
            If InCount > 5 Then
              If Longarray(1) <> 127 OR Longarray(2) <> 127 'These characters are at the start of each ensemble hex 7F7F
                FramingError = FramingError + 1
                InCount = InCount-2 'discard junk bytes and continue
              EndIf
            EndIf
            Numbytes = InCount
            If InCount > 4 Then 'get number of bytes per ensemble from adcp data
              LSB = Longarray(3)
              MSB = Longarray(4)
              EnsBytes = LSB + (MSB*256)
            EndIf
            If Numbytes > 4 AND EnsBytes = Numbytes - 2 Then 'we have all the bytes, let's get out of both loops
              SerialFlush(AdcpPort)
              ADCPDone = true
              ExitDo
            EndIf
            Delay (1,30,uSec)
          Loop
          If FramingError > 0 Then
            HeaderMismatch = HeaderMismatch + 1
            FramingError = 0
          EndIf
          Subscans = Subscans + 1
          If ADCPDone Then ExitFor
          Delay (1,2,Sec) 'Wait a bit for incoming ensemble, but not more than 4 seconds
        Next
      #EndIf
      VMLoopEnd = Timer(DebugTimer,msec,4)
      VMLoopEnd = VMLoopEnd/1000
      VMLoopTotTime = VMLoopEnd-VMLoopStart

      If Numbytes = ((EnsBytes *2) +4) Then MissedEns = MissedEns + 1
      CDMACheckStart = Timer(DebugTimer,msec,4)
      CDMACheckStart = CDMACheckStart/1000
      Call CDMAcheck
      CDMACheckEnd = Timer(DebugTimer,msec,4)
      CDMACheckEnd = CDMACheckEnd/1000
      CDMACheckTotTime = CDMACheckEnd-CDMACheckStart
      #If HasVM = True Then
        ZeroVMTimeStart = Timer(DebugTimer,msec,4)
        ZeroVMTimeStart = ZeroVMTimeStart/1000
        If NumbytesZero > 7 Then
          BadEnsemble = BadEnsemble + 1
          Call ZeroVMArrays
          VMdataIn = No
          SerialFlush(AdcpPort)
          NumbytesZero = 0
        EndIf
        If Numbytes < 1 Then
          NumbytesZero = NumbytesZero + 1
        Else
          NumbytesZero = 0
        EndIf
        ReceivedBytes = Numbytes
        InCount = 0
        ZeroVMTimeEnd = Timer(DebugTimer,msec,4)
        ZeroVMTimeEnd = ZeroVMTimeEnd/1000
        ZeroVMTotTime = ZeroVMTimeEnd - ZeroVMTimeStart
        ChkSumChkStart = Timer(DebugTimer,msec,4)
        ChkSumChkStart = ChkSumChkStart/1000
        Call ChecksumCheck
        If (CalcCheckSum <> EnsChecksum) OR (CalcCheckSum = 0) Then
          BadEnsemble = BadEnsemble + 1
          BadChecksum = BadChecksum + 1
          VMdataIn = No
          'SerialFlush(AdcpPort)
        Else
          VMdataIn = Yes
        EndIf
         ChkSumChkEnd = Timer(DebugTimer,msec,4)
          ChkSumChkEnd = ChkSumChkEnd/1000
          ChkSumChkTotTime = ChkSumChkEnd - ChkSumChkStart
      #EndIf
      
      #If HasVM Then
        If VMdataIn = Yes Then 'only process data if we have it
          VmDeadCount = 0
          MainDecodeStart = Timer(DebugTimer,msec,4)
          MainDecodeStart = MainDecodeStart/1000
          Call MainDecode
          MainDecodeEnd = Timer(DebugTimer,msec,4)
          MainDecodeEnd = MainDecodeEnd/1000
          MainDecodeTotTime = MainDecodeEnd-MainDecodeStart
         
          OneMinCalcStart = Timer(DebugTimer,msec,4)
          OneMinCalcStart = OneMinCalcStart/1000
          Call OneMinuteCalcs
          OneMinCalcEnd = Timer(DebugTimer,msec,4)
          OneMinCalcEnd = OneMinCalcEnd/1000
          OneMinCalcTotTime = OneMinCalcEnd - OneMinCalcStart
'          CalcQStart = Timer(DebugTimer,msec,4)
'          CalcQStart = CalcQStart/1000
'          Call SubCalcQ
'          CalcQEnd = Timer(DebugTimer,msec,4)
'          CalcQEnd = CalcQEnd/1000
'          CalcQTotTime = CalcQEnd-CalcQStart
          GetVMMemStart = Timer(DebugTimer,msec,4)
          GetVMMemStart = GetVMMemStart/1000
          GetVMMemEnd = Timer(DebugTimer,msec,4)
          GetVMMemEnd = GetVMMemEnd/1000
          GetVMMemTotTime = GetVMMemEnd-GetVMMemStart

          'now call the DataOut tables (need to be seen on every scan)
          'if hasVM = False and we're getting vm data we need to disable these two tables because they are called later

          RecAllVelFlag = false
          'Rec15minFlag = false 'turn data table flag back off
          'make sure spike stuff is not called if hasvm is false
          If ScanNo >= 20 Then 'fill fif0 buffer before checking but do check first incase we have to set disable variables
            ChkSpikeStart = Timer(DebugTimer,msec,4)
            ChkSpikeStart = ChkSpikeStart/1000
            Call CheckSpikes
            ChkSpikeEnd = Timer(DebugTimer,msec,4)
            ChkSpikeEnd = ChkSpikeEnd/1000
            ChkSpikeTotTime = ChkSpikeEnd - ChkSpikeStart
            #If StoreAllToCard Then
              StoreToCrdStart = Timer(DebugTimer,msec,4)
              StoreToCrdStart = StoreToCrdStart/1000
              Call StoreAllData
              StoreToCrdEnd = Timer(DebugTimer,msec,4)
              StoreToCrdEnd = StoreToCrdEnd/1000
              StoreToCrdTotTime = StoreToCrdEnd-StoreToCrdStart
            #EndIf
          EndIf
          AddSpikeStart = Timer(DebugTimer,msec,4)
          AddSpikeStart = AddSpikeStart/1000
          Call AddSpikes 'make sure buffer is full before checking
          AddSpikeEnd = Timer(DebugTimer,msec,4)
          AddSpikeEnd = AddSpikeEnd/1000
          AddSpikeTotTime = AddSpikeEnd-AddSpikeStart

        Else 'if no vm data in
          VmDeadCount = VmDeadCount + 1
        EndIf 'if vm data in
        If VmDeadCount >= VMDeadCntMax Then
          WakeUpVM = True
        EndIf
        'used to be before VM loop, moved to after to test avoidance of timing problem.
'      GetStageStart = Timer(DebugTimer,msec,4)
'      GetStageStart = GetStageStart/1000
'      Call GetStage
'      GetStageEnd = Timer(DebugTimer,msec,4)
'      GetStageEnd = GetStageEnd/1000
'      GetStageTotTime = GetStageEnd-GetStageStart
'        Call StageDiff
'        Call GetSN
        If SetVMTimeFlg Then
          Call SetVMTime
        EndIf
      #EndIf
      'Call All Data Tables (time them to make sure nothing is being hung up.
      DataTabsStart = Timer(DebugTimer,msec,4)
      DataTabsStart = DataTabsStart/1000
      CallTable DataOut
      DataOutCount = DataOutCount + 1
      DataOutEnd = Timer (DebugTimer,msec,4)
      DataOutEnd = DataOutEnd/1000
      DataOutTotTime = DataOutEnd - DataOutStart
      Data1mStart = Timer (DebugTimer,msec,4)
      Data1mStart = Data1mStart/1000
      CallTable Data1m
      Data1mCount = Data1mCount + 1
      Data1mEnd = Timer(DebugTimer,msec,4)
      Data1mEnd = Data1mEnd/1000
      Data1mTotTime = Data1mEnd - Data1mStart
      DataTabsEnd = Timer(DebugTimer,msec,4)
      DataTabsEnd = DataTabsEnd/1000
      DataTabsTotTime = DataTabsEnd - DataTabsStart
      CallBmChkStart = Timer(DebugTimer,msec,4)
      CallBmChkStart = CallBmChkStart/1000
      CallTable BeamCheck
      CallBmChkEnd = Timer(DebugTimer,msec,4)
      CallBmChkEnd = CallBmChkEnd/1000
      CallBmChkTotTime = CallBmChkEnd-CallBmChkStart

      RecAQFlag = False

      'If StoreVariablesFlg = true Then Call StoreVariables
     
      AQTabStart = Timer(DebugTimer,msec,4) 'read timer for start time of the AQ table
      AQTabStart = AQTabStart/1000 'convert
      AvgIndexVel = DataOut.IndexVel_Avg 'copy discharge data to new variables to sample in the AQ table
      AvgVMTemp = DataOut.VMtempC_Avg
      AvgVMPitch = DataOut.VMpitch_Avg
      AvgVMRoll = DataOut.VMroll_Avg
      AvgPS1Stg = DataOut.PS1Stg_Avg
      AvgPS2Stg = DataOut.PS2Stg_Avg
      AvgBBLstage = DataOut.BBLstage_Avg
      AvgUpBeamStg = DataOut.UpBeamStg_Avg
      '      AvgLoggerQcfs = DataOut.Qcfs_Avg
      '      AvgStagePrime = Dataout.StagePrime_Avg
      '      AvgStageSec = Dataout.StageSecnd_Avg
      Delay(1,50,mSec)
      CallTable Aquarius 'call the table, if Rec15MinFlag is true, record it. Otherwise, store data in background until we are ready to record the data
      AQcount = AQcount + 1 'debug counter
      AQTabEnd = Timer (DebugTimer,msec,4) 'end time of AQ table
      AQTabEnd = AQTabEnd/1000 'convert
      AQTabTotTime = AQTabEnd - AQTabStart   'total time to write to AQ
      Rec15minFlag = false 'turn off data table trigger flags (until they get triggered in the program above at the next appropriate interval)
      ScanEnd = Timer(DebugTimer,mSec,4) 'read timer for end of scan
      ScanEnd = ScanEnd/1000 'convert
      ProcessTime = ScanEnd - ScanStart 'calculate total time
      CallTable Debugger 'call/store debugging info
      CallTable SVMaq 'call SVMaq table
    NextScan
  EndProg
