'CR1000 or CR6 Series Datalogger
'Program Authors
'Michael R. Simpson
'HydroInterface
'Trevor Violette, Mark Inc, and Jim DeRose, USGS
'Program Version Date
Const ProgramVersionDate = 20190809
Const ProgramVersion = "4.22"
'Last Modified by: Mark Inc
'UNIVERSAL PROGRAM -- May need some trimming!!! NOTE! THIS PROGRAM WILL NOT COMPILE ON CR1000 OS 28 or EARLIER!

'-----------------IMPORTANT IMPORTANT-----------------------------------------------
'BEFORE COMPILING:
' 1 SET DLD DATALOGGER TYPE IN TOOLS MENU FOR THE TARGET DATALOGGER
' 2 CHOOSE COSTOMIZE CONSTANTS IN TOOLS MENU, SELECT PROPER CONSTANTS FOR THE TARGET STATION
' 3 CHOOSE CONDITIONAL COMPILE AND SAVE IN THE COMPILE MENU. RENAME THE FILE WITH STATION ID AND DATE IN FILENAME USING CR6 or CR1 file extension
' 4 LOAD THE SAVED FILE INTO THE STATION DATALOGGER OR YOU CAN LOAD THE ORIGINAL DLD FILE IF SPACE PERMITS.
' 5 DO NOT USE A MAX232 ADAPTER ON THE CSI/0 (ComME) port

'Note: Pos Flow angle can only be used on 4 beam uplookers using EARTH coordinate transformation.
'its use in any other configuration is disabled after the first ensemble.
'If using BEAM coordinate transformation on a Channel Master, You MUST obtain an external HEADING determination as there is NO internal compass!
'If using a Bi-directional rating (Ebb/Flood) with different bins for each direction you must be using a channel master with insturment coordinates, you must set Birating to true in the startup parameters.
'You also must set StartBin, EndBin, StartEbbBin, EndEbbBin, StartFldBin, and EbbFldBin to appropriate values (ebb = pos) (Fld = neg)  Startbin and Endbin should include all the bins used
'for both ebb and flood calculations. You also have to set BiRatTran to the velocity That you wish calculations to switch from Ebb bins to Flood Bins. The program will make sure you are using
'a Channel Master with instrument coords before applying the Ebb/Flood bin differences. If you are using any other VM or coord system, it will use the standard method to calculate iVel.
'You can include V2 (Y velocity) in the IndexVel calculation if you wish to use it. Just make sure UseV2 is True.

'_______________________________PROGRAM UPDATES_________________________________________
'20090211 - MRS and PRS averaged beams for each bin added to coorelation and RSSI decoders
'20090211 - PRS cleaned up program slightly
'20090212 - PRS  WHvolts added to variable leader decoder; defined a prelimary output table
'20090213 - JBD added bells\whistles and data tables, many minor changes to subroutines
'20090213 - PRS added Evel and Nvel to Flow Data Keypad Menu; flow direction included in 15 min output table; converted mm/sec to ft/sec// changed to V1 and V2 20100808
'20090219 - MRS and PRS added subroutine CalcLastGoodBin to calculate last good bin based on good RSSI and Coorelation
'20090220 - PRS added some variables to keypad
'20090319 - PRS added MaxRSSIBin to data out for troubleshooting purposes, decreased RSSI spike down to 5 counts
'20090320 - JBD moved calls to keypad and stage ahead of call to uplooker
'20090331 - PRS decreased RSSI spike down to 4 counts for the 600kHz system
'20090410 - PRS modified subrountine CalcLastGoodBin to allow the user to set the RSSI and Corr filter numbers
'20090422 - PRS modified subroutine CalcLastGoodBin to startbin filtering at 2nd bin, assume 1st bin is good
'20090428 - PRS set correlation threshold as 120 per RDI FSA022
'20090507 - PRS modified subroutine CalcLastGoodBin to use standard deviation of correlation values to filter good bins
'20090605 - PRS added subroutines to filter bad ensembles and monitor the bad ensembles
'20090606 - PRS modified subroutines CalcLastGoodBin to include different filtering cases
'20090609 - PRS modified subroutines CalcLastGoodBin and EnsFilter
'20090610 - PRS Added Subroutine to get CTD Data, plus some modification to stage routine //MRS removed CTD routine -- added YSI
'20090612 - PRS Modified GetCTD subroutine to convert units
'20090825 - PRS Added function to zero pressure sensor, put the counter resets in the main program, correlation and RSSI data for each beam and bin will be output
'           switched from 5 sec scan to 10 sec scan //MRS removed the function to zero pressure sensor -- use offsets
'20091027 - PRS Corrected GetPSPress Subroutine to Zero pressure sensor correctly; added SiteInfo Table to generate SiteParameters when called by Tech
'20091110 - PRS corrected the program to listen for ADCP data instead of sending a CS command, and added Station specific principle directions of flow
'20091117 - PRS,MRS Added code to check for hex 7F7F at start of ensenble and to adjust array to beginning.  Also added code to calculate checksum of
'           incoming data and discard data if calc checksum and ensemble checksum (sent by ADCP) do not agree!
'20091123 - PRS revised the calc last good bin filter to filter out bad bins based on three thresholds
'20091202 - PRS revised Last Good Bin Filter, other minor changes
'20091211 - PRS made some slight changes in LastGoodBinFilter, and added LastGoodBinCheck
'20091216 - PRS modified the way the ADCP data comes in to ensure if there is a transmission error that the program doesnt lock up
'20100610 - MRS modified and cleaned up code to allow communication with Channel Master
'20100623 - MRS Changed true to yes and false to no for JBD's convention
'20100705 - MRS Added YSI subroutine and checking, deleted CTD routine
'20100720 - MRS Added VMstage decode subroutine to decode vertical beam and VM pressure data
'20100724 - MRS Added Loop in Main Decode routine to Check Profile data IDs and apply the correct Offset
'20100806 - MRS Removed Workhorse code (E and N velocities and speed and direction calculations)
'20100807 - MRS Added Filter routines for turbidity and velocity
'20100811 - MRS Added Ablility to FTP QA/QC File at fixed time intervals
'20100818 - MRS Cleaned up code and added comments where needed
'20100907 - JBD Further cleaned\standardized code where needed
'20100916 - MRS moved some code in scan loop to subroutines
'20100920 - MRS fleshed out QA/QC data table
'20100922 - MRS finished v4 test program: added ADCP realtime clock decode and restart attempts variable
'20101007 - MRS Made changes to the cdma stuff -- Added Deep Water Channel defaults to startup subroutine
'20101014 - MRS Added Code to output RSSI average over selected bins -- Moved Allbin RSSI data to new backscatter table --
'20101122 - MRS Worked on Velocity and Stage Spike filters to make them independent of Scan Rate
'20101123 - MRS Replace IFTime Statements with MOD calculations to allow for skipped scans
'20101124 - MRS added code to include all bins in output, but only average user selected bins for iVel
'20101202 - MRS added default flow sign to prevent output of zero velocities
'20101204 - JBD Moved ProgramVersion to top of program and changed variable and added to QAQCInfo datatable
'20101204 - JBD Dimmed out many Public variables (Mike make sure I didn't Dim out any you want to see?)
'20101204 - JBD modified CDMA cycling subroutine (with LoopInterval) to work properly
'20101204 - JBD removed SysInfo datatable and modified QAQCInfo datatable (calls at midnight, Tech visit, no YsiErrCount or BadQcount = 200)
'20101204 - JBD Mike, need to make sure UsrDriveSize will still work with available storage?
'20101204 - JBD put default values for all station parameters in Startup (many are just set to zero. Change before sending to site)
'20101204 - JBD removed the SgtRef Variable (was not ever used)
'20101205 - MRS inserted SubScan statement to allow 60 sec main scan interval while scanning VM for data every 15 seconds
'20101205 - MRS Created DataTable Event for events that cannot wait for 2400 hours - BadQ or BadYSI, tech visit, cdma cycle, and low battery volts.
'20101205 - MRS Created flags so that Event table is only transmitted once every 24 hours
'20101205 - MRS Modified QAQCinfo table so that it is called every scan (for avg, max and min), but only stores and transmits at 5 min past midnight (need to test)
'20101206 - MRS Added small delay after table called to allow time for data storage
'20101206 - JBD removed BadStgCount from the Event table (covered by BadQCount)
'20101207 - MRS added code to assure that only 1 record is stored in QAQCinfo, and added flag for CDMA Clycle to only send warning once per day
'20101208 - MRS Moved FTP code to SlowSequence so ftp delay will not delay main scan
'20101208 - MRS Moved call to CDMA check inside of 15 second subscan
'20101209 - MRS Reset counters at 5 minutes after midnight so that QAQC file has full counter values
'20101209 - MRS Added code suggested by JBD to the YSI data sub menu
'20101210 - JBD Changed the Catastrophy and USR filename to Event
'20101210 - JBD Added some flow\sensor data to the Event table (so we can use as electronic site visit)
'20101210 - JBD Added code to automatically calculate the depth of the YsiSonde based upon initial depth reading
'20101210 - MRS Added 200ms after last call to QAQC to allow time for file storage.
'20101213 - MRS Corrected errors due to file name change from CAT to Event
'20101213 - MRS Changed SW12 statements to allow for normally closed relays
'20110123 - MRS Changed code to allow for both normally open or normally closed CDMA relays -- Defaults to normally closed
'20110615 - JBD Changed the FTP startup defaults, and fixed realtime calculation of Ysi Sonde Depth.
'20110615 - JBD restructured startup default table, and Keypad menu to make more user friendly.
'20110624 - MRS Created debugging version to investigate depth problem
'20110717 - MRS Added decode blocks for vertical commands and amplitude
'20110801 - MRS Added Structure to send commands to ADCP
'20110816 - MRS Deleted amplitude decode subroutine
'20110830 - MRS Added Generic startup block, Added trigger variable for stage 2, Cleaned up code
'20110913 - MRS Added code for banner and CSCmd In WakeVM block
'20110915 - MRS Added code for above and below rating indicators
'20111029 - MRS Added bug fix for random data in StagePrime or stageSecnd if bad value
'20111109 - JBD and MRS removed spike filters, cleaned up, added Median filter to output table
'20111116 - JBD added LowRatVel and HighRatVel and YsiOffset to startup parameters..
'20111121 - JBD added a "SiteVisit" data table, and more choices to site visit reason in keypad menu
'20111121 - JBD standardized CM (Chanel Master) to VM (Velocity Meter) so code can be more easily adapted to other programs
'20111215 - JBD and MRS dimmed out a few more public variables..
'20111229 - JBD cleaned up unnecessary comments, re-arranged routines etc.
'20120110 - JBD added code to keep VM power relay from switching off during site visits.
'20120119 - JBD added a 1min datatable to collect calibration data
'20120120 - JBD added RssiSwath and bin correlation to backskatter data table
'20120130 - MRS added new table "BeamCheck" to record 24hrs of raw RSSI and Corr data on 1st of Month or if user flag set
'20120209 - JBD moved some startup variables out of the Paremeters section, and shortened some keypad menu names
'20120209 - MRS Corrected program big wherein user beamcheck data collection was terminated too early
'20120214 - JBD added stagePrime to the beam check data table
'20120425 - MRS added baudrate choice 9600 or 38400 -- defaults to 38400
'20120430 - MRS Modifed for vemco router use
'20121114 - JBD put in code to wake up CM once per hour to fix sensor glitch (line ~2138)
'20130221 - JBD added code to CDMACheck that when turned on runs CDMA 10mins per hour
'20130625 - JBD changed to float tape code to code for a second pressure sensor
'20130709 - JBD added code to toggle off discharge calculations
'20131104 - JBD slightly modified the pressure sensor subroutines (Bug in PSpress2) and cleaned up some stage related comments
'20131104 - JBD changed the main program scan buffer from 3 to 5
'20131113 - JBD added VMHeading to relevant datatables (for WH HADCPs with compasses)
'20131123 - MRS Added Coordinate system decoding variables
'20131123 - MRS Changed Xvel Yvel Zvel and Evel to V1, V2, V3, and V4 for universal decoding
'20131123 - MRS Fixed bug in ensemble decoding because of Com framing error
'20131123 - MRS Added optional principal flow direction calculation for Earth Coordinate systems
'20131123 - MRS Added Flag to allow recording all beam velocities for use in Radial beam velocity applications and Uplooker applications
'20140131 - JBD modified startup teble to turn on beam check automatically at startup
'20140131 - JBD changed all Cond, Vel and Q variables type in the data out tables from FP2 to IEEE4
'20140131 - JBD consolidate some variables table into the QAQC data table
'20140205 - DWH corrected multiplyer for 3 and 4 byte numbers
'20140218 - MRS corrected code in velocity decoder -- added disable array to use in avg and median reps
'20140218 - MRS corrected code for High and Low measurements
'20140301 - MRS Added code to decode WH pressure sensor
'20140530 - MRS Added code for DO %Saturation
'20140607 - MRS Added code for Stage from YSI
'20140707 - MRS Added code for pitch and roll in beamcheck datatable
'20140716 - MRS Added code to allow beamcheck and calibration data to be collected for 24 hours
'20140723 - MRS Corrected error for YSI stage calc.
'20140923 - MRS Added YSI variables ORP,BGA,FDOM,Ammonium,Nitrate, and Chloride
'20141008 - TAV Added code for stage3 in order to test and compare EXO sonde stage to pressure sensors
'20141204 - JBD Removed old code\comments and fixed minor bug in keypad menu,
'20141204 - JBD wrote code so YSI Locations cant be zero and cause "variable out of bounds error".
'20141208 - TAV changed "Trans" variable to a String in order to revert back to "NAN" in case of incidental changes
'20141216 - TAV testing to get rid of "LocStg" and "YsiStg" because the new EXOs have a pressure sensor, should be no need for these anymore
'               May look at keeping them to keep standardized program that'll work with 6600 or EXO, but turn them off when not needed.
'20150107 - TAV added code to check on the amount of memory left on WH recorder at 00:15 each day. Needed to be aware as WH won't
'               resume deployment if there's a power surge, etc. and there's no memory left.
'20150108 - TAV added a StgRef that will populate in the SiteVisit datatable so we know what the reference (staff or wire weight) at time of visit
'20150114 - TAV,DEA,AAD added variables to allow for an indicator if someone had a visual reference on the stage. Created counter for reference
'           to see how long ago the most recent visual refence on stage
'20150128 - TAV fixed bug in the bad stage flags, added "VisRefOK" to SiteVisit table to more easily see when someone got a reference
'20150205 - MRS Added Code for Bi-Directional rating (different bins depending on flow direction) BI-RATINGS CAN ONLY BE USE WITH CHANNEL MASTERS SET IN INSTRUMENT COODINATES
'20150211 - TAV added "WQVisit", "DiveVisit", and "DaysSince..." counters measurements, WQ, and Dive Visits in order to display values on RTMC
'               to more easily see when service is due at each station.
'20150213 - TAV added "FullVisit" and date variables for WQ, StgRefs, and Dives to more easily see when maintenance was accomplished.
'20150219 - TAV added code to reset "HighMeas" and "LowMeas" to "False" if someone changes the high or low RatVels
'20150309 - TAV added code to automatically get pressure sensor and ADCP serial numbers as well as flags to indicate when a new instrument has been installed
'20150322 - MRS added code to decode the ADCP sn from the LongArray so wakeup and PS0 not needed
'20150406 - TAV added code to send specific flow data to a second datalogger (in this case Sac Waste Water). And send all data tables to a second datalogger in order to test satellite communications.
'20150513 - MRS added panel temperature to serial data out for SRWTP
'20150514 - MRS deleted serial code and added SDI-12 sensor code to output flow data to SRWTP slave data logger.
'20150921 - TAV Added SiteID to VelData Table. Added YSI data to 1min table, created trigger to turn on YSI data. Edited Stage processes. Now uses "StagePrime" to calculate discharge (as before), but instead of "StageSecnd"
'               there are "UpbeamStg", "VMPressStg", "PS1Stg, "PS2Stg", and "YsiStg" and the corresponding "TrueStg" and "Offset" for each. This will keep data in USGS database more organized.
'               Added VMUpbeam and VMTemp to Beamcheck data for Suspended Sediment Concentration studies
'20151013 - MRS Corrected YSI error bug where the sub bypassed the error even if ysi was not sending data.
'20151015 - MRS Beamcheck now recording every 15 mins the time (for sediment data)
'20151116 - MRS Added Code to restart EXO (via the CDMA relay) if ysi data is not present for an hour
'20151118 - TAV Lots of commenting to make program easier to understand. Deleted "StageSecnd" and Stage3" and associated variables. Left the subroutine (commented out)
'               for reference. Changed "OSVersion" to "OSVers". OS28 and higher have "OSVersion" as a constant, somewhere.
'20151203 - TAV Fixed a stage bug. Added "StageSecnd" back in for the sole purpose of getting the differences between stage values (to see if there's drift). Added a TempDiff variable for comparison of YSI and VM Temp.
'               Now the user will select the instrument used to calculate Q (with "SelStgUsed") and the instrument to compare to (with "SelStg2"). At most stations it should be PS1 and PS2. Still need to do some more clean up.
'               A couple edits to the WQ parameters made, added a second FDOM (one is FdomRFU, the other FdomQSU), YsiDO is now "YsiDOmgL". Fixed Keypad menu as well.
'20151228 - TAV Finished up some thorough cleanup. Dimmed a lot of Variables. MRS will dim others. Eliminated "Startup" datatable as it's never been used. Moved BaudRate and VemcoRTR into the scan so user can change on the fly
'               Deleted PowerSwitch as all boards (minus a few Args) have relays now. Deleted "SendSatData" as this was just for testing purposes. Fixed "TrueStage" bug, user shouldn't have issues with the values not "taking" anymore.
'20160128 - MRS Modified the lastgoodbin routine to correctly identify changes in correllation magnitude as well as RSSI.  If profile range exceedes endbin, it no longer gives lastgoodbin as zero.
'               Also changed CorrThreshold to 15 vs 8 to allow for latest program modifications.  Also make sure to set endbin to last valid velocity bin if not lastgoodbin
'20160201 - TAV Added "IsSubmersed" variable to account for situations when we may use a CampbellSci submersible enclosure. If IsSubmersed = True Then use SW12 port to power and cycle ADCP. (No CDMA present)
'20160425 - TAV added code to allow the PT3 command to be parsed out in order to return noise floor for RDI instruments. Had to increase the "Warning" string as well as "SerialIn" command to 2000 to allow for adequate space.
'20160426 - TAV added "NoiseFloor" datatable and a few parameters to the BeamCheck datatable. Noise floor table will be written ONLY with "PT3" command is issued. PT3 command will be automatically once a day per the user's choice, and can be done manually
'20160427 - JBD added Subroutine to obtain external battery voltage from sources larger than 12 volts (36-48 volts)
'20160505 - TAV made a "SiteVisit" record be written when the PT3 command is issued, added YsiWiperPos to know the position of the wiper of the sonde. Useful for WQ processing.
'20160509 - TAV adjusted data types in the QAQC Table for "rVel" and "rStg" from FP2 to IEEE4.
'20160607 - TAV changed all values pertaining to discharge in data tables FROM "Median" to "Average"
'20160627 - JBD added max\min pannel temp to QAQC datatable
'20160629 - TAV dimmed "SelStgUsed" variable so techs CANNOT change primary stage on the fly. They would need to send new program to do so.
'20160711 - TAV finished YsiWiperPos code to alarm techs when the central wiper is outside the housing. Still needs testing! (But won't affect measurements)
'20160721 - TAV Created ConstTable to allow use of this program on either CR1000 or CR6 datalogger. NEED TO CLEAN UP PROGRAM. LOTS OF UNUSED VARIABLES.
'20160823 - MRS\JBD modified the program (hopefully) to work with the VADCP
'20161011 - TAV fixed a couple comport bugs (labelling) for CR6s.
'20161020 - TAV fixed the WakeUpVM to work appropriately with VADCP (needs a "CSTOP" command in order to actually reset instrument". General cleanup, deleted a bunch of unused variables.
'20170403 - TAV added "CardOut" instruction to the SiteVisit table so we would have backups of SiteVisit files.
'20171001 - MRS Program re-designed to Use conditional and custom compile statements and to include Spike detector, EXO serial and EXO burst.
'20180320 - TAV Changed "SiteNum" variable to variable type "String *16" to accomodate short term stations that have long station numbers. Deleted "DiveVisit" stuff. Not really useful anymore.
'20180321 - TAV added a lot of timers around the subroutines for debugging purposes only. Stored every minute in table called "Debugger". Once we're comfortable, we can delete those timers and only keep a couple (ScanStart, ScanEnd, BeforeBurst, AfterBurst, etc.)
'20180323 - TAV Modified the "StoreAllToCard" subroutine to exit the routine if something malfunctioned with the card. Adjusted Data Table sizes to accomodate the "StoreAllToCard" file being written
'               To the card. Current card allocations are: DataOut, Burst, AQ, VelData, BeamCheck: 17280 records (180 days), QAQC and NoiseFloor: 180 records (180 days, unless user activates the NoiseFloor manually)
'               and the SiteVisit table to accomodate 50 records. This allows for ~1.94GB on a 2GB card to be available to the "StoreAllToCard" function.
'               Added ConditionalCompile statements around all WQ variables. If there is no sonde, there's no reason to have the variables populate in the Public table.
'               Created a couple Customize Constants values: "Debugging", "ShowAllVel", and "ShowRawWQ". Allows user to choose whether they want variables associated with those things to be Public or Dim.
'20180329 - MRS Fixed bug causing array out of bounds error if ADCP setup for more than 27 bins. Replaced hard coded 27 with maxbins constant
'20180402 - TAV Fixed bug causing Aquarius table not to write if the logger expected WQ data but the WQ sonde was dead. Added a variable "RecAQFlag". If WQDead AND within 15 sec of 15min mark then RecAQFlag = True
'               Otherwise, resort to normal operation of recording flag with WQ data
'20180405 - TAV Built more timers and counters to narrow down bug causing DataOut to be written every other day. Also reworked how tables are called. Now all data tables are called at the end of the scan, outside of any If...Then statements
'20180406 - TAV Made a user-selectable variable when using the AutoRange function. Now, a user can decide how many bins to cut off at the surface based on their beamchecks. *ONCE IT HAS BEEN RATED, THIS VALUE SHOULD NOT CHANGE!*
'20180509 - TAV Increased WQ "SerialIn" instruction's Max Characters to account for a full suite of sensors/more than 1 parameter per sensor. Set the "GetVariablesFlag" to True in the "Initialize" Sub. Otherwise
'               it wouldn't get called if the system went down and rebooted.
'20180622 - TAV Fixed bug that was disallowing modem to cycle properly. Syntax around Conditional Compile statements regarding SW12 ports was not correct.
'20180706 - TAV Added code to detect "No Sonde" being returned from the SOA. This will put logger into Redeploy mode until a sonde is found.
'20180710 - TAV Added the TrueStage values to the keypad menu.
'               Fixed another Conditional Compile Syntax error regarding the Modem
'               Added SVMaq Table to allow techs to get field visit readings easier without having to scroll through the public table. SVMaq table only stores 1 record.
'               Added IsNClosed to USR variables.
'               Updated BiRating code to allow for use with 3-beam systems that aren't uplookers.
'20180823 - MRS Fixed bug for warning if U ports are used for VM or Sonde on the CR6 using the comms mode 0 option. Put Serialopen commands in subroutines.
'20180824 - MRS Eliminated "baudratehi" and VMbaud is now set in constant menu
'20181018 - TAV added battery voltages (Station, VM, and Wq Sonde) to Aquarius data tables. Added individual sensor stage values to AQ table and removed "StagePrime" and "StageSec". This selection will be done within Aquarius
'               so the changes can be tracked and managed more easily.
'20181114 - MRI created MaxBurstCnt constant, added into constant table so it can be changed more easily. Call burst table when MaxBurstCnt is met and write to Aqurius table.
'20181206 - TAV added Bi-directional rating variables into QAQC Table.
'20181219 - MRI added stagesecnd and selstgsecnd to 1min data table
'20190220 - TAV & MRI reworked entire WQ burst function/loop. It had been reporting 15min late and also not being triggered if the sonde missed the prior 1min punch.
'               Wrote logic to Exit the For...Next... loop if burst values were missed during the burst collection. Still working on logic to COUNT the actual number of values used for the burst. Unless something
'                      happens in the middle of the burst, it's been verified that 30 values are used.
'               Wrote table to sample every value every time through the Burst loop so we have a table stored with each individual sample to verify accuracy of the burst table.
'               Added StdDev, Min, and Max to Burst Table.
'               Now pull median values from the burst table using "MedTempC = Burst.BurstTempC_Med" to populate the AQ table. No sense in having two tables process the exact same functions.
'               Because of how the Median function works, we now "Round" the time of the mid point of the burst. Median is calculated by averaging the two median numbers if the total number of values is even.
'20190227 - MRI added logic to dermine what comms mode to us for the sonde based on if a Max232 was used or not. Current logic requires use of the C ports but additional flag of WQUseUPort may be added if testing shows U ports can be used for sonde communication
'                Due to differences in processing speed the CR1000 was set to use a longer period between samples while collecting burst data to avoid missing/shifting data
'           TAV updated the burst loop to exclude zeroes from the median calculation in the Burst table if there were issues with the communication. Total number of values used in the calculation also seems to be working correctly now.
'20190320 - MRI Added statement to conditional compile out the ADCPLoop if the HasVM is false to avoid potential timing problems
'20190325 - MRI Added BurstPeriod variable in public table so user can adjust the period length that is sent to the sonde during serial burst communication. Had it set to standard 1150 unless otherwise declared. Minimum value is 250. Presereve in USR file too.
'20190401 - TAV Added logic to record Turbidity NTUs (in addition to FNU) if it's a DWR sonde. Also added logic to set the time in PST if instead of UTC if it's a DWR sonde. They are using KOR 2, which makes the time output in local time (PST)
'20190408 - TAV Removed NTU logic per discussions and findings about how the YSI EXO reports the values. Reading is actually FNU. The only thing that changes is the 3 letter acronym, so it is inaccurate to report "NTU".
'20190409 - TAV Made the "Wq_Mark_Bad" function only occur if its a USGS sonde, not a DWR sonde in Sample and Hold mode.
'20190509 - TAV Added CR6-RF451 radio link checking logic and reset if link is broken with up 4 total nodes in the system.
'20190510 - TAV Added base code to accept a daisy-chained EXO system (2 Sondes total).
'20190522 - MRI Altered communication with SOA to address sondes independently and accept commands for the targeted sonde only and send data to the correct field. Flags for redeploy and cycleWQpower work if either sonde is having problems
'20190529 - TAV Added Suna Code to program
'20190610 - MRI Added "OneMinConsistent" variable to allow 1min data to be recorded for a long period of time
'20190625 - TAV Adjusted timing of burst and suna samples, adjusted MOD functions and moved them to the top of the scan. Lessened delays between EXO redeploy routines to ensure we don't skip scans if the exo dies.
'20190703 - MRI Implemented easier to track program versioning with variable "ProgramVersion". Starting at 4.0. Adjustment of the version number should reflect severity of the changes made.
'20190705 - TAV Added V1, V2, V3, V4 to DataOut table.
'20190709 - TAV Increased buffer for SUNA port when it's opened to record data. Eliminated delay between opening the SerialIn command. Adjusted when the Suna gets turned off if it was manually turned on.
'20190710 - TAV Added Program info to SVMaq table for easy access in case it's needed before midnight when QAQC gets written.
'20190711 - TAV Put "MaxBins" in the Customize Constants section to more easily establish how many bins are wanted at the site.
'           TAV Fixed some problems with conditional compiling if WqSonde = "NONE". Still some more work to do with other Customuze Constant options.
'20190712 - MRI 4.21 Adjusted BinSpikes to pull from MaxBins variable to stop error when more than 27 bins are being collected. Fixed bug with top bottom sonde where the btm error flags would not reset after a power cycle.
'20190809 - MRI 4.22 Added FlowSign to the USR drive to prevent issue of incorrect flow sign being entered in the program, user reset in the field to be correct with the public table, and then a power cycle resets sign to original, incorrect value.


'IMPORTANT - SDI-12 Code should be commented out if program is not being used at Freeport Sites.  If program is being used at freeport then the SlaveCom master slave code (used for fish recievers) MUST be commented out
'IMPORTANT - ADCP should be set for 1 minute TE and WP 60.
'IMPORTANT - For EXO2 serial operation, A MAX232 adapter must be used on CR6 "U" ports or CR1000 Com1.Com2,Com3 or Com4. An ADCP can run on all ports, but
'            a MAX232 adapter should probably be used if using CR6 "U" ports or for long RS232 cables.
SequentialMode 'must not use pipeline mode or averages are missed

'_____________________________Declare Public Variables___________________________________
Const Yes = True
Const No = False
'-------------------------------------------------------------------------------------------
'------------------------------------------------------------------------------------
'Customize constants explanation:
'WQSonde has the following choices"
' "NONE" is if there is no WQ Sonde installed at the station
' "WQ_SDI12" Choose if the WQ Sonde is SDI12
' WQ_Serial" Choose if the WQ Sonde is connected to the Serial port and No Burst is required
' "WQ_SERIAL_BURST" Choose if the WQ sonde is serial connected and Burst data is required
'"WQBaude" is the Sonde buadrate. 38400 or 9600.  38400 is preferred if Burst data is required
'"IsWQMax232" Choose if there is a MAX232 adapter on the Sonde Com port
'"IsVMMax232" Choose if there is a MAx232 adapter on the VM com port
'"IsSpecStudy" Choose if the VM is being used for a special velocity study
'"GetNoiseFloor" Choose if this is a sediment station and VM noise floor data is required
'"HasSlave" Choose if there is a slave datalogger attached that needs velocity and stage info
'"HasVM" Choose if there is a Velocity meter at this station
'"UseAutoRange" This will change EndBin based on water depth above transducer face for Uplooker sites
'"WQDeadCntMax" number of scans (1 min) of no WQ data before cycling power to the WQ sonde (5 to 120)
'VMDeadCntMax"  number of scans (1 min) of no VM data before cycling power To the VM (5 To 120)
'"StoreAllToCard"  Store all beam data (RSSI, Corr, Velocity) to Micro SD card (CR6) or CF card (CR1000)

'Change these values in the Tools/Customize Constants dropdown dialog
'do not change commented items in this customization section!!!!!!, they are like the keypad menu items.

'Start of Constants Customization Section
Const WqSonde = "WQ_SERIAL_BURST"
'Value = "WQ_SDI12"
'Value = "WQ_SERIAL"
'Value = "WQ_SERIAL_BURST"
'Value = "NONE"
Const DWRSonde = False
'value = True
'value = False
Const TopBottom = False  'Is there a second EXO daisy-chained in the system
'value = True
'value = False
Const HasSuna = False 'THIS WILL ONLY COMPILE ON A CR6!
'value = True
'value = False
Const MaxSunaBurst = 30
'Min = 10
'Max = 30
'Inc = 1
Const WqBaud = 38400
'value = 9600
'value = 38400
Const VmBaud = 38400
'value = 9600
'value = 19200
'value = 38400
'value = 57600
'value = 115200
Const IsWqMax232 = False 'If using a CR1000 and collecting serial burst water quality data this should be true
'value = True
'value = False
Const MaxBurstCnt = 30
'Min = 1
'Max = 30
'Inc = 1
Const MinBurstVals = 4
'Min = 1
'Max = 30
'Inc = 1
Const IsVmMax232 = False
'value = True
'value = False
Const IsSpecStudy = False
'value = True
'value = False
Const GetNoiseFloor = False
'value = True
'value = False
Const HasSlave = False
'value = True
'value = False
Const HasVM = True
'value = True
'value = False
Const MaxBins = 27
'Min = 1
'Max = 100
'Inc = 1
Const UseAutoRange = False
'value = True
'value = False
Const WQDeadCntMax = 20
'Min = 5
'Max = 120
'Inc = 5
Const VMDeadCntMax = 20
'Min = 5
'Max = 120
'Inc = 5
Const RadioNetwork = False 'Is the datalogger part of a radio network NOTE: IF TRUE THIS WILL ONLY COMPILE ON CR6-RF451!!
'value = True
'value = False
Const IsMaster = False  'Is the datalogger the Master in a radio network?
'value = True
'value = False
Const StoreAllToCard = True
'value = True
'value = False
Const Debugging = False
'Value = True
'Value = False
Const SeeAllVel = False
'Value = True
'Value = False
Const SeeRawWQ = False
'Value = True
'Value = False
Const ReadExtPwr = False
'End of Constants Customization Section

'------------------------------------------------------------------------------------------
'Constants to allow program to be used on CR1000 OR CR6 datalogger.
'in this preliminary version it's assumed that the CDMA uses SW12 no 1 on both dataloggers
'IMPORTANT! if using CR6 ports ComC1 or ComC3 use the device configuration utility to configure these ports for RS-232 (not TTL or other)
'-------------------------------------------------------------------------------------------------------------------------------------------
#If LoggerType = CR1000 Then
  Const AdcpPort = Com1
  Const WqSerialPort = Com4
  Const VMSwitchPort = 4 'only used if not using sw12
  Const WqSwitchPort = 6
  Const PS1Com3 = 3
  Const PS1Com5 = 5
  Const PS2Com3 = 3
  Const PS2Com5 = 5
  Const WqCom3 = 3
  Const wqCom5 = 5
  #If HasSlave = Yes Then
    Const SlaveCom = Com4
  #EndIf
  #If ReadExtPwr = True Then
    Const ExtPwrCom = 1
    Const ExtSolarCom = 2
  #EndIf
#ElseIf LoggerType = CR6 Then
  Const AdcpPort = ComU1
  Const WqSerialPort = ComC3
  Const WqSwitchPort = U6
  Const UseSW12_2_forWQ = False
  Const VMSwitchPort = U4
  Const PS1Com3 = U3
  Const PS1Com5 = U5
  Const PS2Com3 = U3
  Const PS2Com5 = U5
  Const WqCom3 = U3
  Const wqCom5 = U5
  #If HasSuna = True Then
    Const SunaPort = ComC1
    Const SunaWipeSwitch = U9
    Const SunaSwitch = U10
  #EndIf
  #If HasSlave = Yes Then
    Const SlaveCom = ComU7
  #EndIf
  #If RadioNetwork Then
    Const DefRadOn = 0
    Const DefOpMode = 2
    Const DefFreqKey = 0
    Const DefMaxPacket = 8
    Const DefMinPacket = 9
    Const DefDataRate = 3 'Normal
    Const DefTxPwr = 10 'Max
    Const DefRetryTO = 255 'Max
    Const DefLowPwr = 2
    Const DefRepeaters = 0 'No repeaters
    Const DefPacketRepeat = 2
    Const DefSlaveRetry = 9
    Const DefFreqRepeat = 0
    Const DefSlaveRepeat = 0
    Const DefTxSubID = 15
    Const DefRxSubID = 15
    Const DefNetID = 1234
  #EndIf
  #If ReadExtPwr = True Then
    Const ExtPwrCom = U11
    Const ExtSolarCom = U9
  #EndIf
#EndIf


'Declare Constants
Const VelocityScaleWater = 1/304.8 'converts mm/sec to ft/sec
'constants for selecting different stage devices
Const ScanRate = 60
Const ScanUnit = 2
Const FastScanRate = 15
Const FastScanUnit = 2
Const UPbeam = 1
Const VMpress = 2
Const PSpress = 3
Const PSpress2 = 4
Const WqPress = 5
'data ID's
Const FixedLeaderID = 0 'data IDs located at the start of each data stream
Const VariableLeaderID = 128
Const CorrelationProfileID = 512
Const RSSIProfileID = 768
Const PGoodProfileID = 1024
Const VelocityProfileID = 256
Const VMStageID = 16384
Const BottomID = 1536
'Const MaxBins = 27 'Changed back to 27 per JBD
Const MaxBeams = 4
Const BadVel = -32768 'bad velocity indicator from adcp
Const BadDataIndicator = NAN
Const Meters_to_Feet = 3.280839895
Const DegToRad = (3.14159265358979323846/180) 'degrees to radians

'Declare Misc Veriables
Public SiteID As String * 6 '3 character station identification
Public SiteNum As String * 16 'station number
Public CR1Volts As Float 'power supply voltage to cr10000
Public ExtWHConvertVolt As Float 'get volts from external power supply or battery pack
Public ExtSolarVolt As Float 'get volts from solar panel
Public PTempC As Float 'CR1000 panel temperature in DegC
Public PTempF As Float 'CR1000 panel temperature in Degf
Public BurstPeriod As Long 'give user ability to alter burst period in the public table
Public RecCalibData As Boolean 'flag to record data at 1 minute interval when measurements are being done.
Public OneMinConsistent As Boolean 'flag to record data at 1 minute interval for prolonged periods of time
#If HasSuna Then
  Public ManualSunaOn As Boolean
#EndIf
Public StoreVariablesFlg As Boolean
Public GetVariablesFlg As Boolean
Dim Rec15minFlag As Boolean 'set when Dataout table is stored
Public RecAQFlag As Boolean 'Set when problem with Sonde but still want to record to the Aquarius table
Dim Rec24HrFlag As Boolean 'set when QAQC table is stored
Dim Rec1MinFlag As Boolean 'set when recording Calibration data
Dim OneMinCount As Long 'used to turn off calibration data after 24 hours (1439 minnutes)
Dim RecDataFlag As Boolean 'used to check timing of ensemble data
Public RecAllVelFlag As Boolean 'used to set timing for velocity collecting in Special studies
Public VemcoRTR As Boolean 'used to set datalogger as "Master" in Master/Slave configurations (originially used for VEMCO deployments)
Public IsSubmersed As Boolean ''used to switch the function of the SW12V port so it's used for ADCP if the datalogger is in a submersible enclosure (with no relays, CDMA, etc.)
Public Prompt As String *5
Dim RecBeamCheckFlag As Boolean 'flag to turn beamcheck table on or off
Public LowRatVel As Float' user input of lowest velocity covered by rating
Dim InitialLRV As Float ' used for changing LowMeas flag to false if there's been a change to the LowRatVel
Public HighRatVel As Float' user input of Highest velocity covered by rating
Dim InitialHRV As Float 'used for changing HighMeas flag to false if there's been a change to the HighRatVel
Public LowMeas As Boolean 'flag indicating low flow measurement needed
Public HighMeas As Boolean 'flag indicating high flow measurement needed
Dim LowCount As Long 'counter for number of times velocity is below the Lower limit
Dim HighCount As Long 'Counter for number of times velocity is above the upper limit
Public VMPower As Boolean 'flag to turn VM on and Off manually
Public isVMNClosed As Boolean 'is the VM powered using a Normally clo9sed relay
Public VmDeadCount As Long 'number of times VM has bad data
#If Debugging = True Then
  Public UseCommsZeroForADCP As Boolean 'Used to set comms mode when C1,C3 com ports are used on the CR6 for the ADCP
  Public UseCommsOneForSonde As Boolean 'Used to set comms mode when C1,C3 com ports are used on the CR6 for the Sonde
  Public UseCommsZeroForSonde As Boolean 'Used to set comms mode when C1,C3 com ports are used on the CR6 for the Sonde
  Public WqUseCPort As Boolean 'Used to set comms mode when C1,C3 com ports are used on the CR6 for the Sonde. Future version may allow U ports too.
#Else
  Dim UseCommsZeroForADCP As Boolean 'Used to set comms mode when C1,C3 com ports are used on the CR6 for the ADCP
  Dim UseCommsOneForSonde As Boolean 'Used to set comms mode when C1,C3 com ports are used on the CR6 for the Sonde
  Dim UseCommsZeroForSonde As Boolean 'Used to set comms mode when C1,C3 com ports are used on the CR6 for the Sonde
  Dim WqUseCPort As Boolean 'Used to set comms mode when C1,C3 com ports are used on the CR6 for the Sonde. Future version may allow U ports too.
#EndIf
'Declare variables to hold time values
Dim rTime(9) As Float 'this array holds time values returned from the realtime statement
Alias rTime(3) = DOM 'FOR BEAM CHECK
Alias rTime(4) = Hour
Alias rTime(5) = Minute
Alias rTime(6) = Second
Alias rTime(7) = MicroSecond
Public LastScan As String * 6 'when did the datalogger most recently scan?
Dim RealSeconds As Long 'used for computing elapsed time intervals
Dim Mod5Minutes As Long 'used for computing elapsed time intervals
Dim Mod15Minutes As Float 'used for computing elapsed time intervals
Dim Mod60Minutes As Float 'used for computing elapsed time intervals
Dim ModDay As Float 'used for computing elapsed time intervals
#If Debugging = True Then
  Public VMYear As Long 'Date time from the Velocity meter clock
  Public VMMonth As Long 'Date time from the Velocity meter clock
  Public VMDay As Long 'Date time from the Velocity meter clock
  Public VMHour As Long 'Date time from the Velocity meter clock
  Public VMMinute As Long 'Date time from the Velocity meter clock
  Public VMSecond As Long 'Date time from the Velocity meter clock
  Public VMTime As String * 25 'Date time from the Velocity meter clock
  Public SetVMTimeFlg As Boolean 'used it setting VM Time
  Public VMTimeString As String * 25 'used it setting VM Time
  Public SplitTime(6) As Float 'used it setting VM Time
  Public RawSetTime As String * 25 'used it setting VM Time and EXO time
  Public FSplitTime(6) As Float 'used it setting VM Time
#Else
  Dim VMYear As Long 'Date time from the Velocity meter clock
  Dim VMMonth As Long 'Date time from the Velocity meter clock
  Dim VMDay As Long 'Date time from the Velocity meter clock
  Dim VMHour As Long 'Date time from the Velocity meter clock
  Dim VMMinute As Long 'Date time from the Velocity meter clock
  Dim VMSecond As Long 'Date time from the Velocity meter clock
  Dim VMTime As String * 25 'Date time from the Velocity meter clock
  Dim SetVMTimeFlg As Boolean 'used it setting VM Time
  Dim VMTimeString As String * 25 'used it setting VM Time
  Dim SplitTime(6) As Float 'used it setting VM Time
  Dim RawSetTime As String * 25 'used it setting VM Time and EXO time
  Dim FSplitTime(6) As Float 'used it setting VM Time
#EndIf
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Public EXOTimeString As String * 25
  Public SetEXOTimeFlg As Boolean
#EndIf

'spike filter variables
#If HasVM Then
  Dim RSSIspike(MaxBins,4,16) As Float 'array to hold RSSI data Queue
  Dim Corrspike(MaxBins,4,16) As Float 'array to hold Correlation data Queue
  Dim Velspike(MaxBins,4,16) As Float 'array to hold Velocity data Queue
  Dim StageSpike(16) As Float 'array to hold Stage data Queue
  Public QueueDQI As Float 'data quality indicator for Queue
  Public RSSIStdNo As Long = 2  ' standard deviations from mean for spike
  Public CorrStdNo As Long = 2
  Public VelStdNo As Long = 2
  Public SpikeFileName As String * 64
  Dim FileHandle As Long
  Public FileHeader As String * 500
  Public SpikeCounter As Long
  Public SendHeader As Boolean = True
  Public TestTime As String * 20
  Public CardError As String * 25
#EndIf

'Declare variables for CDMA
Dim CdmaScans As Long 'number of times the datalogger has unsuccessfully attempted to connect to the loggernet server
Public HrsCdmaOff As Long 'how many hours to allow to pass before trying to restart the CDMA if there are connection issues
Dim LoggernetAddr As Long 'LoggerNet server PakBus address (generally 4094). if datalogger doesn't see this address as a "neighbor" it assumes connection failure
'which is used for knowing when to reset CDMA (using the variables above)
Public CdmaWorks As Boolean 'using the above variable "LoggernetAddr", does the datalogger see 4094 as a neighbor? if not, it's assumed CDMA does not work
Dim CDMAFailure As Boolean 'indicator of a CDMA failure for triggering a reset
Public CycleCdmaPwr As Boolean 'cycle the power to the CDMA
Public IsCDMAOn As Boolean 'Is the CDMA powered? (based on the switch 12V port status, (on or off), and the "IsNClosed" variable
Public IsCDMANClosed As Boolean 'Is there a Normally Closed Relay installed in the CDMA circuit, if yes, SW12V port stays OFF to keep power to CDMA. if no, SW12V port
'stays ON to power the CDMA
Public KeepCDMAon As Boolean 'keep CDMA 24/7 (true) or turn on at the top of the hour for 10 minutes to save battery power (false)

'Declare variables to hold system status information
Public Tech As String * 3 'user initials so we know who was there for a visit
Public VisitReason As String *100 'what is the purpose of the visit
Public SerNum As Long 'datalogger computer serial number
Public OSVers As String * 18 'datalogger Operating System version
Public Program As String * 25 'Program version
Public ProgVersDate As String * 8 'date of the program version, based on the constant "ProgramVersionDate"
Public ProgVersion As String * 5 'program version number, based on constant "ProgramVersion"
Public ProgErrors As Long 'from "Status" table, The number of compile or runtime errors for the current program.
Public Low12Volts As Long 'from "status" table, how many times has there been low voltage (based on CR1000 threshold of 9.6v when the CR1000 goes into a lower power
'mode and discontinues it's measurement tasks until power is restored)
Public LithBat As Float 'voltage of the internal lithium battery. (this battery keeps memory in case of external power issues)
Public SkipScans As Long 'number of times a complete scan has been skipped (with the exception of intentionally skipped scans based on ExitScan and Do/Loops
Public FreeCFMem As Float 'how much memory does the external CF card have remaining

Public ErrorEvent As String * 100 'what caused the automated "SiteVisit" table to be written?
Public Coord As String * 20 'which coordinate system is the ADCP using?
Dim ADCPSN01 As Long 'the following "ADCPSNxx" are used to have a record of which serial number is being used and if it's been changed
Dim ADCPSN02 As Long
Dim ADCPSN03 As Long
Dim ADCPSN04 As Long
Public AdcpSN As Long
Dim InitialAdcpSN As Long 'used to hold the previous day's serial number and flag it if the instrument has changed
Public NewADCP As Boolean 'is it a new ADCP?
Public PS1SN As String * 40 'used to get pressure sensor brand, model, and serial number
Dim InitialPS1SN As String * 40 'used to hold the previous day's serial number and flag it if the instrument has changed
Public NewPS1 As Boolean 'is it a new pressure sensor?
Public PS2SN As String * 40 'used to get pressure sensor brand, model, and serial number
Dim InitialPS2SN As String * 40 'used to hold the previous day's serial number and flag it if the instrument has changed
Public NewPS2 As Boolean 'is it a new pressure sensor?

'Decoding Velocity variables
Public BadChecksum As Long 'if
Public HeaderMismatch As Long
Dim NumbytesZero As Long
Public CalcCheckSum As Float
Public EnsChecksum As Float
Dim TempL As Long
Public Numbytes
Public BadEnsemble As Long
Public ScanNo As Long
Dim Longarray(2000) As Long 'Array for the Raw Ensemble
Dim Nums(2) As Long
Public EnsembleLen As Long
Dim Datatypes As Long
Dim Offsets(25) As Long 'offsets to the start of the datatype locations
Public BinSize As Long 'ADCP bin size in centimeters
Public NumADCPBins As Long 'ADCP number of bins
Public Numbins As Long 'number of adcp bins used
Public EnsPings As Long 'Number of acoustic pings per ensemble
Public NumBeams As Long 'Number of beams on ADCP
Public BlankDist As Long 'Blanking distance of ADCP
Public EX As Long 'coordinate transformation
Public ES As Long 'Salinity
Public Decode As String * 70
Public FramingError As Long
Dim FixedLeadOffset As Long
Dim MSB As Long
Dim MSB1 As Long
Dim LSB As Long
Dim ReceivedBytes As Long
Dim TempId As Long 'for testing
'Dim UseAutoLastBin As Boolean
Public UseDir As Boolean 'does the user want to use compass direction of flow to indicate flood or ebb?
Public PosFlowDir As Float 'what is the compass bearing that indicates a positive flow? (outgoing flow)
Public RecordAll As Boolean
Public PreserveFile As String * 500
'Declare Vel and Q variables
Public CalcQ As Boolean 'user select whether to calculate discharge or not
Public UseV2 As Boolean
Public IndexVel As Float 'index velocity based on rating
Public MeanVel As Float 'average channel velocity based on all bin data
Public Qcfs As Float 'total discharge
Public BadQCount As Long 'how many times has the datalogger been unable to calculate discharge? (either bad stage value or bad velocity value)
Public MinExpVel As Long 'minimum velocity expected at site
Public MaxExpVel As Long 'maximum velocity expected at site
Public FlowSign As Long 'positive or negative multipler depending on which side of the channel the instrument is on
Public BadVelCount As Long 'how many times has there been bad velocity?
Public BadBinCnt As Long
Public DataErr As Long
Public BadVelFlag As Boolean 'indicates there was a data punch with invalid velocity
Public BadQFlag As Boolean 'indicates there was a data punch with invalid discharge
Dim VelDatOffset As Long 'Velocity offset (location of the beginning of velocity data
Dim Bin As Long 'counters for bins
Public StartBin As Long 'where the datalogger begins its iVel calculation
Public StartEbbBin As Long' Use if using ebb and flood rating
Public EndEbbBin As Long' Use if using ebb and flood rating
Public StartFldBin As Long' Use if using ebb and flood rating
Public EndFldBin As Long' Use if using ebb and flood rating
Public EndBin As Long 'where the datalogger ends its iVel calculation
Public BiRating As Boolean = False 'Use this flag if using Ebb/Flood rating
Public BiRatOK As Boolean = False 'Used by program to determin if BiRating can be done
Public UseBiRat As Boolean = False 'flag set if both the above are true
Public BiRatTran As Float  'Transition velocity for ebb/flood Rating
Dim Beam As Long 'counters for beams
Dim temp As Long 'temporary variable
Dim Index As Long 'temporary variable
Dim BinVel As Float 'test variable
Dim BinStep As Long 'counter variable
Dim EnsBin As Long 'counter variable
Dim ensVelocity(MaxBins,4)As Float '30 bins, and 4 beams max Velocity Data
#If SeeAllVel = True Then
  Public V1(MaxBins) As Float 'Can be either Beam 1 velocity, X velocity, or East velocity
  Public V2(MaxBins) As Float 'Can be either Beam 2 velocity, Y velocity, or North velocity
  Public V3(MaxBins) As Float 'Can be either Beam 3 velocity, Z velocity, or UP velocity
  Public V4(MaxBins) As Float 'Can be either Beam 4 velocity, or Error velocity
  Public VMBinVel(MaxBins) As Float 'Up/Dowm stream velocity in each bin
#Else
  Dim V1(MaxBins) As Float 'Can be either Beam 1 velocity, X velocity, or East velocity
  Dim V2(MaxBins) As Float 'Can be either Beam 2 velocity, Y velocity, or North velocity
  Dim V3(MaxBins) As Float 'Can be either Beam 3 velocity, Z velocity, or UP velocity
  Dim V4(MaxBins) As Float 'Can be either Beam 4 velocity, or Error velocity
  Dim VMBinVel(MaxBins) As Float 'Up/Dowm stream velocity in each bin
#EndIf

Dim VelCount As Long 'counter for number of velocity measurements
Dim BadBinCount As Long

'Velocity Averaging Variables  NOTE! EBB FLOOD RATINGS CAN ONLY BE USED WITH CHANNEL MASTERS SET TO INSTRUMENT COORDINATES
Dim V1Sum As Float 'sum of bins in each ensemble for V1
Dim V1EbbSum As Float ' sum of bins in each ensemble for V1 in positive dir
Dim V1FldSum As Float ' sum of bins in each ensemble for V1 in Neg dir
Dim V2Sum As Float 'sum of bins in each ensemble for V2
Dim V2EbbSum As Float ' sum of bins in each ensemble for V2 in positive dir
Dim V2FldSum As Float ' sum of bins in each ensemble for V2 in Neg dir
Dim V3Sum As Float 'sum of bins in each ensemble for V3
Dim V4Sum As Float 'sum of bins in each ensemble for V4
Dim V1Disable(MaxBins) As Boolean
Dim V2Disable(MaxBins) As Boolean
Dim V3Disable(MaxBins) As Boolean
Dim V4disable(MaxBins) As Boolean
Dim VmBinVelDisable(MaxBins) As Boolean
Public V1AVG As Float 'average of bins in each ensemble for V1
Dim V1EbbAvg As Float 'average of bins in each ensemble for V1 for pos dir
Dim V2EbbAvg As Float 'average of bins in each ensemble for V2 for pos dir
Public V2AVG As Float 'average of bins in each ensemble for V2
Dim V1FldAvg As Float 'average of bins in each ensemble for V1 for Neg dir
Dim V2FldAvg As Float 'average of bins in each ensemble for V2 for Neg dir
Public V3AVG As Float 'average of bins in each ensemble for V3
Public V4AVG As Float 'average of bins in each ensemble for V4
Dim Cnt As Long
Public V1Cnt As Long
Dim V1EbbCnt As Long
Dim V2EbbCnt As Long
Dim V1FldCnt As Long
Dim V2FldCnt As Long
Dim V2Cnt As Long
Dim V3Cnt As Long
Dim V4Cnt As Long
Const rad = 3.14159/180
Const deg = 180/3.14159

'Decoding Variable leader
Dim VarLeadOffset As Long '---data variables from variable leader---
Public BIT As Long
Public EnsembleNo As Long

'Decoding RSSI Data
Dim RSSIDatOffset As Long   'location of start of RSSI data
Dim ensRSSI(MaxBins,4) As Long  'MaxBins bins and 4 beams max  RSSI Data
Dim nRSSI As Long 'for RSSI average calc
Dim AccumRSSI As Long 'for RSSI average calc
Dim AvgRSSI(MaxBins) As Long 'average of all beams for that bin per ensemble
Public AvgRSSIStartBin As Long
Public AvgRSSIEndBin As Long
Dim AvgRSSIcounter As Long
Dim AvgRSSIAccum As Long
Public AvgSwathRSSI As Float

'Decoding Correlation Magnitude
Dim CorrDatOffset As Long 'location of start of correlation data
Dim ensCorr(MaxBins,4) As Long '25 bins and 4 beams max Correlation Data
'Dim TempCorr(4) 'temporary array for calculating standard deviation of Correllation
Dim nCorr As Long
Dim AccumCorr As Long
Dim AvgCorr(MaxBins) As Long 'average of all beams for that bin per ensemble
'Dim StdDevCorr(MaxBins) As Float 'holder for std dev of 4 beam correlation

'Decoding Channel Master and Workhorse Stage
Public VMStageDatOffset As Long
Dim L1SB As Long
Dim M1SB As Long
Dim TempM As Float
#If Debugging = True Then
  Public VMTemp As Long 'temporary debugging variable
  Public VMPSTemp As Long 'temporary debugging variable
  Public WHPSTemp As Float 'for workhorse pressure
  Public WHTempM As Float
  Public WHTempK As Float
#Else
  Dim VMTemp As Long 'temporary debugging variable
  Dim VMPSTemp As Long 'temporary debugging variable
  Dim WHPSTemp As Float 'for workhorse pressure
  Dim WHTempM As Float
  Dim WHTempK As Float
#EndIf

'System Identification
Public IsCM As Boolean
Public IsVADCP As Boolean
Public IsWorkhorse As Boolean


'Data Filtering Variables
Public SelectFilter As Long
Public RangedBin As Long = 0 'holder for last bin before surface corruption
Public DucerDepthOffset As Float' difference between depth sensor and transducer face. (+/-) - if lower than ducer + if higher
Public RangeSource As Long 'sensor source for ducer depth calculation
Public CutOffBins As Long 'user enterable value for number of bins to discard when using AutoRange feature for uplookers
'Dim cntBin As Long 'counter for LastGoodBin Check
'Dim cntBin2 As Long 'second counter for LastGoodBin Check
Public RSSIThreshold As Float 'allows user to set RSSI Threshold
Public StdCorrThreshold As Float 'allows user to set stddev threshold for correlation of 4 beams
Public CorrThreshold As Float
'Dim TestEns As Long
'Dim EnsLoop As Long
'Dim AvgRunEns As Float
'Dim RunEnsSpikes As Long
Dim BadEnsCount As Long
'Dim BadEnsFlag As Boolean
Dim LoopInterval As Long
Dim FastLoopInterval As Long

'Declare Event variable flags
Dim EventCDMAFlag As Boolean 'added so cdma cycle is only recorded every 24 hours
Dim EventVoltFlag As Boolean '  '   '  Low Voltage  "       "       "      "
Dim EventYSIFlag As Boolean  '   "   " BadYSI = 200  "     "        "      "
Dim EventQFlag As Boolean    '   "   " BadQ = 200    "     "        "      "

'Declare Stage and Area Variables
Public PSPressPort As Long 'port Pressure sensor 1 is plugged into (3 or 5)
Public PSPressAddr As Long 'SDI12 address for Pressure sensor 1
Public PSPressDataIn As Boolean 'are there data from Pressure sensor 1?
Public PsPress1Stg(2) As Float 'array to hold the values pressure sensor 1 is outputting (temp and feet)
Alias PsPress1Stg(1) = PS1RawDepthFt 'Label array as easy-to-read values for techs
Alias PsPress1Stg(2) = PS1TempC
Public PSpress2Stg(2) As Float 'array to hold values pressure sensor 2 is outputting
Alias PSpress2Stg(1) = PS2RawDepthFt 'Label array as easy-to-read values for techs
Alias PSpress2Stg(2) = PS2TempC
Public PSpress2Port As Long 'port pressure sensor 2 is plugged into (3 or 5)
Public PSpress2Addr As Long 'SDI12 address for pressure sensor 2
Public PSpress2DataIn As Boolean 'are there data from pressure sensor 2?
Public StagePrime As Float 'stage value used in calculating discharge
Public StageSecnd As Float 'stage value used in calculating stage difference
Public StgDiff As Float 'absolute value of difference between StagePrime and the user selected instrument stage
Public UpBeamStg As Float 'stage value (after offset applied) for ADCP vertical beam
Public VMPressStg As Float 'stage value (after offset applied) for ADCP pressure sensor
Public PS1Stg As Float ''stage value (after offset applied) for pressure sensor 1
Public PS2Stg As Float ''stage value (after offset applied) for pressure sensor 2
Public SondeStg As Float ''stage value (after offset applied) for YSI or EXO sonde
Public TrueUpBeamStg As Float 'user input stage reference to calculate (and apply) offset to raw upbeam data to output "UpBeamStg"
Public TrueVMPressStg As Float 'user input stage reference to calculate (and apply) offset to raw ADCP pressure sensor data to output "VMPressStg"
Public TruePS1Stg As Float 'user input stage reference to calculate (and apply) offset to raw Pressure sensor 1 data to output "PS1Stg"
Public TruePS2Stg As Float 'user input stage reference to calculate (and apply) offset to raw pressure sensor 2 data to output "PS2Stg"
Public TrueSondeStg As Float 'user input stage reference to calculate (and apply) offset to raw YSI data to output "YsiStg"
Dim SelStgPrime As String 'which of the 5 stage options is used to calculate discharge
Public SelStgSecnd As String 'Which of the 5 stage options is used to calculate stage difference
Public UpBeamOffset As Float 'offset applied to raw data to get stage value
Public VMPressOffset As Float'offset applied to raw data to get stage value
Public PS1Offset As Float'offset applied to raw data to get stage value
Public PS2Offset As Float'offset applied to raw data to get stage value
Public SondeOffset As Float'offset applied to raw data to get stage value
Public StgSelect As String 'numerical indicator of which instrument is being used to calculate discharge within the datalogger
Public Area As Float 'calculated channel area based on stage-area rating
Public BadStgFlag As Boolean 'indicates bad stage value
Public BadStgCount As Long 'indicates number of times bad stage values have occured
Public MaxExpStg As Long 'maximum expected stage
Public MinExpStg As Long 'minimum expected stage

'Declare Rating Variables
'Should we make these arrays for easier output?
Public StgOffset As Float 'stage-area equation coefficient
Public StgCoef As Float 'stage-area equation coefficient
Public StgCoef2 As Float 'stage-area equation coefficient
Public VelOffset As Float 'iVel equation coefficient
Public VelCoef As Float 'iVel equation coefficient
Public VelCoef2 As Float 'iVel equation coefficient
Public VelCoef3 As Float 'iVel equation coefficient
Public UpVelOffset As Float 'iVel equation coefficient for velocities above transition point (in break point rating)
Public UpVelCoef As Float 'iVel equation coefficient for velocities above transition point (in break point rating)
Public UpVelCoef2 As Float 'iVel equation coefficient for velocities above transition point (in break point rating)
Public UpVelCoef3 As Float 'iVel equation coefficient for velocities above transition point (in break point rating)
Public LowVelOffset As Float 'iVel equation coefficient for velocities below transition point (in break point rating)
Public LowVelCoef As Float 'iVel equation coefficient for velocities below transition point (in break point rating)
Public LowVelCoef2 As Float 'iVel equation coefficient for velocities below transition point (in break point rating)
Public LowVelCoef3 As Float 'iVel equation coefficient for velocities below transition point (in break point rating)
Public Trans As String * 4 'Transition point in velocity where iVel calulation decides to use upper or lower rating equation
'                           Float was used, changed to a 3 character string in case someone accidentally types a number in, this will allow user to revert back to "NAN" -TAV 20141208
'declare variables for EXO and SDI
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Public WqNparams = 24
  #If TopBottom Then
    Public BtmWqNparams = 24
  #EndIf
  Public Redeploy As Boolean
  Public NoSondeTrig
  #If TopBottom Then
    Public BtmNoSondeTrig
  #EndIf
  Public GetBurst As Boolean
  Public StartTopBurstTimer
  #If TopBottom = False Then
    Public StartTopBurst As Boolean
    Public TopBurstDelay
  #EndIf
  #If TopBottom Then
    Public GetBtmBurst As Boolean
    Public StartBtmBurstTimer
    Public StartBtmBurst As Boolean
    Public BtmBurstDelay
  #EndIf
  Public BurstTimeReached As Float 'holder to see when we're reaching the burst time
  Public BurstReachedMod As Float
  Public BurstComs As String * 10000
  '  Public TestMedBurstTime
  '  Public OldBurstTime
  '  Public NewBurstTime
  Public OldEXOTime As Long
  #If TopBottom Then
    Public BtmOldEXOTime As Long
  #EndIf
  'Exo Parameter Codes from EXO manual. These are used to determine where to put the EXO sensor data.
  Dim DateCode = 52
  Dim TimeCode = 54
  Dim TempCCode = 1
  Dim TempFCode = 2
  Dim CondCode = 7
  Dim TurbFNUCode = 223
  Dim DoSatCode = 211
  Dim DOmgLCode = 212
  Dim DepthFtCode = 23
  Dim DepthMetersCode = 22
  Dim BattCode = 28
  Dim pHCode = 18
  Dim pHmVCode = 17
  Dim ChlugLCode = 193
  Dim ChlRFUCode = 194
  Dim BGApcRFUCode = 216
  Dim BGApcugLCode = 225
  Dim FDomRFU = 227
  Dim FDomQSU = 228
  Dim ORPCode = 19
  Dim NH4Code = 48
  Dim CLCode = 112
  Dim NO3Code = 106
  Dim WiperPos = 229

  #If WqSonde = "WQ_SERIAL_BURST" Then
    Public BurstData(24)
    Dim BurstArray(30,24)
    Public BurstIn As String * 256 'Raw EXO burst data string
    Public jCount As Long 'Counter
    Public kCount As Long 'Counter
    Public BurstCount As Long 'number of burst measurements collected
    '    Public BurstCount_Mid
    Public GotToBurst 'debugging, how many times did we reach the burst function
    Public TotalBurstVals 'how many values are actually used to calculate the burst math functions
    Public BurstErrCnt 'how many times during the burst loop did we miss data
    Public BurstMaxErrCnt = 3 'threshold for how many times we can miss before exiting the burst loop
    Public BurstMissed As Boolean 'flag if we missed the burst due to missing too many values
    Public BurstDebugCount As Long 'Debugging EXO burst!----------------------------------------------
    Public BurstDate
    Public BurstTime
    Public BurstTempC
    Public BurstTempF
    Public BurstSpCond
    Public BurstTurbFNU
    Public BurstDOSat
    Public BurstDOmgL
    Public BurstORP
    Public BurstDepthFt
    Public BurstDepthMeters
    Public BurstBattV
    Public BurstpH
    Public BurstpHmV
    Public BurstChlugL
    Public BurstChlRFU
    Public BurstBGApcRFU
    Public BurstBGApcugL
    Public BurstFdomRFU
    Public BurstFDomQSU
    Public BurstNH4Amgl
    Public BurstNO3Nmgl
    Public BurstCLmgl
    Public BurstWiperPos
    #If TopBottom Then
      Public BtmBurstData(24)
      Dim BtmBurstArray(30,24)
      Public BtmBurstIn As String * 256 'Raw EXO burst data string
      Public BtmjCount As Long 'Counter
      Public BtmkCount As Long 'Counter
      Public BtmBurstCount As Long 'number of burst measurements collected
      '    Public BurstCount_Mid
      Public BtmTotalBurstVals 'how many values are actually used to calculate the burst math functions
      Public BtmBurstErrCnt 'how many times during the burst loop did we miss data
      Public BtmBurstMaxErrCnt = 3 'threshold for how many times we can miss before exiting the burst loop
      Public BtmBurstMissed As Boolean 'flag if we missed the burst due to missing too many values
      Public BtmBurstDebugCount As Long 'Debugging EXO burst!----------------------------------------------
      Public BtmBurstDate
      Public BtmBurstTime
      Public BtmBurstTempC
      Public BtmBurstTempF
      Public BtmBurstSpCond
      Public BtmBurstTurbFNU
      Public BtmBurstDOSat
      Public BtmBurstDOmgL
      Public BtmBurstORP
      Public BtmBurstDepthFt
      Public BtmBurstDepthMeters
      Public BtmBurstBattV
      Public BtmBurstpH
      Public BtmBurstpHmV
      Public BtmBurstChlugL
      Public BtmBurstChlRFU
      Public BtmBurstBGApcRFU
      Public BtmBurstBGApcugL
      Public BtmBurstFdomRFU
      Public BtmBurstFDomQSU
      Public BtmBurstNH4Amgl
      Public BtmBurstNO3Nmgl
      Public BtmBurstCLmgl
      Public BtmBurstWiperPos
    #EndIf
    '____________________________Median variables to be pulled from Burst table and stored to output in AQ Table_____________
    Public MedBurstDate
    Public MedBurstTime
    Public MedTempC
    Public MedTempF
    Public MedSpCond
    Public MedTurbFNU
    Public MedDOSat
    Public MedDOmgL
    Public MedORP
    Public MedDepthFt
    Public MedDepthMeters
    Public MedBattV
    Public MedpH
    Public MedpHmV
    Public MedChlugL
    Public MedChlRFU
    Public MedBGApcRFU
    Public MedBGApcugL
    Public MedFdomRFU
    Public MedFDomQSU
    Public MedNH4Amgl
    Public MedNO3Nmgl
    Public MedCLmgl
    Public MedWiperPos
    #If TopBottom Then
      Public BtmMedBurstDate
      Public BtmMedBurstTime
      Public BtmMedTempC
      Public BtmMedTempF
      Public BtmMedSpCond
      Public BtmMedTurbFNU
      Public BtmMedDOSat
      Public BtmMedDOmgL
      Public BtmMedORP
      Public BtmMedDepthFt
      Public BtmMedDepthMeters
      Public BtmMedBattV
      Public BtmMedpH
      Public BtmMedpHmV
      Public BtmMedChlugL
      Public BtmMedChlRFU
      Public BtmMedBGApcRFU
      Public BtmMedBGApcugL
      Public BtmMedFdomRFU
      Public BtmMedFDomQSU
      Public BtmMedNH4Amgl
      Public BtmMedNO3Nmgl
      Public BtmMedCLmgl
      Public BtmMedWiperPos
    #EndIf
  #EndIf 'EXO data that's been parsed
  #If SeeRawWQ = True OR Debugging = True Then
    Public t(24)
    Public WqData(24)
    Public WqIn As String * 256 'Raw EXO data string
    Public WqDelay As Long 'Used as place holder for timer to know how long the wiper is wiping
    Public RecBurstFlag As Boolean
    #If TopBottom Then
      Public BTM_t(24)
      Public BtmWqData(24)
      Public BtmWqIn As String * 256
      Public BtmWqDelay
    #EndIf
  #Else
    Dim t(24)
    Dim WqData(24)
    Dim WqIn As String * 256 'Raw EXO data string
    Dim WqDelay As Long 'Used as place holder for timer to know how long the wiper is wiping
    Dim RecBurstFlag As Boolean
    #If TopBottom Then
      Dim BTM_t(24)
      Dim BtmWqData(24)
      Dim BtmWqIn As String * 256
      Dim BtmWqDelay
    #EndIf
    'Public RecAquariusFlag As Boolean
    'Dim ExoBaud 'Variable to use in the "SerialOpen" instruction for the EXO
  #EndIf
  'Dim TempLong As Long 'Placerholder for timer
  Public WipeTime As String * 25 'Time/Date that the wiper finishes its wipe
  Public WqParamOrder(24) 'Array that holds the Wq Codes to help determine what order the data are coming in.
  Public WqLocDate
  Public WqLocTime
  Public WqLocTempC
  Public WqLocTempF
  Public WqLocCond
  Public WqLocTurbFNU
  Public WqLocDoSat
  Public WqLocDOmgL
  Public WqLocORP
  Public WqLocDepthFt
  Public WqLocDepthMeters
  Public WqLocBatt
  Public WqLocpH
  Public WqLocpHmV
  Public WqLocChlugL
  Public WqLocChlRFU
  Public WqLocBGApcRFU
  Public WqLocBGApcugL
  Public WqLocFDomRFU
  Public WqLocFDomQSU
  Public WqLocNH4
  Public WqLocNO3
  Public WqLocCL
  Public WqLocWiperPos
  Public Wipeflag As Boolean
  'Exo Error variables
  '  Public ExoError As Boolean
  '  Public ExoDead As Boolean
  '  Public ExoErrorCnt
  #If TopBottom Then
    Public BtmWipeTime As String * 25 'Time/Date that the wiper finishes its wipe
    Public BtmWqParamOrder(24) 'Array that holds the Wq Codes to help determine what order the data are coming in.
    Public BtmWqLocDate
    Public BtmWqLocTime
    Public BtmWqLocTempC
    Public BtmWqLocTempF
    Public BtmWqLocCond
    Public BtmWqLocTurbFNU
    Public BtmWqLocDoSat
    Public BtmWqLocDOmgL
    Public BtmWqLocORP
    Public BtmWqLocDepthFt
    Public BtmWqLocDepthMeters
    Public BtmWqLocBatt
    Public BtmWqLocpH
    Public BtmWqLocpHmV
    Public BtmWqLocChlugL
    Public BtmWqLocChlRFU
    Public BtmWqLocBGApcRFU
    Public BtmWqLocBGApcugL
    Public BtmWqLocFDomRFU
    Public BtmWqLocFDomQSU
    Public BtmWqLocNH4
    Public BtmWqLocNO3
    Public BtmWqLocCL
    Public BtmWqLocWiperPos
    Public BtmWipeflag As Boolean
  #EndIf
  'Declare Variables for SDI12 Sonde
  'Data from YSIsond comes into the wqSDI12Sensor array (in a certain order, based on YSI settings),
  'user selects which order they come in using these variables. Datalogger puts values in correct location
  #If WqSonde = "WQ_SDI12" Then
    Public WqSDI12Sensor(23)
    Public Wiper1Min As Float
    Public WiperTestCount As Float
    Public WiperInCount As Float
    'Public LocDate As Long 'may be used in the future
    'Public LocTime As Long 'may be used in the future
    Public LocTempC As Long
    Public LocSpCond As Long
    Public LocTurbFNU As Long
    Public LocVolts As Long
    Public LocDOmgL As Long
    Public LocDOSat As Long
    Public LocPH As Long
    Public LocORP As Float
    Public LocDepth As Long
    Public LocChlorMGL As Long
    Public LocChlorRFU As Long
    Public LocBGA As Float
    Public LocFdomRFU As Float
    Public LocFdomQSU As Float
    Public LocAmmonium As Float
    Public LocNitrate As Float
    Public LocChloride As Float
    Public LocWiperPos As Float
    Public WqAddr As Long 'SDI12 address of the YSI
    Public WqSDIPort As Long 'Port YSI is plugged into (C3 or 5 for CR1000, U3 or 5 for CR6)
    Public WiperErrCount As Float
    Public WiperOut As Boolean
    'Dim WqSdiErr As Boolean 'indicator for data not coming in
    Public MilliToMicro As Boolean 'does the Specific Conductance need a multiplier to make the value millisiemens to microsiemens?
  #EndIf

  'Declare universal variables for the sondes, only populate variables if a sonde is present
  #If (WqSonde <> "NONE") Then
    'Public WqSerPort As String
    'Public WqAddr As String
    Public TempDiff As Float
    Public WqError As Boolean
    Public WqDead As Boolean
    'Public WqDeadCnt As Long
    Public WqBadData As Boolean
    Public WqDate As String
    Public WqTime As String
    'Public WqNparams As Long
    Public WqTempC As Float
    Public WqTempF As Float
    Public WqSpCond As Float
    Public WqTurbFNU As Float
    Public WqChlugL As Float
    Public WqChlRFU As Float
    Public WqDOMgl As Float
    Public WqDOSat As Float
    Public WqPH As Float
    Public WqPHmv As Float
    Public WqORP As Float
    Public WqDepthFt As Float
    Public WqDepthMeters As Float
    Public WqBattV As Float
    Public WqBGAugl As Float
    Public WqBGArfu As Float
    Public WqFDOMrfu As Float
    Public WqFDOMqsu As Float
    Public WqNH4mgl As Float
    Public WqNO3mgl As Float
    Public WqCLmgl As Float
    Public WqWiperPos As Float
    Public WqErrCount As Long
    Public WqPwrCycleCnt As Long
    Public WqManualCycle As Boolean
    #If TopBottom Then
      Public BtmWqError As Boolean
      Public BtmWqDead As Boolean
      'Public WqDeadCnt As Long
      Public BtmWqBadData As Boolean
      Public BtmWqDate As String
      Public BtmWqTime As String
      'Public WqNparams As Long
      Public BtmWqTempC As Float
      Public BtmWqTempF As Float
      Public BtmWqSpCond As Float
      Public BtmWqTurbFNU As Float
      Public BtmWqChlugL As Float
      Public BtmWqChlRFU As Float
      Public BtmWqDOMgl As Float
      Public BtmWqDOSat As Float
      Public BtmWqPH As Float
      Public BtmWqPHmv As Float
      Public BtmWqORP As Float
      Public BtmWqDepthFt As Float
      Public BtmWqDepthMeters As Float
      Public BtmWqBattV As Float
      Public BtmWqBGAugl As Float
      Public BtmWqBGArfu As Float
      Public BtmWqFDOMrfu As Float
      Public BtmWqFDOMqsu As Float
      Public BtmWqNH4mgl As Float
      Public BtmWqNO3mgl As Float
      Public BtmWqCLmgl As Float
      Public BtmWqWiperPos As Float
      Public BtmWqErrCount As Long
      Public BtmWqPwrCycleCnt As Long
      '  Public BtmWqManualCycle As Boolean
    #EndIf
  #EndIf
#EndIf
Public IsWQNClosed As Boolean 'Keep this outside conditional compile until we take time to actually fix it. Works like this though.
'variables for aquarius table
Public AvgIndexVel As Float
Public AvgVMTemp As Float
Public AvgVMPitch As Float
Public AvgVMRoll As Float
Public AvgPS1Stg As Float
Public AvgPS2Stg As Float
Public AvgUpBeamStg As Float
'Public AvgLoggerQcfs As Float
'Public AvgLoggerMeanVel As Float  Maybe bring this into Aquarius for internal use if we deem it necessary?
'Public AvgStagePrime As Float
'Public AvgStageSec As Float

'Public WqSondeDead As Boolean 'indicator that the YSI is flatlined or out
'Public WqSondeDeadCnt As Long 'how long has it been flatlined or out?
'Public WqErrCount As Long
'Public WqError As Boolean


'Declare variables for velocity meter data
Public VMtempF As Float
Public VMupBeam As Float
Public VMpressure As Float
Public WHpressure As Float
Public VMHeading As Float
Public VMpitch As Float
Public VMroll As Float
Public VMVolts As Float
Public VMtempC As Float
Public VMdataIn As Boolean
'------------------------String used to send specific data through serial communications to another logger-------------------
'Public OutString As String * 1000 'string of variables/values to be sent out to another datalogger
Public SendFlowData As Boolean 'user selectable flag to send only flow data


'-------------------------------------------------------DEBUGGIMG!!!!!-------------------------------------------------
#If Debugging = True Then
  Public DepthMSB As Long 'debugging variables
  Public DepthMSB1 As Long'debugging variables
  Public DepthLSB As Long'debugging variables
  Public DepthLSB1 As Long'debugging variables
  Public IDwords(14) As Long
  Public LSBTemp As Long
  Public LSB1Temp As Long
  Public MSBTemp As Long
  Public MSB1Temp As Long
  Public Subscans As Long
  Public EnsBytes As Long
  Public MissedEns As Long
  Public ADCPLoop As Long
  Public ADCPDone As Boolean
  Public ScanDiff As Long
  Public ScanStart
  Public ScanEnd
  Public ADCPEnd
  Public BeforeBurst
  Public AfterBurst
  Public CDMACheckStart
  Public CDMACheckEnd
  Public CDMACheckTotTime
  Public ZeroVMTimeStart
  Public ZeroVMTimeEnd
  Public ZeroVMTotTime
  Public ChkSumChkStart
  Public ChkSumChkEnd
  Public ChkSumChkTotTime
  Public MainDecodeStart
  Public MainDecodeEnd
  Public MainDecodeTotTime
  Public CalcRangeStart
  Public CalcRangeEnd
  Public CalcRangeTotTime
  Public OneMinCalcStart
  Public OneMinCalcEnd
  Public OneMinCalcTotTime
  Public CalcQStart
  Public CalcQEnd
  Public CalcQTotTime
  Public GetVMMemStart
  Public GetVMMemEnd
  Public GetVMMemTotTime
  Public VMTimeStart
  Public VMTimeEnd
  Public VMTotTime
  Public CallBmChkStart
  Public CallBmChkEnd
  Public CallBmChkTotTime
  Public DataTabsStart
  Public DataTabsEnd
  Public DataTabsTotTime
  Public DataOutStart
  Public DataOutEnd
  Public DataOutTotTime
  Public Data1mStart
  Public Data1mEnd
  Public Data1mTotTime
  Public AQTabStart
  Public AQTabEnd
  Public AQTabTotTime
  Public StoreToCrdStart
  Public StoreToCrdEnd
  Public StoreToCrdTotTime
  Public ChkSpikeStart
  Public ChkSpikeEnd
  Public ChkSpikeTotTime
  Public AddSpikeStart
  Public AddSpikeEnd
  Public AddSpikeTotTime
  Public ProcessTime
  Public DataOutCount
  Public AQcount
  Public Data1mCount
  Public CardBadCount
  Public CardOkCount
  Dim DebugTimer
#Else
  Dim DepthMSB As Long 'debugging variables
  Dim DepthMSB1 As Long'debugging variables
  Dim DepthLSB As Long'debugging variables
  Dim DepthLSB1 As Long'debugging variables
  Dim IDwords(14) As Long
  Dim LSBTemp As Long
  Dim LSB1Temp As Long
  Dim MSBTemp As Long
  Dim MSB1Temp As Long
  Dim Subscans As Long
  Dim EnsBytes As Long
  Dim MissedEns As Long
  Dim ADCPLoop As Long
  Dim ADCPDone As Boolean
  Dim ScanDiff As Long
  Dim ScanStart
  Dim ScanEnd
  Dim ADCPEnd
  Dim BeforeBurst
  Dim AfterBurst
  Dim CDMACheckStart
  Dim CDMACheckEnd
  Dim CDMACheckTotTime
  Dim ZeroVMTimeStart
  Dim ZeroVMTimeEnd
  Dim ZeroVMTotTime
  Dim ChkSumChkStart
  Dim ChkSumChkEnd
  Dim ChkSumChkTotTime
  Dim MainDecodeStart
  Dim MainDecodeEnd
  Dim MainDecodeTotTime
  Dim CalcRangeStart
  Dim CalcRangeEnd
  Dim CalcRangeTotTime
  Dim OneMinCalcStart
  Dim OneMinCalcEnd
  Dim OneMinCalcTotTime
  Dim CalcQStart
  Dim CalcQEnd
  Dim CalcQTotTime
  Dim GetVMMemStart
  Dim GetVMMemEnd
  Dim GetVMMemTotTime
  Dim VMTimeStart
  Dim VMTimeEnd
  Dim VMTotTime
  Dim CallBmChkStart
  Dim CallBmChkEnd
  Dim CallBmChkTotTime
  Dim DataTabsStart
  Dim DataTabsEnd
  Dim DataTabsTotTime
  Dim DataOutStart
  Dim DataOutEnd
  Dim DataOutTotTime
  Dim Data1mStart
  Dim Data1mEnd
  Dim Data1mTotTime
  Dim AQTabStart
  Dim AQTabEnd
  Dim AQTabTotTime
  Dim StoreToCrdStart
  Dim StoreToCrdEnd
  Dim StoreToCrdTotTime
  Dim ChkSpikeStart
  Dim ChkSpikeEnd
  Dim ChkSpikeTotTime
  Dim AddSpikeStart
  Dim AddSpikeEnd
  Dim AddSpikeTotTime
  Dim ProcessTime
  Dim DataOutCount
  Dim AQcount
  Dim Data1mCount
  Dim CardBadCount
  Dim CardOkCount
  Dim DebugTimer
#EndIf
'---------------------------------------------------------DEBUGGING!---------------------------------------------------------

#If HasVM Then
  #If GetNoiseFloor = Yes Then
    Public NoiseFlrParsed As String * 105 '"RSSI Noise Floor" pasrsed from PT3 Command
    Public FilterString As String * 5 'Holds string that the "InStr" instruction searches for
    Public StartString 'Holds value for where "RSSI" begins in the PT3 command string
    Public NoiseHGainW(4) 'array to hold values for each beam's "High Gain, WideBandwidth" Noise Floor
    Public NoiseLGainW(4) 'Array to hold values for each beam's "Low Gain, WideBandwidth" Noise Floor
    Public NoiseHGainN(4) 'Array to hold values for each beam's "High Gain, Narrow Bandwidth" noise floor
    Public NoiseLGainN(4) 'Array to hold calues for each beam's "Low Gain, Narrow Bandwidth" noise floor
    Public SendPT3 As Boolean
    Public PT3Time As Long
  #EndIf
  '---------VM Diagnostic Variables
  'Public PowerSwitch As Boolean 'does user want to allow power to be cycled on ADCP
  Public Banner As String * 200 'ADCP response from sending a break
  Public Warning As String * 2000 'echo of ADCP response for anything other than a break
  Public VMMemString As String * 200 'response for "get free memory" command
  'Public PT3Full As String * 2000 'Response from PT3 command
  Public CMD As String 'user entered command for the ADCP, ex: make bin size 250cm = "ws250"
  Public CSCmd As String * 10 'echo of CS (deploy command) to ensure ADCP deployed properly
  Public SendCMD As Boolean 'after command is input in "CMD" user must turn this to "true" to actually send the command to ADCP
  Public WakeUpVM As Boolean 'send a break/cycle power to ADCP in case it went to sleep. manual switch
  Public VMRestartAttempts As Long 'how many times has the ADCP tried to restart
  Public VMLowMem As Boolean 'indicator if ADCP internal  memory is below user threshold
  Public VMLowMemCount As Float 'how many times ADCP internal memory is below user threshold
  Public VMMemFree As Float 'how much internal memory does the ADCP have remaining
  Public VMLowMemVal As Float 'user threshold for "low internal memory"
  Public VMNoMem As Boolean 'flag indicating no internal memory remaining
  Public VMNoMemCount As Float 'how many times has the ADCP had no internal memory remaining
  Public RecErased As Boolean 'flag indicating the internal memory was erased
  Public RecEraseString As String * 200 'echo of response from ADCP when internal memory is erased (also acts as indicator to trigger "RecErased" flag)
#EndIf

#If RadioNetwork = True Then
  #If IsMaster = True Then
    ConstTable
      Const NetworkSlaves = 2 'How many nodes are in the system?
    EndConstTable
    #If NetworkSlaves = 1 Then 'Declare how many nodes are in the system with conditional compile
      Public NeighborApb = 3 'PakBus address of Node "A"
      Public NeighborASecCode = "0000" 'Security code of neighbor A (use "0000" if no security code is set)
    #ElseIf NetworkSlaves = 2 Then
      Public NeighborApb = 3
      Public NeighborASecCode = "0000"
      Public NeighborBpb = 4 'PakBus address of Node "B"
      Public NeighborBSecCode = "0000" 'Security code of neighbor B (use "0000" if no security code is set)
    #ElseIf NetworkSlaves = 3 Then
      Public NeighborApb = 3
      Public NeighborASecCode = "0000"
      Public NeighborBpb = 4
      Public NeighborBSecCode = "0000"
      Public NeighborCpb = 5 'PakBus address of Node "C"
      Public NeighborCSecCode = "0000" 'Security code of neighbor C (use "0000" if no security code is set)
    #ElseIf NetworkSlaves = 4 Then
      Public NeighborApb = 3
      Public NeighborASecCode = "0000"
      Public NeighborBpb = 4
      Public NeighborBSecCode = "0000"
      Public NeighborCpb = 5
      Public NeighborCSecCode = "0000"
      Public NeighborDpb = 6 'PakBus address of Node "D"
      Public NeighborDSecCode = "0000" 'Security code of neighbor D (use "0000" if no security code is set)
    #EndIf 'If Master
  #ElseIf IsMaster = False Then 'if it's part of a radio network but not the master datalogger
    Public MasterPB = 2 'PakBus address of master datalogger
    Public MasterSecCode = "0000" 'security code of master datalogger
  #EndIf 'If Slave
#EndIf
' Declare placeholders for all RF451 Settings
#If RadioNetwork = True Then
  Public ReadRadSettings As Boolean 'Trigger to read in radio settings
  Public SetRadSettings As Boolean 'Trigger to reset radio settings
  Public SetRadToDefault As Boolean 'Trigger to Reset radio to factory defaults
  Public RadOn As Long 'Radio Enabled (0= False, 1 = True)
  Public RadOpMode As Long 'Operation mode (Point to Multipoint Master = 2, Point to Multipoint Slave = 3, Point to Multipoint Repeater = 7)
  Public RadFreqKey As Long  'Frequency Key (Min = 0, Max = 14)
  Public RadMaxPacket As Long '(Min = 0, Max = 9)
  Public RadMinPacket As Long '(Min = 0, Max = 9)
  Public RadDataRate As Long '(3 = Normal 115Kbps, 2 = High 153Kbps)
  Public RadTxPwr As Long 'Transmit power, 0=min, 10=max)
  Public RadRetryTO As Long 'Retry timeout, sets delay the radio will wait before dropping the connection to a master or repeater (factory=255 (if 1 in 255 packets is successful, link is maintained, Min = 8, Max = 255)
  Public RadLowPwr As Long 'Sets how many "slots" the transceiver sleeps (min = 2, max = 31)
  Public RadRepeaters As Long 'Are repeaters used in system (0 = no repeaters, 1 = repeaters used)
  Public RadPacketRepeat As Long 'hOw many times is the packet transmitted? (min= 0 (1 transmission), max = 9 (10 transmissions))
  Public RadSlaveRetry As Long 'How many times should the slave retrasmit a packet to master? (min = 0, max =9)
  Public RadFreqRepeat As Long '0 = Use Master Freq Key, 1= Use Repeater Freq Key
  Public RadSlaveRepeat As Long '0 = Normal, 1 = Enable Slave/Repeater
  Public RadRxSubID As Long 'Min = 0, Max = 15
  Public RadTxSubID As Long 'Min = 0, Max = 15
  Public RadNetID As Long 'Network ID, Min= 0, Max = 4095

  #If IsMaster = False Then 'If Not master then define Reset Slave
    Public ResetSlave As Boolean 'Set to true (automatically or manually) to reset the slave radio
  #EndIf

  Public ResetTried As Boolean 'indicates whether a reset of the radio was attempted
  Public NextTryCnt As Float 'counter to see how long it's been since last reset
  Public MaxNextTryCnt = 10 'user threshold for how long to wait between reset attempts
  Public ResetTryOK As Boolean 'flag to tell logger enough time passed to try a reset again. Set to True on Compile, then to false once a reset has been tried
  Public RadResetAttempts As Float 'how many times has the radio attempted a reset?

  Const MaxLinksDeadCnt = 10 'max number of times all links can be dead before a reset is attempted.
#EndIf 'If Radio Network
'Declare variables based on if the logger is in a radio network and whether it's the master in the network or not.
#If IsMaster = True AND RadioNetwork = True Then
  #If NetworkSlaves > 0 Then
    Public AllLinksDead As Float 'counter to record how many times all links have been dead
    Public SendToNetwork As Float 'Placeholder variable to send to the network, used to get response from loggers whether communication is successful or not
    Public ResetMaster As Boolean
    #If NetworkSlaves = 1 Then 'if there is only one node in the network (Simple Master/Slave communication, 2 dataloggers in network, 1 master, 1 slave)
      Public SendToAresult As Float 'Result of whether the SendVariable worked or not (cue for if comms were successful)
      Public SendToAFailCnt As Float 'count for how many times the comms have failed
      Public MaxAFails = 5 'max number of times comms can fail before resetting itself
      Public LinkToAdead As Boolean 'is the link to SlaveX considered dead (counter exceeds threshold)
    #ElseIf NetworkSlaves = 2 Then 'if there are two nodes in the network (both communicating directly through master, 3 dataloggers in network, 1 master, 2 slaves)
      Public SendToAresult As Float
      Public SendToAFailCnt As Float
      Public MaxAFails = 5
      Public LinkToAdead As Boolean
      Public SendToBresult As Float
      Public SendToBFailCnt As Float
      Public MaxBFails = 5
      Public LinkToBdead As Boolean
    #ElseIf NetworkSlaves = 3 Then 'if there are three nodes in the network (all three communicating directly through master, 4 dataloggers in network, 1 master, 3 slaves)
      Public SendToAresult As Float
      Public SendToAFailCnt As Float
      Public MaxAFails = 5
      Public LinkToAdead As Boolean
      Public SendToBresult As Float
      Public SendToBFailCnt As Float
      Public MaxBFails = 5
      Public LinkToBdead As Boolean
      Public SendToCresult As Float
      Public SendToCFailCnt As Float
      Public MaxCFails = 5
      Public LinkToCdead As Boolean
    #ElseIf NetworkSlaves = 4 Then 'if there are four nodes in the network (all four communicating directly through master 5 dataloggers in network, 1 master, 4 slaves)
      Public SendToAresult As Float
      Public SendToAFailCnt As Float
      Public MaxAFails = 5
      Public LinkToAdead As Boolean
      Public SendToBresult As Float
      Public SendToBFailCnt As Float
      Public MaxBFails = 5
      Public LinkToBdead As Boolean
      Public SendToCresult As Float
      Public SendToCFailCnt As Float
      Public MaxCFails = 5
      Public LinkToCdead As Boolean
      Public SendToDresult As Float
      Public SendToDFailCnt As Float
      Public MaxDFails = 5
      Public LinkToDdead As Boolean
    #EndIf
    ' #EndIf
  #ElseIf IsMaster = False AND RadioNetwork = True Then 'if the datalogger is in the network, but not the master
    Public MasterReceive As Float 'Variable to store value from the master datalogger
    Public GetResult As Float 'was the communication successful (0 = successful)
    Public GetFailCnt As Float 'counter for how many times communications have failed
    Public MaxGetFails = 5 'threshold for how many times comms can fail before resetting the radio
    Public LinkDead As Boolean 'flag to indicate the link is considered dead (counter exceeded threshold)
  #EndIf
#EndIf

#If HasSuna Then
  Public SampleSuna As Boolean 'Trigger to say when it's time to sample/turn on the SUNA
  Public SunaReady As Boolean 'Trigger to say when the SUNA is warmed up
  Public SunaMissedCnt 'Counter for when the SUNA missed (Either DarkFrame, or no data)
  Public SunaMissed As Boolean 'Trigger to Exit DoLoop if the we missed SUNA data
  Public SunaOnTime 'How long was the SUNA powered
  Public SunaSampleStart 'How long into the scan did the Suna Sampling Start
  Public SunaStringLen 'Length of the String read in
  Public LocLF 'Variable to store where the L occurs in the string
  Public LFrame As Boolean 'Used to trigger the Exit out of the DoLoop so we only get Light Frames
  Public Lcount As Long 'Counter for the ForNext loop to read in the SUNA data
  Public SunaHeader As String * 7
  Public SunaSN 'Suna Parameters
  Public SunaSampleTime
  Public SunaNitrateuM
  Public SunaNitratemgL
  Public SunaFittingResult
  Public A254
  Public TLamp
  Public TSpec
  Public SunaLampTime
  Public SunaHumid
  Public SunaSpecAve
  Public SunaDarkAve
  Public SunaVoltMain
  Public SunaVoltLamp
  Public SunaTimer 'Timer Name for specifying when to power the SUNA and Wiper
  Public WipeSuna As Boolean 'Is it time to wipe?
  Public RecSunaData As Boolean 'Flag to Trigger the SunaStats table
  Public AvgSunaNitrateuM 'Variables to copy from SunaStats to variables, then "Sample" the stats in AQ table
  Public  MedSunaNitrateuM
  Public  StdSunaNitrateuM
  Public AvgSunaNitratemgL
  Public  MedSunaNitratemgL
  Public  AvgSunaFittingResult
  Public  StdSunaFittingResult
  Public  AvgA254
  Public  AvgSunaDarkAve
  Public  AvgSunaSpecAve
  Public  AvgTSpec
  Public  AvgTLamp
  Public  AvgSunaHumid
  Public  AvgSunaLampTime
  Public  AvgSunaVoltMain
  Public  AvgSunaVoltLamp
  Dim SSN 'Location definitions used to parse data to correct locations
  Dim SST
  Dim SNuM
  Dim SNmgL
  Dim SFR
  Dim STL
  Dim STS
  Dim SLT
  Dim SH
  Dim SSA
  Dim SDA
  Dim SVL
  Dim SVM
  Dim SA254
  Dim SunaBurstIn As String * 2000 'String to read the data in from the Suna
  Dim SunaBurstArray(MaxSunaBurst,282) 'Multi-dimension array to store the MaxSunaBurst number of values
  Dim SunaBurstData(282) 'Parsed data per single sample
  Dim SpectrumData(256) 'Raw Spectrum data parsed from full array
  Dim mCount 'counters for loops
  Dim nCount
  Dim oCount
  Dim SunaSampleTimer 'Timer names to know when Suna is ready or wipes
  Dim SunaWipeTimer
  Dim WipeStart 'Start time (within the minute) of the wipe
  Dim StartWipe As Boolean 'Trigger to start the wipe
  Dim WipeEnd 'End time of the wipe (when the port gets switched off)
  Dim SunaWipeTotTime 'Total time it took for port to turn on/off
  Dim SunaProcessStart 'Start time of tables being written (within the minute, not Actual timestamp
  Dim SunaProcessEnd 'End time of tables being written
  Dim SunaProcessTotTime 'Total time for tables to be written
#EndIf


PreserveVariables 'preserve values in case of power outages
SetStatus ("USRDriveSize",16384)
'__________________________Define Output Tables___________________________________________
'table for startup, holds only "true" OR "false"
'DataTable (Startup,True,2)
'  Sample (1,StartPrams,String)
'EndTable

'15 MINUTE DATA OUTPUT TABLE
'data output table has no DataInterval instruction
'execution of table is controlled completely by main code logic below.
#If (WqSonde <> "NONE") Then
  DataTable (DataOut,Rec15minFlag,-1)'records data only when Record Flag = yes
    OpenInterval 'tells table to process from last execution of table
    CardOut (0,17280) 'sends copy of data to CF card
    Sample (1,SiteID,String)
    Sample (1,SiteNum,String)
    Sample (1,IndexVel,IEEE4)
    Average (1,IndexVel,IEEE4,BadVelFlag)
    Average (1,MeanVel,IEEE4,BadQFlag)
    Average (1,Qcfs,IEEE4,BadQFlag)
    Sample (1,StagePrime,IEEE4)
    Average (1,StagePrime,IEEE4,BadStgFlag)
    Sample (1,StageSecnd,FP2)
    Average (1,StageSecnd,IEEE4,false)
    Average (1,PS1Stg,IEEE4,false)
    Average (1,PS2Stg,IEEE4,false)
    Average (1,UpBeamStg,IEEE4,false)
    Average (1,VMPressStg,IEEE4,false)
    Average (1,SondeStg,IEEE4,false)
    Average (1,StgDiff,IEEE4,False)
    Sample (1,StgSelect,String)
    Average (1,VMpitch,FP2,False)
    Average (1,VMroll,FP2,False)
    Sample (1,VMHeading,FP2)
    Average (1,VMtempC,FP2,False)
    Minimum (1,CR1Volts,FP2,False,False)
    Minimum (1,VMVolts,FP2,False,False)
    Sample (1,BadStgCount,FP2)
    Sample (1,BadVelCount,FP2)
    Sample (1,BadQCount,FP2)
    Average(1,AvgSwathRSSI,FP2,False)
    Sample (1,LowRatVel,FP2)
    Sample (1,HighRatVel,FP2)
    Minimum (1,ExtWHConvertVolt,FP2,False,False)
    Minimum (1,ExtSolarVolt,FP2,False,False)
    Average (1,RangedBin,FP2,False)
    Average (MaxBins,VMBinVel(),IEEE4,VmBinVelDisable())
    Average(MaxBins,V1(),FP2,V1Disable())
    Average(MaxBins,V2(),FP2,V2Disable())
    Average(MaxBins,V3(),FP2,V3Disable())
    Average(MaxBins,V4(),FP2,V4disable())
    'WQ data
    Average (1,TempDiff,IEEE4,False)
    Sample (1,WqTempC,FP2)
    Sample (1,WqSpCond,IEEE4)
    Sample (1,WqBattV,FP2)
    Sample (1,WqDOMgl,FP2)
    Sample (1,WqPH,FP2)
    Sample (1,WqTurbFNU,FP2)
    Average (1,WqTurbFNU,FP2,WqBadData)
    Median (1,WqTurbFNU,15,FP2,WqBadData)
    Sample (1,WqChlugL,FP2)
    Sample (1,WqChlRFU,FP2)
    Average (1,WqDepthFt,FP2,WqBadData)
    Average (1,WqDepthMeters,FP2,WqBadData)
    Sample (1,WqDOSat,FP2)
    Sample (1,WqORP,FP2)
    Sample (1,WqFDOMrfu,FP2)
    Sample (1,WqFDOMqsu,FP2)
    Sample (1,WqBGAugl,FP2)
    Sample (1,WqNH4mgl,FP2)
    Sample (1,WqNO3mgl,FP2)
    Sample (1,WqCLmgl,FP2)
    Sample (1,WqWiperPos,FP2)
    #If TopBottom Then
      Sample (1,BtmWqTempC,FP2)
      Sample (1,BtmWqSpCond,IEEE4)
      Sample (1,BtmWqBattV,FP2)
      Sample (1,BtmWqDOMgl,FP2)
      Sample (1,BtmWqPH,FP2)
      Sample (1,BtmWqTurbFNU,FP2)
      Average (1,BtmWqTurbFNU,FP2,BtmWqBadData)
      Median (1,BtmWqTurbFNU,15,FP2,BtmWqBadData)
      Sample (1,BtmWqChlugL,FP2)
      Sample (1,BtmWqChlRFU,FP2)
      Average (1,BtmWqDepthFt,FP2,BtmWqBadData)
      Average (1,BtmWqDepthMeters,FP2,BtmWqBadData)
      Sample (1,BtmWqDOSat,FP2)
      Sample (1,BtmWqORP,FP2)
      Sample (1,BtmWqFDOMrfu,FP2)
      Sample (1,BtmWqFDOMqsu,FP2)
      Sample (1,BtmWqBGAugl,FP2)
      Sample (1,BtmWqNH4mgl,FP2)
      Sample (1,BtmWqNO3mgl,FP2)
      Sample (1,BtmWqCLmgl,FP2)
      Sample (1,BtmWqWiperPos,FP2)
    #EndIf
  EndTable
#EndIf

#If (WqSonde = "NONE") Then 'Don't store non-existent WQ data in the DataOutTable
  DataTable (DataOut,Rec15minFlag,-1)'records data only when Record Flag = yes
    OpenInterval 'tells table to process from last execution of table
    CardOut (0,17280) 'sends copy of data to CF card
    Sample (1,SiteID,String)
    Sample (1,SiteNum,String)
    Sample (1,IndexVel,IEEE4)
    Average (1,IndexVel,IEEE4,BadVelFlag)
    Average (1,MeanVel,IEEE4,BadQFlag)
    Average (1,Qcfs,IEEE4,BadQFlag)
    Sample (1,StagePrime,IEEE4)
    Average (1,StagePrime,IEEE4,BadStgFlag)
    Sample (1,StageSecnd,FP2)
    Average (1,StageSecnd,IEEE4,false)
    Average (1,PS1Stg,IEEE4,false)
    Average (1,PS2Stg,IEEE4,false)
    Average (1,UpBeamStg,IEEE4,false)
    Average (1,VMPressStg,IEEE4,false)
    Average (1,SondeStg,IEEE4,false)
    Average (1,StgDiff,IEEE4,False)
    Sample (1,StgSelect,String)
    Average (1,VMpitch,FP2,False)
    Average (1,VMroll,FP2,False)
    Average (1,VMtempC,FP2,False)
    Sample (1,VMHeading,FP2)
    Minimum (1,CR1Volts,FP2,False,False)
    Minimum (1,VMVolts,FP2,False,False)
    Sample (1,BadStgCount,FP2)
    Sample (1,BadVelCount,FP2)
    Sample (1,BadQCount,FP2)
    'Maximum (1,LastGoodBin,FP2,False,False)
    Sample (1,LowRatVel,FP2)
    Sample (1,HighRatVel,FP2)
    Minimum (1,ExtWHConvertVolt,FP2,False,False)
    Minimum (1,ExtSolarVolt,FP2,False,False)
    Average (MaxBins,VMBinVel(),IEEE4,VmBinVelDisable())
    Average(MaxBins,V1(),FP2,V1Disable())
    Average(MaxBins,V2(),FP2,V2Disable())
    Average(MaxBins,V3(),FP2,V3Disable())
    Average(MaxBins,V4(),FP2,V4disable())
    Average(1,AvgSwathRSSI,FP2,False)
  EndTable
#EndIf
'Data table that is only used for obtaining an EXO burst (1 minute burst of one second dat, once every 15 minutes
#If WqSonde = "WQ_SERIAL_BURST" Then
  DataTable(Burst,RecBurstFlag,-1)
    'DataInterval(0,1,Min,-1)
    CardOut (0,17280)
    OpenInterval
    Sample (1,SiteID,String)
    Sample (1,SiteNum,String)
    Sample (1,BurstDate,IEEE4)
    Sample (1,BurstTime,IEEE4)
    Sample (1, BurstPeriod, IEEE4)
    '    Sample (1,BurstMedDate,IEEE4)
    '    Sample (1,BurstMedTime,IEEE4)
    Median (1,BurstDate,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstTime,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstTempC,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstTempF,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstSpCond,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstTurbFNU,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstDOSat, MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstDOmgL,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstORP,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstDepthFt,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstDepthMeters,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstBattV,MaxBurstCnt,FP2,BurstMissed)
    Median (1,BurstpH,MaxBurstCnt,FP2,BurstMissed)
    Median (1,BurstpHmV,MaxBurstCnt,FP2,BurstMissed)
    Median (1,BurstChlugL,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstChlRFU,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstBGApcRFU,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstBGApcugL,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstFdomRFU,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstFDomQSU,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstNH4Amgl,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstNO3Nmgl,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstCLmgl,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstWiperPos,MaxBurstCnt,FP2,BurstMissed)
    StdDev (1,BurstTempC,IEEE4,False)
    Minimum (1,BurstTempC,IEEE4,False,0)
    Maximum (1,BurstTempC,IEEE4,False,0)
    StdDev (1,BurstSpCond,IEEE4,False)
    Minimum (1,BurstSpCond,IEEE4,False,0)
    Maximum (1,BurstSpCond,IEEE4,False,0)
    StdDev (1,BurstTurbFNU,IEEE4,False)
    Minimum (1,BurstTurbFNU,IEEE4,False,0)
    Maximum (1,BurstTurbFNU,IEEE4,False,0)
    StdDev (1,BurstDOSat,IEEE4,False)
    Minimum (1,BurstDOSat,IEEE4,False,0)
    Maximum (1,BurstDOSat,IEEE4,False,0)
    StdDev (1,BurstDOmgL,IEEE4,False)
    Minimum (1,BurstDOmgL,IEEE4,False,0)
    Maximum (1,BurstDOmgL,IEEE4,False,0)
    StdDev (1,BurstORP,IEEE4,False)
    Minimum (1,BurstORP,IEEE4,False,0)
    Maximum (1,BurstORP,IEEE4,False,0)
    StdDev (1,BurstDepthFt,IEEE4,False)
    Minimum (1,BurstDepthFt,IEEE4,False,0)
    Maximum (1,BurstDepthFt,IEEE4,False,0)
    StdDev (1,BurstDepthMeters,IEEE4,False)
    Minimum (1,BurstDepthMeters,IEEE4,False,0)
    Maximum (1,BurstDepthMeters,IEEE4,False,0)
    StdDev (1,BurstBattV,FP2,False)
    Minimum (1,BurstBattV,FP2,False,0)
    Maximum (1,BurstBattV,FP2,False,0)
    StdDev (1,BurstpH,FP2,False)
    Minimum (1,BurstpH,FP2,False,0)
    Maximum (1,BurstpH,FP2,False,0)
    StdDev (1,BurstpHmV,FP2,False)
    Minimum (1,BurstpHmV,FP2,False,0)
    Maximum (1,BurstpHmV,FP2,False,0)
    StdDev (1,BurstChlugL,IEEE4,False)
    Minimum (1,BurstChlugL,IEEE4,False,0)
    Maximum (1,BurstChlugL,IEEE4,False,0)
    StdDev (1,BurstChlRFU,IEEE4,False)
    Minimum (1,BurstChlRFU,IEEE4,False,0)
    Maximum (1,BurstChlRFU,IEEE4,False,0)
    StdDev (1,BurstBGApcRFU,IEEE4,False)
    Minimum (1,BurstBGApcRFU,IEEE4,False,0)
    Maximum (1,BurstBGApcRFU,IEEE4,False,0)
    StdDev (1,BurstBGApcugL,IEEE4,False)
    Minimum (1,BurstBGApcugL,IEEE4,False,0)
    Maximum (1,BurstBGApcugL,IEEE4,False,0)
    StdDev (1,BurstFdomRFU,IEEE4,False)
    Minimum (1,BurstFdomRFU,IEEE4,False,0)
    Maximum (1,BurstFdomRFU,IEEE4,False,0)
    StdDev (1,BurstFDomQSU,IEEE4,False)
    Minimum (1,BurstFDomQSU,IEEE4,False,0)
    Maximum (1,BurstFDomQSU,IEEE4,False,0)
    StdDev (1,BurstNH4Amgl,IEEE4,False)
    Minimum (1,BurstNH4Amgl,IEEE4,False,0)
    Maximum (1,BurstNH4Amgl,IEEE4,False,0)
    StdDev (1,BurstNO3Nmgl,IEEE4,False)
    Minimum (1,BurstNO3Nmgl,IEEE4,False,0)
    Maximum (1,BurstNO3Nmgl,IEEE4,False,0)
    StdDev (1,BurstCLmgl,IEEE4,False)
    Minimum (1,BurstCLmgl,IEEE4,False,0)
    Maximum (1,BurstCLmgl,IEEE4,False,0)
    StdDev (1,BurstWiperPos,FP2,False)
    Minimum (1,BurstWiperPos,FP2,False,0)
    Maximum (1,BurstWiperPos,FP2,False,0)
    Sample (1,TotalBurstVals,FP2)
    Sample (1,BurstMissed,Boolean)
    Sample (1,BurstErrCnt,FP2)
  EndTable

  '__________________________________________Metadata for each burst sample_____________________________________
  '_____________________collect each 1 second value that is being used to calculate "Burst" table values________________
  DataTable(SecBurst,True,-1)
    'DataInterval(0,1,Min,-1)
    CardOut (0,350000)
    OpenInterval
    Sample (1,SiteID,String)
    Sample (1,SiteNum,String)
    Sample (1,BurstDate,IEEE4)
    Sample (1,BurstTime,IEEE4)
    Sample (1,BurstTempC,IEEE4)
    Sample (1,BurstTempF,IEEE4)
    Sample (1,BurstSpCond,IEEE4)
    Sample (1,BurstTurbFNU,IEEE4)
    Sample (1,BurstDOSat,IEEE4)
    Sample (1,BurstDOmgL,IEEE4)
    Sample (1,BurstORP,IEEE4)
    Sample (1,BurstDepthFt,IEEE4)
    Sample (1,BurstDepthMeters,IEEE4)
    Sample (1,BurstBattV,FP2)
    Sample (1,BurstpH,FP2)
    Sample (1,BurstpHmV,FP2)
    Sample (1,BurstChlugL,IEEE4)
    Sample (1,BurstChlRFU,IEEE4)
    Sample (1,BurstBGApcRFU,IEEE4)
    Sample (1,BurstBGApcugL,IEEE4)
    Sample (1,BurstFdomRFU,IEEE4)
    Sample (1,BurstFDomQSU,IEEE4)
    Sample (1,BurstNH4Amgl,IEEE4)
    Sample (1,BurstNO3Nmgl,IEEE4)
    Sample (1,BurstCLmgl,IEEE4)
    Sample (1,BurstWiperPos,FP2)
    Sample (1,TotalBurstVals,FP2)
    Sample (1,jCount,FP2)
    Sample (1,BurstMissed,Boolean)
    Sample (1,BurstErrCnt,FP2)
  EndTable

  '__________________________Bottom Sonde Burst Data Tables_________________________________
  #If TopBottom Then  'remove these tables if there is no bottom sonde
    DataTable(BtmBurst,RecBurstFlag,-1)
      'DataInterval(0,1,Min,-1)
      CardOut (0,17280)
      OpenInterval
      Sample (1,SiteID,String)
      Sample (1,SiteNum,String)
      Sample (1,BtmBurstDate,IEEE4)
      Sample (1,BtmBurstTime,IEEE4)
      Sample (1,BurstPeriod, IEEE4)
      '    Sample (1,BurstMedDate,IEEE4)
      '    Sample (1,BurstMedTime,IEEE4)
      Median (1,BtmBurstDate,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstTime,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstTempC,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstTempF,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstSpCond,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstTurbFNU,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstDOSat, MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstDOmgL,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstORP,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstDepthFt,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstDepthMeters,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstBattV,MaxBurstCnt,FP2,BurstMissed)
      Median (1,BtmBurstpH,MaxBurstCnt,FP2,BurstMissed)
      Median (1,BtmBurstpHmV,MaxBurstCnt,FP2,BurstMissed)
      Median (1,BtmBurstChlugL,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstChlRFU,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstBGApcRFU,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstBGApcugL,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstFdomRFU,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstFDomQSU,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstNH4Amgl,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstNO3Nmgl,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstCLmgl,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstWiperPos,MaxBurstCnt,FP2,BurstMissed)
      StdDev (1,BtmBurstTempC,IEEE4,False)
      Minimum (1,BtmBurstTempC,IEEE4,False,0)
      Maximum (1,BtmBurstTempC,IEEE4,False,0)
      StdDev (1,BtmBurstSpCond,IEEE4,False)
      Minimum (1,BtmBurstSpCond,IEEE4,False,0)
      Maximum (1,BtmBurstSpCond,IEEE4,False,0)
      StdDev (1,BtmBurstTurbFNU,IEEE4,False)
      Minimum (1,BtmBurstTurbFNU,IEEE4,False,0)
      Maximum (1,BtmBurstTurbFNU,IEEE4,False,0)
      StdDev (1,BtmBurstDOSat,IEEE4,False)
      Minimum (1,BtmBurstDOSat,IEEE4,False,0)
      Maximum (1,BtmBurstDOSat,IEEE4,False,0)
      StdDev (1,BtmBurstDOmgL,IEEE4,False)
      Minimum (1,BtmBurstDOmgL,IEEE4,False,0)
      Maximum (1,BtmBurstDOmgL,IEEE4,False,0)
      StdDev (1,BtmBurstORP,IEEE4,False)
      Minimum (1,BtmBurstORP,IEEE4,False,0)
      Maximum (1,BtmBurstORP,IEEE4,False,0)
      StdDev (1,BtmBurstDepthFt,IEEE4,False)
      Minimum (1,BtmBurstDepthFt,IEEE4,False,0)
      Maximum (1,BtmBurstDepthFt,IEEE4,False,0)
      StdDev (1,BtmBurstDepthMeters,IEEE4,False)
      Minimum (1,BtmBurstDepthMeters,IEEE4,False,0)
      Maximum (1,BtmBurstDepthMeters,IEEE4,False,0)
      StdDev (1,BtmBurstBattV,FP2,False)
      Minimum (1,BtmBurstBattV,FP2,False,0)
      Maximum (1,BtmBurstBattV,FP2,False,0)
      StdDev (1,BtmBurstpH,FP2,False)
      Minimum (1,BtmBurstpH,FP2,False,0)
      Maximum (1,BtmBurstpH,FP2,False,0)
      StdDev (1,BtmBurstpHmV,FP2,False)
      Minimum (1,BtmBurstpHmV,FP2,False,0)
      Maximum (1,BtmBurstpHmV,FP2,False,0)
      StdDev (1,BtmBurstChlugL,IEEE4,False)
      Minimum (1,BtmBurstChlugL,IEEE4,False,0)
      Maximum (1,BtmBurstChlugL,IEEE4,False,0)
      StdDev (1,BtmBurstChlRFU,IEEE4,False)
      Minimum (1,BtmBurstChlRFU,IEEE4,False,0)
      Maximum (1,BtmBurstChlRFU,IEEE4,False,0)
      StdDev (1,BtmBurstBGApcRFU,IEEE4,False)
      Minimum (1,BtmBurstBGApcRFU,IEEE4,False,0)
      Maximum (1,BtmBurstBGApcRFU,IEEE4,False,0)
      StdDev (1,BtmBurstBGApcugL,IEEE4,False)
      Minimum (1,BtmBurstBGApcugL,IEEE4,False,0)
      Maximum (1,BtmBurstBGApcugL,IEEE4,False,0)
      StdDev (1,BtmBurstFdomRFU,IEEE4,False)
      Minimum (1,BtmBurstFdomRFU,IEEE4,False,0)
      Maximum (1,BtmBurstFdomRFU,IEEE4,False,0)
      StdDev (1,BtmBurstFDomQSU,IEEE4,False)
      Minimum (1,BtmBurstFDomQSU,IEEE4,False,0)
      Maximum (1,BtmBurstFDomQSU,IEEE4,False,0)
      StdDev (1,BtmBurstNH4Amgl,IEEE4,False)
      Minimum (1,BtmBurstNH4Amgl,IEEE4,False,0)
      Maximum (1,BtmBurstNH4Amgl,IEEE4,False,0)
      StdDev (1,BtmBurstNO3Nmgl,IEEE4,False)
      Minimum (1,BtmBurstNO3Nmgl,IEEE4,False,0)
      Maximum (1,BtmBurstNO3Nmgl,IEEE4,False,0)
      StdDev (1,BtmBurstCLmgl,IEEE4,False)
      Minimum (1,BtmBurstCLmgl,IEEE4,False,0)
      Maximum (1,BtmBurstCLmgl,IEEE4,False,0)
      StdDev (1,BtmBurstWiperPos,FP2,False)
      Minimum (1,BtmBurstWiperPos,FP2,False,0)
      Maximum (1,BtmBurstWiperPos,FP2,False,0)
      Sample (1,BtmTotalBurstVals,FP2)
      Sample (1,BtmBurstMissed,Boolean)
      Sample (1,BtmBurstErrCnt,FP2)
    EndTable

    '__________________________________________Metadata for each burst sample_____________________________________
    '_____________________collect each 1 second value that is being used to calculate "Burst" table values________________
    DataTable(BtmSecBurst,True,-1)
      'DataInterval(0,1,Min,-1)
      CardOut (0,350000)
      OpenInterval
      Sample (1,SiteID,String)
      Sample (1,SiteNum,String)
      Sample (1,BtmBurstDate,IEEE4)
      Sample (1,BtmBurstTime,IEEE4)
      Sample (1,BtmBurstTempC,IEEE4)
      Sample (1,BtmBurstTempF,IEEE4)
      Sample (1,BtmBurstSpCond,IEEE4)
      Sample (1,BtmBurstTurbFNU,IEEE4)
      Sample (1,BtmBurstDOSat,IEEE4)
      Sample (1,BtmBurstDOmgL,IEEE4)
      Sample (1,BtmBurstORP,IEEE4)
      Sample (1,BtmBurstDepthFt,IEEE4)
      Sample (1,BtmBurstDepthMeters,IEEE4)
      Sample (1,BtmBurstBattV,FP2)
      Sample (1,BtmBurstpH,FP2)
      Sample (1,BtmBurstpHmV,FP2)
      Sample (1,BtmBurstChlugL,IEEE4)
      Sample (1,BtmBurstChlRFU,IEEE4)
      Sample (1,BtmBurstBGApcRFU,IEEE4)
      Sample (1,BtmBurstBGApcugL,IEEE4)
      Sample (1,BtmBurstFdomRFU,IEEE4)
      Sample (1,BtmBurstFDomQSU,IEEE4)
      Sample (1,BtmBurstNH4Amgl,IEEE4)
      Sample (1,BtmBurstNO3Nmgl,IEEE4)
      Sample (1,BtmBurstCLmgl,IEEE4)
      Sample (1,BtmBurstWiperPos,FP2)
      Sample (1,BtmTotalBurstVals,FP2)
      Sample (1,jCount,FP2)
      Sample (1,BtmBurstMissed,Boolean)
      Sample (1,BtmBurstErrCnt,FP2)
    EndTable
  #EndIf 'endif for top bottom
#EndIf 'endif for burst
#If WqSonde = "WQ_SERIAL_BURST" Then
  DataTable (Aquarius,Rec15minFlag,-1) 'guaruntee aquarius table populates even if burst is not complete to avoid losing stage and velocity data
    CardOut (0,17280)
    OpenInterval
    ' aquarius table for burst
    Minimum (1,CR1Volts,FP2,False,False)
    Sample (1,MedBurstDate,IEEE4)
    Sample (1,MedBurstTime,IEEE4)
    Minimum (1,WqBattV,FP2,False,False)
    Sample (1,MedTempC,IEEE4) 'the "Med..." values are pulled from the burst table via "Med... = Burst.BurstMed..."
    Sample (1,MedSpCond,IEEE4)
    Sample (1,MedTurbFNU,IEEE4)
    Sample (1,MedDOSat,IEEE4)
    Sample (1,MedDOmgL,IEEE4)
    Sample (1,MedDepthFt,IEEE4)
    Sample (1,MedDepthMeters,IEEE4)
    Sample (1,MedBattV,FP2)
    Sample (1,MedpH,IEEE4)
    Sample (1,MedChlugL,IEEE4)
    Sample (1,MedChlRFU,IEEE4)
    Sample (1,MedFdomRFU,IEEE4)
    Sample (1,MedFDomQSU,IEEE4)
    #If TopBottom Then
      Sample (1,BtmMedBurstDate,IEEE4)
      Sample (1,BtmMedBurstTime,IEEE4)
      Minimum (1,BtmWqBattV,FP2,False,False)
      Sample (1,BtmMedTempC,IEEE4) 'the "Med..." values are pulled from the burst table via "Med... = Burst.BurstMed..."
      Sample (1,BtmMedSpCond,IEEE4)
      Sample (1,BtmMedTurbFNU,IEEE4)
      Sample (1,BtmMedDOSat,IEEE4)
      Sample (1,BtmMedDOmgL,IEEE4)
      Sample (1,BtmMedDepthFt,IEEE4)
      Sample (1,BtmMedDepthMeters,IEEE4)
      Sample (1,BtmMedBattV,FP2)
      Sample (1,BtmMedpH,IEEE4)
      Sample (1,BtmMedChlugL,IEEE4)
      Sample (1,BtmMedChlRFU,IEEE4)
      Sample (1,BtmMedFdomRFU,IEEE4)
      Sample (1,BtmMedFDomQSU,IEEE4)
    #EndIf
    #If HasSuna Then
      Sample (1,AvgSunaNitrateuM,IEEE4)
      Sample (1,MedSunaNitrateuM,IEEE4)
      Sample (1,StdSunaNitrateuM,IEEE4)
      Sample (1,AvgSunaNitratemgL,IEEE4)
      Sample (1,MedSunaNitratemgL,IEEE4)
      Sample (1,AvgSunaFittingResult,IEEE4)
      Sample (1,StdSunaFittingResult,IEEE4)
      Sample (1,AvgA254,IEEE4)
      Sample (1,AvgSunaDarkAve,IEEE4)
      Sample (1,AvgSunaSpecAve,IEEE4)
      Sample (1,AvgTSpec,FP2)
      Sample (1,AvgTLamp,FP2)
      Sample (1,AvgSunaHumid,FP2)
      Sample (1,AvgSunaLampTime,IEEE4)
      Sample (1,AvgSunaVoltMain,IEEE4)
      Sample (1,AvgSunaVoltLamp,IEEE4)
    #EndIf
    '    Median (1,BurstTempC,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstSpCond,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstTurbFNU,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstDOSat,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstDOmgL,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstDepthFt,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstBattV,MaxBurstCnt,FP2,WqBadData)
    '    Median (1,BurstpH,MaxBurstCnt,FP2,WqBadData)
    '    Median (1,BurstChlugL,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstChlRFU,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstFdomRFU,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstFDomQSU,MaxBurstCnt,IEEE4,WqBadData)
    Sample (1,AvgPS1Stg,IEEE4)
    Sample (1,AvgPS2Stg,IEEE4)
    Sample (1,AvgUpBeamStg,IEEE4)
    '    Sample (1,AvgStagePrime,IEEE4)
    '    Sample (1,AvgStageSec,IEEE4)
    Sample (1,AvgIndexVel,IEEE4)
    Minimum (1,VMVolts,FP2,False,False)
    Sample (1,AvgVMTemp,IEEE4)
    Sample (1,AvgVMPitch,IEEE4)
    Sample (1,AvgVMRoll,IEEE4)
    '    Sample (1,AvgLoggerQcfs,IEEE4)
  EndTable
#ElseIf (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SDI12") Then
  'regular aquarius table with instantaneous values
  DataTable (Aquarius,Rec15minFlag,-1)
    CardOut (0,17280)
    OpenInterval
    Minimum (1,CR1Volts,FP2,False,False)
    Sample (1,WqDate,IEEE4)
    Sample (1,WqTime,IEEE4)
    Minimum (1,WqBattV,FP2,False,False)
    Sample (1,WqTempC,IEEE4)
    Sample (1,WqSpCond,IEEE4)
    Sample (1,WqTurbFNU,IEEE4)
    Sample (1,WqDOSat,IEEE4)
    Sample (1,WqDOMgl,IEEE4)
    Sample (1,WqDepthFt,IEEE4)
    Sample (1,WqDepthMeters,IEEE4)
    Sample (1,WqBattV,IEEE4)
    Sample (1,WqPH,IEEE4)
    Sample (1,WqChlugL,IEEE4)
    Sample (1,WqChlRFU,IEEE4)
    Sample (1,WqFDOMrfu,IEEE4)
    Sample (1,WqFDOMqsu,IEEE4)
    #If TopBottom Then
      Sample (1,BtmWqDate,IEEE4)
      Sample (1,BtmWqTime,IEEE4)
      Minimum (1,BtmWqBattV,FP2,False,False)
      Sample (1,BtmWqTempC,IEEE4)
      Sample (1,BtmWqSpCond,IEEE4)
      Sample (1,BtmWqTurbFNU,IEEE4)
      Sample (1,BtmWqDOSat,IEEE4)
      Sample (1,BtmWqDOMgl,IEEE4)
      Sample (1,BtmWqDepthFt,IEEE4)
      Sample (1,BtmWqDepthMeters,IEEE4)
      Sample (1,BtmWqBattV,IEEE4)
      Sample (1,BtmWqPH,IEEE4)
      Sample (1,BtmWqChlugL,IEEE4)
      Sample (1,BtmWqChlRFU,IEEE4)
      Sample (1,BtmWqFDOMrfu,IEEE4)
      Sample (1,BtmWqFDOMqsu,IEEE4)
    #EndIf
    Sample (1,AvgPS1Stg,IEEE4)
    Sample (1,AvgPS2Stg,IEEE4)
    Sample (1,AvgUpBeamStg,IEEE4)
    '    Sample (1,AvgStagePrime,IEEE4)
    '    Sample (1,AvgStageSec,IEEE4)
    Sample (1,AvgIndexVel,IEEE4)
    Minimum (1,VMVolts,FP2,False,False)
    Sample (1,AvgVMTemp,IEEE4)
    Sample (1,AvgVMPitch,IEEE4)
    Sample (1,AvgVMRoll,IEEE4)
    '    Sample (1,AvgLoggerQcfs,IEEE4)
  EndTable
#EndIf

#If (WqSonde = "NONE") Then 'Don't write non-existent WQ data to the AQ table
  DataTable (Aquarius,Rec15minFlag,-1)
    CardOut (0,17280)
    OpenInterval
    Minimum (1,CR1Volts,FP2,False,False)
    Sample (1,AvgPS1Stg,IEEE4)
    Sample (1,AvgPS2Stg,IEEE4)
    Sample (1,AvgUpBeamStg,IEEE4)
    '    Sample (1,AvgStagePrime,IEEE4)
    '    Sample (1,AvgStageSec,IEEE4)
    Sample (1,AvgIndexVel,IEEE4)
    Minimum (1,VMVolts,FP2,False,False)
    Sample (1,AvgVMTemp,IEEE4)
    Sample (1,AvgVMPitch,IEEE4)
    Sample (1,AvgVMRoll,IEEE4)
    '    Sample (1,AvgLoggerQcfs,IEEE4)
  EndTable
#EndIf

#If HasSuna = True Then
  DataTable (SunaStats,RecSunaData,-1)
    CardOut(0,17280)
    Sample (1,SunaSN,FP2)
    Average (1,SunaNitrateuM,IEEE4,False)
    Median (1,SunaNitrateuM,30,IEEE4,False)
    StdDev (1,SunaNitrateuM,IEEE4,False)
    Average (1,SunaNitratemgL,IEEE4,False)
    Median (1,SunaNitratemgL,30,IEEE4,False)
    Average (1,SunaFittingResult,IEEE4,False)
    Median (1,SunaFittingResult,30,IEEE4,False)
    StdDev (1,SunaFittingResult,IEEE4,False)
    Average (1,A254,IEEE4,False)
    Average (1,SunaDarkAve,IEEE4,False)
    Average (1,SunaSpecAve,IEEE4,False)
    Average (1,TSpec,FP2,False)
    Average (1,TLamp,FP2,False)
    Average (1,SunaHumid,FP2,False)
    Average (1,SunaLampTime,IEEE4,False)
    Average (1,SunaVoltMain,IEEE4,False)
    Average (1,SunaVoltLamp,IEEE4,False)
  EndTable

  DataTable (SecSunaData,1,-1)
    CardOut(0,35000)
    Sample(1,SunaHeader,String)
    Sample(282,SunaBurstData(),IEEE4)
  EndTable

  DataTable (RawSpectrum,1,-1)
    CardOut(0,35000)
    Sample (1,SunaSN,FP2)
    Sample (256,SpectrumData(),IEEE4)
  EndTable
#EndIf

'Store Velocity  data for all bins (used for beam coordinate studies)
#If IsSpecStudy = Yes Then
  DataTable (VelData,RecAllVelFlag,-1)
    OpenInterval 'tells table to process from last execution of table
    CardOut (0,17280) 'sends copy of data to CF card, maybe output this table...
    Sample (1,SiteID,String)
    Sample (1,SiteNum,String)
    Sample(1,Coord,String)
    Sample(1,Decode,String)
    Average(MaxBins,V1(),FP2,V1Disable())
    Average(MaxBins,V2(),FP2,V2Disable())
    Average(MaxBins,V3(),FP2,V3Disable())
    Average(MaxBins,V4(),FP2,V4disable())
    Average (108,ensRSSI(),UINT2,False)
    Average (108,ensCorr(),UINT2,False)
    Sample (1,VMHeading,FP2)
    Average (1,VMpitch,FP2,False)
    Average (1,VMroll,FP2,False)
    Average (1,VMtempC,FP2,False)
    'store other... x, y, think about this... what do we really want in here
  EndTable
#EndIf

'BadQCount or YsiErrCount = 200 (problem for more than 3 hours)
'And it is called at Midnight
'QAQC table that is called at midnight and gets pertainent information
DataTable  (QAQCInfo,Rec24HrFlag,-1)
  CardOut (0,180) 'sends copy of data to CF card (Will store a lot of data on card)
  'TableFile("USR:Test",8,2,0,24,Hr,Outstat,LastFileName) 'when OutStat = True, then data goes to FTP site
  'Store system info here
  Sample (1,SiteID,String)
  Sample (1,SiteNum,String)
  Sample (1,Tech,String)
  Sample (1,VisitReason,String
  Sample (1,Program,String)
  Sample (1,ProgVersDate,String)
  Sample (1,ProgVersion, String)
  Sample (1,SerNum,Long)
  Sample (1,OSVers,String)
  Sample (1,AdcpSN,Long)
  Sample (1,IsCM,Boolean)
  Sample (1,NewADCP,Boolean)
  Sample (1,PS1SN,String)
  Sample (1,NewPS1,Boolean)
  Sample (1,PS2SN,String)
  Sample (1,NewPS2,Boolean)
  Sample (1,EX,Long)'how is the vm setup
  Sample (1,Coord,String)
  Sample (1,Decode,String)
  Sample (1,ProgErrors,Long)
  Sample (1,Low12Volts,Long)
  Sample (1,LithBat,FP2)
  Sample (1,SkipScans,Long)
  Sample (1,FreeCFMem,IEEE4)
  Sample (1,LowMeas,Boolean)
  Sample (1,HighMeas, Boolean)
  Sample (1,BadQCount,Long)
  Sample (1,BadVelCount,Long)
  Sample (1,BadBinCnt,Long)
  Sample (1,BadEnsCount,FP2)
  Sample (1,BadStgCount,Long)
  #If (WqSonde <> "NONE") Then
    Sample (1,WqErrCount,Long)
    Sample (1,WqBattV,FP2)
  #EndIf
  Sample (1,VMRestartAttempts,FP2)
  Sample (1,IndexVel,FP2)
  Sample (1,StagePrime,IEEE4)
  Sample (1,StageSecnd,IEEE4)
  Sample (1,SelStgPrime,FP2)
  Sample (1,SelStgSecnd,FP2)
  Sample (1,UpBeamStg,IEEE4)
  Sample (1,VMPressStg,IEEE4)
  Sample (1,PS1Stg,IEEE4)
  Sample (1,PS2Stg,IEEE4)
  Sample (1,SondeStg,IEEE4)
  Sample (1,UpBeamOffset,IEEE4)
  Sample (1,VMPressOffset,IEEE4)
  Sample (1,PS1Offset,IEEE4)
  Sample (1,PS2Offset,IEEE4)
  Sample (1,SondeOffset,IEEE4)
  Sample (1,VMtempC,FP2)
  Sample (1,VMpitch,FP2)
  Sample (1,VMroll,FP2)
  Sample (1,CR1Volts,FP2)
  Sample (1,ExtWHConvertVolt,FP2)
  Maximum (1,PTempC,FP2,false,false)
  Minimum (1,PTempC,FP2,false,false)
  Sample (1,NumADCPBins,FP2)
  Sample (1,NumBeams,FP2)
  Sample (1,EnsPings,FP2)
  Sample (1,BinSize,FP2)
  Sample (1,BlankDist,FP2)
  Sample (1,StartBin,FP2)
  Sample (1,EndBin,FP2)
  Sample (1,StartEbbBin,FP2)
  Sample (1,EndEbbBin,FP2)
  Sample (1,StartFldBin,FP2)
  Sample (1,EndFldBin,FP2)
  Sample (1,BiRatTran,FP2)
  Sample (1,UseBiRat,Boolean)
  Sample (1,CutOffBins,FP2)
  Sample (1,VMHeading,FP2)
  Sample (1,UseV2,Boolean)
  Sample (1,FlowSign,Long)
  Sample (1,CdmaWorks,Boolean)
  'Maximum (1,LastGoodBin,FP2,False,False)
  'Minimum (1,LastGoodBin,FP2,False,False)
  'Average (1,LastGoodBin,FP2,False)
  Sample (1,StgOffset,IEEE4)
  Sample (1,StgCoef,IEEE4)
  Sample (1,StgCoef2,IEEE4)
  Sample (1,VelOffset,IEEE4)
  Sample (1,VelCoef,IEEE4)
  Sample (1,VelCoef2,IEEE4)
  Sample (1,VelCoef3,IEEE4)
  Sample (1,UpVelOffset,IEEE4)
  Sample (1,UpVelCoef,IEEE4)
  Sample (1,UpVelCoef2,IEEE4)
  Sample (1,UpVelCoef3,IEEE4)
  Sample (1,LowVelOffset,IEEE4)
  Sample (1,LowVelCoef,IEEE4)
  Sample (1,LowVelCoef2,IEEE4)
  Sample (1,LowVelCoef3,IEEE4)
  Sample (1,Trans,FP2)
  Sample (1,VMLowMemCount,FP2)
  Sample (1,VMLowMem,Boolean)
  Sample (1,VMMemFree,FP2)
  Sample (1,RecErased,Boolean)
EndTable

'This data table is called when there is a station visit
DataTable(SiteVisit,True,-1)
  CardOut (0,50)
  Sample (1,SiteID,String)
  Sample (1,SiteNum,String)
  Sample (1,IndexVel,IEEE4)
  Sample (1,Qcfs,IEEE4)
  Sample (1,StagePrime,IEEE4)
  Sample (1,UpBeamStg,IEEE4)
  Sample (1,VMPressStg,IEEE4)
  Sample (1,PS1Stg,IEEE4)
  Sample (1,PS2Stg,IEEE4)
  Sample (1,SondeStg,IEEE4)
  Sample (1,UpBeamOffset,IEEE4)
  Sample (1,VMPressOffset,IEEE4)
  Sample (1,PS1Offset,IEEE4)
  Sample (1,PS2Offset,IEEE4)
  Sample (1,SondeOffset,IEEE4)
  Sample (1,VMtempC,FP2)
  Sample (1,VMpitch,FP2)
  Sample (1,VMroll,FP2)
  Sample (1,CR1Volts,FP2)
  Sample (1,ExtWHConvertVolt,FP2)
  Sample (1,StartBin,Long)
  Sample (1,EndBin,Long)
  Sample (1,VMHeading,FP2)
  Sample (1,NumADCPBins,Long)
  Sample (1,BlankDist,Long)
  Sample (1,BinSize,Long)
  Sample (1,CutOffBins,FP2)
  #If (WqSonde <> "NONE") Then
    Sample (1,WqBattV,FP2)
    Sample (1,WqTempC,FP2)
    Sample (1,WqSpCond,IEEE4)
    Sample (1,WqTurbFNU,FP2)
    Sample (1,WqDOMgl,FP2)
    Sample (1,WqPH,FP2)
    Sample (1,WqChlugL,FP2)
    Sample (1,WqChlRFU,FP2)
    Sample (1,WqDepthFt,FP2)
    Sample (1,WqDepthMeters,FP2)
    Sample (1,WqDOSat,FP2)
    Sample (1,WqFDOMrfu,FP2)
    Sample (1,WqFDOMqsu,FP2)
    Sample (1,WqBGArfu,FP2)
    Sample (1,WqBGAugl,FP2)
    Sample (1,WqNH4mgl,FP2)
    Sample (1,WqNO3mgl,FP2)
    Sample (1,WqCLmgl,FP2)
    Sample (1,WqErrCount,Long)
    #If TopBottom Then
      Sample (1,BtmWqBattV,FP2)
      Sample (1,BtmWqTempC,FP2)
      Sample (1,BtmWqSpCond,IEEE4)
      Sample (1,BtmWqTurbFNU,FP2)
      Sample (1,BtmWqDOMgl,FP2)
      Sample (1,BtmWqPH,FP2)
      Sample (1,BtmWqChlugL,FP2)
      Sample (1,BtmWqChlRFU,FP2)
      Sample (1,BtmWqDepthFt,FP2)
      Sample (1,BtmWqDepthMeters,FP2)
      Sample (1,BtmWqDOSat,FP2)
      Sample (1,BtmWqFDOMrfu,FP2)
      Sample (1,BtmWqFDOMqsu,FP2)
      Sample (1,BtmWqBGArfu,FP2)
      Sample (1,BtmWqBGAugl,FP2)
      Sample (1,BtmWqNH4mgl,FP2)
      Sample (1,BtmWqNO3mgl,FP2)
      Sample (1,BtmWqCLmgl,FP2)
      Sample (1,BtmWqErrCount,Long)
    #EndIf
  #EndIf
  Sample (1,BadQCount,Long)
  Sample (1,LithBat,FP2)
  Sample (1,Tech,String)
  Sample (1,VisitReason,String)
  Sample (1,VMMemFree,FP2)
EndTable

'1 MINUTE DATA OUTPUT TABLE
DataTable (Data1m,Rec1MinFlag OR OneMinConsistent,-1)'if either flag is true the one min data table will be written
  OpenInterval
  CardOut (0,169600)'trippled allocation from 43,200 to allow for continous 1min data collection
  Sample (1,SiteID,String)
  Sample (1,SiteNum,String)
  Sample (1,StagePrime,IEEE4)
  Sample (1,IndexVel,IEEE4)
  Sample (1,MeanVel,IEEE4,)
  Sample (1,Qcfs,IEEE4)
  #If (WqSonde <> "NONE") Then
    Sample (1,WqBattV,FP2)
    Sample (1,WqTempC,FP2)
    Sample (1,WqSpCond,IEEE4)
    Sample (1,WqTurbFNU,FP2)
    Sample (1,WqDOMgl,FP2)
    Sample (1,WqPH,FP2)
    Sample (1,WqPHmv,FP2)
    Sample (1,WqChlugL,FP2)
    Sample (1,WqChlRFU,FP2)
    Sample (1,WqDepthFt,FP2)
    Sample (1,WqDepthMeters,FP2)
    Sample (1,WqDOSat,FP2)
    Sample (1,WqFDOMrfu,FP2)
    Sample (1,WqFDOMqsu,FP2)
    Sample (1,WqBGArfu,FP2)
    Sample (1,WqBGAugl,FP2)
    Sample (1,WqNH4mgl,FP2)
    Sample (1,WqNO3mgl,FP2)
    Sample (1,WqCLmgl,FP2)
    Sample (1,WqWiperPos,FP2)
    #If TopBottom Then
      Sample (1,BtmWqBattV,FP2)
      Sample (1,BtmWqTempC,FP2)
      Sample (1,BtmWqSpCond,IEEE4)
      Sample (1,BtmWqTurbFNU,FP2)
      Sample (1,BtmWqDOMgl,FP2)
      Sample (1,BtmWqPH,FP2)
      Sample (1,BtmWqChlugL,FP2)
      Sample (1,BtmWqChlRFU,FP2)
      Sample (1,BtmWqDepthFt,FP2)
      Sample (1,BtmWqDepthMeters,FP2)
      Sample (1,BtmWqDOSat,FP2)
      Sample (1,BtmWqFDOMrfu,FP2)
      Sample (1,BtmWqFDOMqsu,FP2)
      Sample (1,BtmWqBGArfu,FP2)
      Sample (1,BtmWqBGAugl,FP2)
      Sample (1,BtmWqNH4mgl,FP2)
      Sample (1,BtmWqNO3mgl,FP2)
      Sample (1,BtmWqCLmgl,FP2)
      Sample (1,BtmWqWiperPos,FP2)
    #EndIf
  #EndIf
  Sample (MaxBins,VMBinVel(),IEEE4)
  Sample (MaxBins,V1(),IEEE4)
  Sample (MaxBins,V2(),IEEE4)
  Sample (MaxBins,V3(),IEEE4)
  Sample (MaxBins,V4(),IEEE4)
  Sample (1,RangedBin,FP2)
  Sample (1,CutOffBins,FP2)
  Sample (1,LowRatVel,FP2)
  Sample (1,HighRatVel,FP2)
  Sample (1,SelStgPrime,FP2)
  Sample (1,StageSecnd,IEEE4)
  Sample (1,SelStgSecnd,FP2)
EndTable

'BEAMCHECK DATA OUTPUT TABLE
DataTable (BeamCheck,RecBeamCheckFlag,-1)
  OpenInterval
  CardOut (0,17280)
  Sample (1,SiteID,String)
  Sample (1,StagePrime,IEEE4)
  Sample (1,NumBeams,Long)
  Sample (1,NumADCPBins,Long)
  Sample (1,BinSize,Long)
  Sample (1,StartBin,Long)
  Sample (1,EndBin,Long)
  Sample (1,VMpitch,FP2)
  Sample (1,VMroll,FP2)
  Average (108,ensRSSI(),UINT2,False)
  Average (108,ensCorr(),UINT2,False)
  Sample (1,VMupBeam,IEEE4)
  Average (1,VMupBeam,IEEE4,False)
  Sample (1,VMtempC,IEEE4)
  Average (1,VMtempC,IEEE4,False)
  Sample (1,VMVolts,IEEE4)
  Average (1,VMVolts,IEEE4,False)
  Sample (1,ExtWHConvertVolt,IEEE4)
  Average (1,ExtWHConvertVolt,IEEE4,False)
EndTable

'___________Field Readings Table____________
'This table will only store a single record.
'Techs can access it for field readings in SVMaq rather than scrolling through the Public Table
DataTable (SVMaq,True,1)
  Sample (1,SiteID,String)
  Sample (1,SiteNum,String)
  Sample (1,Program,String)
  Sample (1,ProgVersDate,String)
  Sample (1,ProgVersion, String)
  Sample (1,CR1Volts,FP2)
  #If HasVM <> False Then
    Sample (1,StagePrime,FP2)
    Sample (1,StageSecnd,FP2)
    Sample (1,PS1Stg,FP2)
    Sample (1,PS2Stg,IEEE4)
    Sample (1,UpBeamStg,IEEE4)
    Sample (1,VMPressStg,IEEE4)
    Sample (1,SondeStg,IEEE4)
    Sample (1,IndexVel,FP2)
    Sample (1,VMpitch,FP2)
    Sample (1,VMroll,FP2)
    Sample (1,VMtempC,FP2)
    Sample (1,VMVolts,FP2)
    Sample (1,PS1Offset,IEEE4)
    Sample (1,PS2Offset,IEEE4)
    Sample (1,UpBeamOffset,IEEE4)
    Sample (1,VMPressOffset,IEEE4)
    Sample (1,SondeOffset,IEEE4)
  #EndIf
  #If (WqSonde <> "NONE") Then
    Sample (1,WqBattV,FP2)
    Sample (1,WqTempC,FP2)
    Sample (1,WqSpCond,IEEE4)
    Sample (1,WqTurbFNU,FP2)
    Sample (1,WqDOMgl,FP2)
    Sample (1,WqPH,FP2)
    Sample (1,WqPHmv,FP2)
    Sample (1,WqChlugL,FP2)
    Sample (1,WqChlRFU,FP2)
    Sample (1,WqDepthFt,FP2)
    Sample (1,WqDepthMeters,FP2)
    Sample (1,WqDOSat,FP2)
    Sample (1,WqFDOMrfu,FP2)
    Sample (1,WqFDOMqsu,FP2)
    Sample (1,WqBGArfu,FP2)
    Sample (1,WqBGAugl,FP2)
    Sample (1,WqNH4mgl,FP2)
    Sample (1,WqNO3mgl,FP2)
    Sample (1,WqCLmgl,FP2)
    Sample (1,WqWiperPos,FP2)
    #If TopBottom Then
      Sample (1,BtmWqBattV,FP2)
      Sample (1,BtmWqTempC,FP2)
      Sample (1,BtmWqSpCond,IEEE4)
      Sample (1,BtmWqTurbFNU,FP2)
      Sample (1,BtmWqDOMgl,FP2)
      Sample (1,BtmWqPH,FP2)
      Sample (1,BtmWqChlugL,FP2)
      Sample (1,BtmWqChlRFU,FP2)
      Sample (1,BtmWqDepthFt,FP2)
      Sample (1,BtmWqDepthMeters,FP2)
      Sample (1,BtmWqDOSat,FP2)
      Sample (1,BtmWqFDOMrfu,FP2)
      Sample (1,BtmWqFDOMqsu,FP2)
      Sample (1,BtmWqBGArfu,FP2)
      Sample (1,BtmWqBGAugl,FP2)
      Sample (1,BtmWqNH4mgl,FP2)
      Sample (1,BtmWqNO3mgl,FP2)
      Sample (1,BtmWqCLmgl,FP2)
      Sample (1,BtmWqWiperPos,FP2)
    #EndIf
  #EndIf
EndTable

'NOISE FLOOR DATA TABLE
#If GetNoiseFloor = Yes Then
  DataTable (NoiseFloor,True,-1)
    OpenInterval
    CardOut (0,180)
    Sample (1,SiteID,String)
    Sample (1,SiteNum,String)
    Sample (4,NoiseHGainW(),FP2)
    'Sample (1,NoiseHGainW(2),FP2)
    Sample (4,NoiseHGainN(),FP2)
    'Sample (1,NoiseHGainN(2),FP2)
    Sample (4,NoiseLGainW(),FP2)
    'Sample (1,NoiseLGainW(2),FP2)
    Sample (4,NoiseLGainN(),FP2)
    'Sample (1,NoiseLGainN(2),FP2)
    Sample (1,VMtempC,IEEE4)
    Sample (1,VMVolts,IEEE4)
    Sample (1,ExtWHConvertVolt,IEEE4)
  EndTable
#EndIf

DataTable (Debugger,True,-1)
  OpenInterval
  CardOut (0,1440)
  Sample (1,ScanStart,FP2)
  Sample (1,ScanEnd,FP2)
  Sample (1,ADCPEnd,FP2)
  Sample (1,BeforeBurst,FP2)
  Sample (1,AfterBurst,FP2)
  #If (WqSonde <> "NONE") Then
    #If (WqSonde = "WQ_SERIAL_BURST") Then
      Sample (1,BurstDebugCount,FP2)
      Sample (1,BurstCount,FP2)
      Sample (1,WipeTime,String)
      Sample (1,WqDelay,FP2)
      Sample (1,Wipeflag,Boolean)
    #EndIf
    Sample (1,WqErrCount,FP2)
    Sample (1,WqPwrCycleCnt,Long)
  #EndIf
  Sample (1,CDMACheckStart,FP2)
  Sample (1,CDMACheckEnd,FP2)
  Sample (1,CDMACheckTotTime,FP2)
  Sample (1,ZeroVMTimeStart,FP2)
  Sample (1,ZeroVMTimeEnd,FP2)
  Sample (1,ZeroVMTotTime,FP2)
  Sample (1,ChkSumChkStart,FP2)
  Sample (1,ChkSumChkEnd,FP2)
  Sample (1,ChkSumChkTotTime,FP2)
  Sample (1,MainDecodeStart,FP2)
  Sample (1,MainDecodeEnd,FP2)
  Sample (1,MainDecodeTotTime,FP2)
  Sample (1,CalcRangeStart,FP2)
  Sample (1,CalcRangeEnd,FP2)
  Sample (1,CalcRangeTotTime,FP2)
  Sample (1,OneMinCalcStart,FP2)
  Sample (1,OneMinCalcEnd,FP2)
  Sample (1,OneMinCalcTotTime,FP2)
  Sample (1,CalcQStart,FP2)
  Sample (1,CalcQEnd,FP2)
  Sample (1,CalcQTotTime,FP2)
  Sample (1,GetVMMemStart,FP2)
  Sample (1,GetVMMemEnd,FP2)
  Sample (1,GetVMMemTotTime,FP2)
  Sample (1,VMTimeStart,FP2)
  Sample (1,VMTimeEnd,FP2)
  Sample (1,VMTotTime,FP2)
  Sample (1,CallBmChkStart,FP2)
  Sample (1,CallBmChkEnd,FP2)
  Sample (1,CallBmChkTotTime,FP2)
  Sample (1,DataTabsStart,FP2)
  Sample (1,DataTabsEnd,FP2)
  Sample (1,DataTabsTotTime,FP2)
  Sample (1,DataOutStart,FP2)
  Sample (1,DataOutEnd,FP2)
  Sample (1,DataOutTotTime,FP2)
  Sample (1,Data1mStart,FP2)
  Sample (1,Data1mEnd,FP2)
  Sample (1,Data1mTotTime,FP2)
  Sample (1,AQTabStart,FP2)
  Sample (1,AQTabEnd,FP2)
  Sample (1,AQTabTotTime,FP2)
  Sample (1,StoreToCrdStart,FP2)
  Sample (1,StoreToCrdEnd,FP2)
  Sample (1,StoreToCrdTotTime,FP2)
  Sample (1,ChkSpikeStart,FP2)
  Sample (1,ChkSpikeEnd,FP2)
  Sample (1,ChkSpikeTotTime,FP2)
  Sample (1,AddSpikeStart,FP2)
  Sample (1,AddSpikeEnd,FP2)
  Sample (1,AddSpikeTotTime,FP2)
  Sample (1,ProcessTime,FP2)
  Sample (1,DataOutCount,FP2)
  Sample (1,Data1mCount,FP2)
  Sample (1,AQcount,FP2)
  Sample (1,CardBadCount,FP2)
  Sample (1,CardOkCount,FP2)
  Sample (1,OneMinCount,FP2)
  #If WqSonde <> "WQ_SDI12" AND WqSonde <> "NONE" Then
    Sample (1,BurstComs,String)
  #EndIf
  #If HasSuna Then
    Sample (1,WipeStart,FP2)
    Sample (1,WipeEnd,FP2)
    Sample (1,SunaWipeTotTime,FP2)
    Sample (1,SunaSampleStart,FP2)
    Sample (1,SunaOnTime,FP2)
    Sample (1,SunaProcessStart,FP2)
    Sample (1,SunaProcessEnd,FP2)
    Sample (1,SunaProcessTotTime,FP2)
  #EndIf
EndTable

#If RadioNetwork = True Then
  DataTable (RadioStatus,1,1) 'testing table, holds nothing of importance for now.
    #If IsMaster = True Then
      #If NetworkSlaves = 1 Then
        Sample (1,SendToAFailCnt,FP2)
        Sample (1,LinkToAdead,Boolean)
        Sample (1,ResetTried,Boolean)
        Sample (1,RadResetAttempts,FP2)
      #ElseIf NetworkSlaves = 2 Then
        Sample (1,SendToAFailCnt,FP2)
        Sample (1,LinkToAdead,Boolean)
        Sample (1,SendToBFailCnt,FP2)
        Sample (1,LinkToBdead,Boolean)
        Sample (1,AllLinksDead,Boolean)
        Sample (1,ResetTried,Boolean)
        Sample (1,RadResetAttempts,FP2)
      #ElseIf NetworkSlaves = 3 Then
        Sample (1,SendToAFailCnt,FP2)
        Sample (1,LinkToAdead,Boolean)
        Sample (1,SendToBFailCnt,FP2)
        Sample (1,LinkToBdead,Boolean)
        Sample (1,SendToCFailCnt,FP2)
        Sample (1,LinkToCdead,Boolean)
        Sample (1,AllLinksDead,Boolean)
        Sample (1,ResetTried,Boolean)
        Sample (1,RadResetAttempts,FP2)
      #ElseIf NetworkSlaves = 4 Then
        Sample (1,SendToAFailCnt,FP2)
        Sample (1,LinkToAdead,Boolean)
        Sample (1,SendToBFailCnt,FP2)
        Sample (1,LinkToBdead,Boolean)
        Sample (1,SendToCFailCnt,FP2)
        Sample (1,LinkToCdead,Boolean)
        Sample (1,SendToDFailCnt,FP2)
        Sample (1,LinkToDdead,Boolean)
        Sample (1,AllLinksDead,Boolean)
        Sample (1,ResetTried,Boolean)
        Sample (1,RadResetAttempts,FP2)
      #EndIf 'Network Slaves
    #Else 'Not master
      Sample (1,GetFailCnt,FP2)
      Sample (1,LinkDead,Boolean)
      Sample (1,ResetTried,Boolean)
      Sample (1,RadResetAttempts,FP2)
    #EndIf 'Not master
  EndTable
#EndIf

'____________________________________SUBROUTINES__________________________________________

'________________________________Get Startup Information__________________________________
Sub GetStartup
  'look at startup table to see if user set UseDefaults to no
  '  If Startup.StartPrams(1,1) <> "false" Then 'insert default values
  '    UseDefaults = "false"
  ProgVersDate = ProgramVersionDate
  ProgVersion =ProgramVersion
  LastScan = "00:00"
  '******************Below are the default stations Parameters (~ line 740) *********************
  Tech = "TEC"
  SiteID = "xxx"
  SiteNum = "12345678"
  VisitReason = "Program update"
  'Default Flow setup values
  'Note if using bi-rating start and end must include all EBB and FLOOD bins
  StartBin = 1
  EndBin = 27
  StartEbbBin = 1 'used for bi-directional rating
  EndEbbBin = 27 'used for bi-directional rating
  StartFldBin = 1 'used for bi-directional rating
  EndFldBin = 27  'used for bi-directional rating
  BiRating = False 'set to true if using bi-directional rating
  BiRatTran = 0 'set to transition velocity for bi-directional rating
  MinExpStg = 0
  MaxExpStg = 30
  MinExpVel = -5
  MaxExpVel = 6
  LowRatVel = 0
  HighRatVel = 0
  FlowSign = 1
  SelStgPrime = PSpress
  SelStgSecnd = UPbeam
  UpBeamOffset = 0
  VMPressOffset = 0
  PS1Offset = 0
  PS2Offset = 0
  SondeOffset = 0
  'default communication setup
  PSPressPort = 3
  PSPressAddr = 0
  PSpress2Port = 5
  PSpress2Addr = 0
  #If WqSonde = "WQ_SDI12" Then
    WqSDIPort = 5
    WqAddr = 4
    'default Ysi Sonde setup values
    LocTempC = 3
    LocSpCond = 4
    LocTurbFNU = 5
    LocVolts = 9
    LocChlorMGL = 11
    LocChlorRFU = 12
    LocPH = 10
    LocDOmgL = 7
    LocDOSat = 6
    LocDepth = 8
    LocORP = 0
    LocBGA = 0
    LocFdomRFU = 0
    LocFdomQSU = 0
    LocAmmonium = 0
    LocNitrate = 0
    LocChloride = 0
    MilliToMicro = No
  #EndIf
  'Default rating variables
  CalcQ = Yes 'change to yes if Q calculations are needed
  'Area Rating:
  StgOffset = 0
  StgCoef = 0
  StgCoef2 = 0
  'meanvel rating:
  VelOffset = 0
  VelCoef = 0
  VelCoef2 = 0
  VelCoef3 = 0
  UpVelOffset = 0
  UpVelCoef = 0
  UpVelCoef2 = 0
  UpVelCoef3 = 0
  LowVelOffset = 0
  LowVelCoef = 0
  LowVelCoef2 = 0
  LowVelCoef3 = 0
  Trans = NAN
  'Misc settings
  AvgRSSIStartBin = StartBin
  AvgRSSIEndBin  = EndBin
  '****************Above are the default stations Parameters************************
  'initialize other important program variables (typically don't need to be changed)
  BiRatOK  = False 'Used by program to determin if BiRating can be done (if using CM with Instrument Coords). do not change manually, SET TO FALSE HERE
  UseBiRat = False 'flag set BY PROGRAM if both the above are true.  do not change manually, SET TO FALSE HERE
  #If GetNoiseFloor = Yes Then
    SendPT3 = True
    PT3Time = 3
  #EndIf
  InitialHRV = HighRatVel
  InitialLRV = LowRatVel
  InitialAdcpSN = 0
  InitialPS1SN = 0
  InitialPS2SN = 0
  #If WqSonde <> "NONE" Then
    WqDead = No
    'WqDeadCnt = 0
    WqErrCount = 0
    IsWQNClosed = Yes 'Default setting is for the existance of a normally closed Sonde power relay
    #If WqSonde = "WQ_SERIAL" Then
      Redeploy = True
      RecBurstFlag = False
    #EndIf
  #EndIf
  'IF this is an uplooker calculating range based on water depth
  RangeSource = UPbeam 'sensor to use for water depth over VM transducer faces
  DucerDepthOffset = 0 'difference between water depth sensor and VM transducer face
  RangedBin = 0 'starting point for range calculation
  CutOffBins = 1 'Starting point for number of bins to discard when using AutoRange feature
  VMPower = Yes
  IsSubmersed = False
  IsCDMANClosed = Yes 'Default setting is for the existance of a normally closed cdma power relay
  isVMNClosed = Yes 'Default setting for the existance of a normally Closed VM power Relay
  KeepCDMAon = Yes 'CDMA is initially setup to stay on
  'UseAutoLastBin = No
  UseV2 = No
  UseDir = No
  IsCM = Yes
  IsVADCP = No
  PosFlowDir = 0
  TrueUpBeamStg = BadDataIndicator
  TrueVMPressStg = BadDataIndicator
  TruePS1Stg = BadDataIndicator
  TruePS2Stg = BadDataIndicator
  TrueSondeStg = BadDataIndicator
  RSSIThreshold = 8
  CorrThreshold = 15
  SelectFilter = 1
  HrsCdmaOff = 4
  CDMAFailure = No
  VemcoRTR = No
  SendFlowData = False
  'since the first time the data tables are called there is no data, then
  'initially set all the bad data flags to true so no processing occurs
  'Set ODD store data flags to no
  Rec1MinFlag = No
  OneMinCount = 0
  RecordAll = No
  RecDataFlag = False
  BadStgFlag = Yes
  BadVelFlag = Yes
  BadQFlag = Yes
  LowCount = 0 'counter for # of times Ivel is below rating
  HighCount = 0 'counter for # of times Ivel is above rating
  LowMeas = No 'below rating flag
  HighMeas = No 'above rating flag
  VMLowMemVal = 0
  #If GetNoiseFloor = Yes Then
    FilterString = "RSSI"
  #EndIf
  If IsSubmersed = False AND IsCDMANClosed Then
    #If LoggerType = CR1000 Then
      SW12(0) 'turn on telemetery if there is a Normally closed relay present.
    #EndIf
    #If LoggerType = CR6 Then
      SW12(1,0)
    #EndIf
  Else
    #If LoggerType = CR1000 Then
      SW12(1) 'turn on telemetery if there's no NC relay present
    #EndIf
    #If LoggerType = CR6 Then
      SW12(1,1)
    #EndIf
  EndIf
  IsCDMAOn = Yes
EndSub


#If ReadExtPwr = True Then
  '___________________External Battery Voltage_______________________________
  Sub ExtPwrSource
    'Datalogger can only read in 5 volts or less
    'To be used with 10:1 DC voltage divider module from Campbell
    'Module divides input voltage by 10 converting to mv(13 volts results in 1300mv (1.3v))
    'Then multiplies by a number (.01) to bring at back to volts again
    VoltDiff (ExtWHConvertVolt,1,mV5000,ExtPwrCom,True,0,250,0.01,0)
    VoltDiff (ExtSolarVolt,1,mv5000,ExtSolarCom,true,0,250,0.01,0)
  End Sub
#EndIf
'____________________________________LastScan Subroutine__________________________________
'now lets create the LastScan variable for keypad menu
'Stores current hour and minute in the LastScan Variable
Sub GetLastScan
  RealTime (rTime()) 'get real time array
  If Minute >= 0 AND Minute < 10 Then
    LastScan = Hour + ":0" + Minute
  Else
    LastScan = Hour + ":" + Minute
  EndIf
EndSub

'_______________________________ Initialize variables ___________________________________________________
Sub Initialize
  VMdataIn = No
  ScanNo = 0
  BadChecksum = 0
  HeaderMismatch = 0
  NumbytesZero = 0
  ReceivedBytes = 0
  WakeUpVM = No
  SetVMTimeFlg = No
  StoreVariablesFlg = No
  GetVariablesFlg = True
  VMRestartAttempts = 0
  AvgRSSIcounter = 0
  AvgRSSIAccum = 0
  AvgSwathRSSI = 0
  #If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST")
    #If WqSonde = "WQ_SERIAL_BURST" Then
      Public iCount As Long = 0
      ResetTable(burst)
      #If TopBottom Then
        ResetTable(BtmBurst)
      #EndIf
      RecBurstFlag = False
      GetBurst = Yes
    #Else
      GetBurst = No
    #EndIf
    SetEXOTimeFlg = No
    Redeploy = True
    WqParamOrder = BadDataIndicator
    Wipeflag = False
    WqManualCycle = False
    OldEXOTime = 0
    #If TopBottom Then
      BtmOldEXOTime = 0
    #EndIf
  #EndIf

  'An array of longs is needed to collect the data because the campbell cannot read the
  'binary PD0 ensemble into a string.  When it hits a blank (HEX 00) it terminates the
  'string cutting off the rest of the ensemble'
  'so to get around this, we read in the data (one byte at a time) and put it into an
  'array of longs.  But at this point there is another problem. RDI transmits binary
  'data in "little indian" fashon (least significant byte first), but longs (two bytes)
  'are stored by campbell "big indian" (most significant byte first), so after we read
  'the byte in (to a temporary long),it is in the most significant byte.  We then must use the
  'MoveBytes statement to move it into the least significant position and store it in
  'the long array.
  Erase(Longarray())
  'Public TempDiff As Float
  'initialize the Universal WQ variables
  #If (WqSonde <> "NONE") Then
    WqDate = ""
    WqTime =""
    'Public WqNparams As Long
    WqTempC = 0
    WqTempF = 0
    WqSpCond = 0
    WqTurbFNU = 0
    WqChlugL = 0
    WqChlRFU = 0
    WqDOMgl = 0
    WqDOSat = 0
    WqPH = 0
    WqPHmv = 0
    WqORP = 0
    WqDepthFt = 0
    WqDepthMeters = 0
    WqBattV = 0
    WqBGAugl = 0
    WqBGArfu = 0
    WqFDOMrfu = 0
    WqFDOMqsu = 0
    WqNH4mgl = 0
    WqNO3mgl = 0
    WqCLmgl = 0
    WqWiperPos = 0
    WqErrCount = 0
    WqPwrCycleCnt = 0
    WqError = False
    WqDead = False
    #If TopBottom Then
      BtmWqDate = ""
      BtmWqTime =""
      'Public WqNparams As Long
      BtmWqTempC = 0
      BtmWqTempF = 0
      BtmWqSpCond = 0
      BtmWqTurbFNU = 0
      BtmWqChlugL = 0
      BtmWqChlRFU = 0
      BtmWqDOMgl = 0
      BtmWqDOSat = 0
      BtmWqPH = 0
      BtmWqPHmv = 0
      BtmWqORP = 0
      BtmWqDepthFt = 0
      BtmWqDepthMeters = 0
      BtmWqBattV = 0
      BtmWqBGAugl = 0
      BtmWqBGArfu = 0
      BtmWqFDOMrfu = 0
      BtmWqFDOMqsu = 0
      BtmWqNH4mgl = 0
      BtmWqNO3mgl = 0
      BtmWqCLmgl = 0
      BtmWqWiperPos = 0
      BtmWqErrCount = 0
      BtmWqPwrCycleCnt = 0
      BtmWqError = False
      BtmWqDead = False
      'WqDeadCnt = 0
    #EndIf
  #EndIf
End Sub

'______________________________Get System Information_____________________________________
Sub GetSysInfo
  Battery (CR1Volts) 'get battery volts
  SerNum = Status.SerialNumber(1,1)
  OSVers = Status.OSVersion(1,1)
  Program = Status.ProgName(1,1)
  ProgErrors = Status.ProgErrors(1,1)
  Low12Volts = Status.Low12VCount(1,1)
  LithBat = Status.LithiumBattery(1,1)
  SkipScans = Status.SkippedScan(1,1)
  FreeCFMem = Status.CardBytesFree(1,1)
EndSub

'__________________________________CDMA Check Subroutine__________________________________
Sub CdmaCheck
  If IsSubmersed = True  Then
    ExitSub
  EndIf
  Select Case IsCDMANClosed
  Case Yes'if relay exists
    If KeepCDMAon = Yes Then 'if want CDMA on
      #If LoggerType = CR1000 Then
        SW12(0)
      #EndIf'turn on CDMA
      #If LoggerType = CR6 Then
        SW12(1,0)
      #EndIf
      IsCDMAOn = Yes
    Else 'If want CDMA off except for window
      If TimeIntoInterval(0,60,min) Then
        #If LoggerType = CR1000 Then
          SW12(0)
        #EndIf'turn on CDMA
        #If LoggerType = CR6 Then
          SW12(1,0)
        #EndIf
        IsCDMAOn = Yes
      EndIf
      If TimeIntoInterval(10,60,min) Then
        #If LoggerType = CR1000 Then
          SW12(1)
        #EndIf'turn off CDMA
        #If LoggerType = CR6 Then
          SW12(1,1)
        #EndIf
        IsCDMAOn = No
      EndIf
    EndIf
  Case No 'if relay does not exist
    If KeepCDMAon = Yes Then 'want CDMA to stay on
      #If LoggerType = CR1000 Then
        SW12(1)
      #EndIf 'turn on CDMA
      #If LoggerType = CR6 Then
        SW12(1,1)
      #EndIf
      IsCDMAOn = Yes
    Else 'want CDMA to turn off except for window
      If TimeIntoInterval(0,60,min) Then
        #If LoggerType = CR1000 Then
          SW12(1)
        #EndIf'turn on CDMA
        #If LoggerType = CR6 Then
          SW12(1,1)
        #EndIf
        IsCDMAOn = Yes
      EndIf
      If TimeIntoInterval(10,60,min) Then
        #If LoggerType = CR1000 Then
          SW12(0)
        #EndIf'turn off CDMA
        #If LoggerType = CR6 Then
          SW12(1,0)
        #EndIf
        IsCDMAOn = No
      EndIf
    EndIf
  EndSelect
  If CycleCdmaPwr = Yes Then
    If IsCDMANClosed Then
      #If LoggerType = CR1000 Then
        SW12(1)
      #EndIf'turn off telemetery if a normally closed relay is present
      #If LoggerType = CR6 Then
        SW12(1,1)
      #EndIf
    Else
      #If LoggerType = CR1000 Then
        SW12(0)
      #EndIf 'turn off telemetery if NC relay is not present
      #If LoggerType = CR6 Then
        SW12(1,0)
      #EndIf
    EndIf  'manual cycle power Open the circuit to the CDMA
    IsCDMAOn = No
    CycleCdmaPwr = No
  EndIf
  LoggernetAddr = Route(4094)
  If LoggernetAddr = 4094 Then
    CdmaWorks = Yes
    CdmaScans = 0
    CDMAFailure = No
  Else 'cycle power to CDMA
    CdmaWorks = No
    CdmaScans = CdmaScans + 1
    If (CdmaScans >= HrsCdmaOff * (FastLoopInterval * 4)) AND (EventCDMAFlag = No) Then 'Fastloop interval is no of Subscans per 15 min so * 4 is scans per hour
      If IsCDMANClosed Then
        #If LoggerType = CR1000 Then
          SW12(1)
        #EndIf'turn off telemetery if a normally closed relay is present
        #If LoggerType = CR6 Then
          SW12(1,1)
        #EndIf
      Else
        #If LoggerType = CR1000 Then
          SW12(0)
        #EndIf 'turn off telemetery if NC relay is not present
        #If LoggerType = CR6 Then
          SW12(1,0)
        #EndIf
      EndIf  'cycle cdma off after 4 hours (Open the Circuit to the CDMA)
      IsCDMAOn = No
      CDMAFailure = Yes
      CdmaScans = 0
    EndIf
  EndIf
EndSub
'
'______________________Serial Out___________________________
'This is used to send particular values out through SlaveCom. The second CR1000
'will collect these values and parse them to be used in the appropriate locations (7 variables
#If HasSlave = Yes Then
  Sub SerialDataOut
    Dim Outstring As String * 100
    Outstring = Qcfs+","+IndexVel+","+StagePrime+","+VMtempF+","+VMVolts+","+CR1Volts+","+PTempF  ' creates a variable For the String being sent out To Second datalogger
    SerialOut (SlaveCom,Outstring,"",0,0)
  EndSub
#EndIf

#If HasVM = True Then
'---------------------Send a command to the ADCP -- Check Responses
'This subroutine is primarily used for 'expert' operators to issue command changes to the ADCP.  As written, only one command at a time can be issued from the
'user interface.  The ADCP echos and responsed are viewed from the "banner", "warning" and "CS" response variables. This capability is not available from the
'keypad, and can only be used from loggernet! Because of CR1000 limitations, the ADCP must have it's power cycled to simulate the RDI "Break" signal!
Sub (SendSetup)
  If (SendCMD) Then
    Banner = ""
    Warning = ""
    CSCmd = ""
    If CMD = "" Then
      SendCMD = False
      ExitSub
    EndIf
    SerialFlush (AdcpPort)
    'Turn Power on and off to ADCP
    Call CycleVMPower
    Call OpenADCPPort
    ''SerialOut (COMRS232,"+++","",0,100)'send alt break command
    Delay (1,1,Sec)'wait for reply
    SerialIn (Banner,AdcpPort,500,">",200)'get banner from ADCP
    'SerialIn (Prompt,AdcpPort,100,13,100)'ge
    SerialFlush (AdcpPort)
    ''send commands to HADCP
    Delay (1,1,Sec)'wait for reply
    'send a command
    SerialOut (AdcpPort,"+++" + CHR(13) + CHR(10),"",0,100)'Send
    SerialIn (Banner,AdcpPort,500,">",200)'get banner from ADCP
    SerialIn (Prompt,AdcpPort,100,-1,100)
    SerialFlush (AdcpPort)
    Delay (1,500,mSec)'wait for reply
    SerialOut (AdcpPort,CMD + CHR(13) + CHR(10),"",0,100)'Send
    SerialIn (Warning,AdcpPort,150,-1,2000)'Get Warning (if any) from ADCP
    SerialFlush (AdcpPort)
    SerialOut (AdcpPort,"CS" + CHR(13) + CHR(10),"",0,100)'CS command to start pinging
    SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
    SerialFlush (AdcpPort)
    SendCMD = False
    Call EraseWH
    #If GetNoiseFloor = Yes Then
      Call ParsePT3
    #EndIf
  EndIf
EndSub
'Open ADCP port
'----------------------------------------------
Sub OpenADCPPort
  #If LoggerType = CR6 Then
    If (IsVmMax232 = Yes) AND (AdcpPort <> ComMe) Then
      If UseCommsZeroForADCP Then
        SerialOpen (AdcpPort,VmBaud,19,0,2000,0)'open ADCP PORT with 2000 byte buffer using format 19
      Else
        SerialOpen (AdcpPort,VmBaud,19,0,2000)
      EndIf
    Else
      If UseCommsZeroForADCP Then
        SerialOpen (AdcpPort,VmBaud,3,0,2000,0)'open ADCP PORT with 2000 byte buffer using format 3
      Else
        SerialOpen (AdcpPort,VmBaud,3,0,2000)
      EndIf
    EndIf
  #Else
    If (IsVmMax232 = Yes) AND (AdcpPort <> ComMe) Then
      SerialOpen (AdcpPort,VmBaud,19,0,2000)'open with 2000 byte buffer using format 19
    Else
      SerialOpen (AdcpPort,VmBaud,3,0,2000) 'open ADCP PORT with 2000 byte buffer using format 3
    EndIf
  #EndIf
EndSub
#EndIf

#If WqSonde <> "NONE"
  Sub OpenWQPort
    #If LoggerType = CR6 'For a CR6 the port require a different configuration from a CR1000
      If UseCommsOneForSonde = True Then
        SerialOpen (WqSerialPort,WqBaud,19,0,2000,1)'Max232 requires us to use TTL language, use comms mode one.The Max232 also converts to a binary like signal and requires serial open format of 19 to function. Standard code zero results in a communication error.
      ElseIf UseCommsZeroForSonde = True Then
        SerialOpen (WqSerialPort,WqBaud,0,0,2000,0)'No Max232 is present so we uses standard RS232 language
      Else
        SerialOpen (WqSerialPort,WqBaud,0,0,2000)'In case we use a non-stanadard port configuration this is the generic code
      EndIf
    #Else 'else it is a CR1000
      If (IsWqMax232 = True) AND (WqSerialPort <> ComME) Then
        SerialOpen (WqSerialPort,WqBaud,19,0,2000)'need to use TTL if Max232 is present
      Else
        SerialOpen (WqSerialPort,WqBaud,0,0,2000)'standard RS232 language works if no Max232 is present
      EndIf
    #EndIf

  EndSub
#EndIf
'_________________________Erase WH Recorder___________________________________
Sub EraseWH
  If CMD = "RE ErAsE" Then 'If command to erase WH recorder is sent then...
    RecEraseString = Mid (Warning,23,15)  'Parse string to get "Recorder erased" from response
  Else
    RecEraseString = ""
  EndIf
  If RecEraseString = "Recorder erased" Then 'if the recorder was successfully erased, flag it in data table
    RecErased = True
  EndIf
  If IfTime (10,1440,min) AND RecErased = True Then 'Reset Recorder erase flag to false at 00:10 (allows time for flag to be written to QAQC table).
    RecErased = False
  EndIf
EndSub

#If GetNoiseFloor = Yes Then
  '__________________________Parse Noise Floor___________________________________
  Sub ParsePT3 'This routine parses the response received from the ADVM when it's been issued a "PT3" command for CHANNEL MASTER ONLY.
    Public PT3String As String * 2000
    'Zero the inputs
    PT3String = ""
    PT3String = Warning
    NoiseFlrParsed = ""
    Erase NoiseHGainW()
    Erase NoiseLGainW()
    Erase NoiseHGainN()
    Erase NoiseLGainN()
    'The final product is the "Noise Floor" for each beam. The commented out sections are for Beams 3 and 4, if we wanted them.
    If (IsCM = False) AND (IsWorkhorse = False) Then ExitSub 'if instrument is not a channel master or Workhorse then exit subroutine
    If CMD = "PT3" Then
      VisitReason = "Sent PT3 Command to ADVM"
      'StartString = InStr (1600,Warning,FilterString,2) 'Parse PT3 response into correct variables
      If IsWorkhorse Then
        'Workhorse parse stuff here
        StartString = InStr (1,PT3String,FilterString,2) 'Parse PT3 response into correct variables
        NoiseFlrParsed = Mid (PT3String,StartString,104)
        NoiseHGainW(1) = Mid (NoiseFlrParsed,10,2)
        NoiseHGainW(2) = Mid (NoiseFlrParsed,15,2)
        NoiseHGainW(3) = Mid (NoiseFlrParsed,20,2)
        NoiseHGainW(4) = Mid (NoiseFlrParsed,25,2)
        NoiseLGainW(1) = Mid (NoiseFlrParsed,50,2)
        NoiseLGainW(2) = Mid (NoiseFlrParsed,55,2)
        NoiseLGainW(3) = Mid (NoiseFlrParsed,60,2)
        NoiseLGainW(4) = Mid (NoiseFlrParsed,65,2)
      Else
        StartString = InStr (1,PT3String,FilterString,2) 'Parse PT3 response into correct variables
        NoiseFlrParsed = Mid (PT3String,StartString,104)
        NoiseHGainW(1) = Mid (NoiseFlrParsed,33,2)
        NoiseHGainW(2) = Mid (NoiseFlrParsed,37,2)
        'NoiseHGainW(3) = Mid (NoiseFlrParsed,41,2)
        'NoiseHGainW(4) = Mid (NoiseFlrParsed,45,2)
        NoiseLGainW(1) = Mid (NoiseFlrParsed,52,2)
        NoiseLGainW(2) = Mid (NoiseFlrParsed,56,2)
        'NoiseLGainW(3) = Mid (NoiseFlrParsed,60,2)
        'NoiseLGainW(4) = Mid (NoiseFlrParsed,64,2)
        NoiseHGainN(1) = Mid (NoiseFlrParsed,71,2)
        NoiseHGainN(2) = Mid (NoiseFlrParsed,75,2)
        'NoiseHGainN(3) = Mid (NoiseFlrParsed,79,2)
        'NoiseHGainN(4) = Mid (NoiseFlrParsed,83,2)
        NoiseLGainN(1) = Mid (NoiseFlrParsed,90,2)
        NoiseLGainN(2) = Mid (NoiseFlrParsed,94,2)
        'NoiseLGainN(3) = Mid (NoiseFlrParsed,98,2)
        'NoiseLGainN(4) = Mid (NoiseFlrParsed,102,2)
      EndIf
    Else
      Warning = ""
    EndIf 'if cmd = pt3
  EndSub
#EndIf 'get noisfloor
'_____________________________Wake VM______This should be modified now that we have the ability to turn the VM on and off__________________
#If HasVM Then
  Sub WakeVM
    'send a CS command To wake up VM in Case it has gone To sleep
    'SerialOut (AdcpPort,"+++","",0,100)'send alt break command
    Banner = ""
    CSCmd = ""
    Call CycleVmPower 'give it a jolt and then send a CS command
    Call OpenAdcpPort
    If IsVADCP = True Then
      SerialOut (AdcpPort,"+++","",0,100)'send alt break command
      Delay (1,1,Sec)'wait for reply
      SerialIn (Banner,AdcpPort,100,-1,100)'get banner from ADCP
      SerialFlush (AdcpPort)
      SerialOut (AdcpPort,"CSTOP" + CHR(13) + CHR(10),"",0,100)
      SerialIn (CSCmd,AdcpPort,100,-1,100)
      SerialFlush (AdcpPort)
      Delay (1,1,Sec)
      SerialOut (AdcpPort,"CS"+ CHR(13) + CHR(10),"",0,100)
      SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
      SerialFlush (AdcpPort)
      VMRestartAttempts = VMRestartAttempts + 1
    Else
      Delay (1,1,Sec)'wait for reply
      SerialIn (Banner,AdcpPort,100,-1,100)'get banner from ADCP
      SerialFlush (AdcpPort)
      SerialOut (AdcpPort,"CS"+ CHR(13) + CHR(10),"",0,100)
      SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
      SerialFlush (AdcpPort)
      VMRestartAttempts = VMRestartAttempts + 1
    EndIf
    VmDeadCount = 0 'set to zero and try again
  EndSub
#EndIf
'the program uses less ADCP processing time if the ADCP and Logger times are synchronized
'So this Sub is called to Sychronize the logger and VM times
'--------------------------------------------------------------------
Sub SetVMTime
  VMTimeStart = Timer(DebugTimer,msec,4)
  VMTimeStart = VMTimeStart/1000
  Call CycleVmPower
  'The set time command to the VM Requires leading zeros, so the logger timestamp is split out and leading zeros added if needed
  RawSetTime = Status.Timestamp 'get latest time from datalogger
  SplitStr (SplitTime(),RawSetTime," ",6,0) 'take apart the time string
  #If Debugging = True Then
    Public SendVMMonth As String
    Public SendVMDay As String
    Public SendVmHour As String
    Public SendVmMin As String
    Public SendVmSec As String
    Public SendVmYear As String
  #Else
    Dim SendVMMonth As String
    Dim SendVMDay As String
    Dim SendVmHour As String
    Dim SendVmMin As String
    Dim SendVmSec As String
    Dim SendVmYear As String
  #EndIf
  If SplitTime(1) < 10 Then  'add leading zeros if needed
    SendVMMonth = "0" + SplitTime(1)
  Else
    SendVMMonth = SplitTime(1)
  EndIf
  If SplitTime(2) < 10 Then
    SendVMDay = "0" + SplitTime(2)
  Else
    SendVMDay = SplitTime(2)
  EndIf
  If SplitTime(4) < 10 Then
    SendVmHour = "0" + SplitTime(4)
  Else
    SendVmHour = SplitTime(4)
  EndIf
  If SplitTime(5) < 10 Then
    SendVmMin = "0" + SplitTime(5)
  Else
    SendVmMin = SplitTime(5)
  EndIf
  If Round(SplitTime(6),0) < 10 Then
    SendVmSec = "0" + Round(SplitTime(6),0) 'eliminate fractional seconds
  Else
    SendVmSec = Round(SplitTime(6),0)
  EndIf
  SendVmYear = Right(SplitTime(3),2)
  VMTimeString = "TS" + SendVmYear + "/" + SendVMMonth + "/" + SendVMDay + "," + SendVmHour + ":" + SendVmMin + ":" + SendVmSec 'Reconstruct time string

  Call OpenADCPPort
  If IsVADCP = True Then 'the VADCP needs a CSTOP command to get into command mode
    SerialOut (AdcpPort,"+++","",0,100)'send alt break command
    Delay (1,1,Sec)'wait for reply
    SerialIn (Banner,AdcpPort,100,-1,100)'get banner from ADCP
    SerialFlush (AdcpPort)
    SerialOut (AdcpPort,"CSTOP" + CHR(13) + CHR(10),"",0,100)
    SerialIn (Warning,AdcpPort,100,-1,100)
    SerialFlush (AdcpPort)
    SerialOut (AdcpPort,VMTimeString + CHR(13) + CHR(10),"",0,100)
    SerialIn (Warning,AdcpPort,100,-1,100) 'get echo of CS command
    Delay (1,1,Sec)'wait for reply
    SerialOut (AdcpPort,"CS"+ CHR(13) + CHR(10),"",0,100)
    SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
    SerialFlush (AdcpPort)
    'RestartAttempts = RestartAttempts + 1
  Else
    SerialOut (AdcpPort,"+++","",0,100)'send alt break command
    Delay (1,1,Sec)'wait for reply
    SerialIn (Banner,AdcpPort,100,-1,100)'get banner from ADCP
    SerialFlush (AdcpPort)
    SerialOut (AdcpPort,VMTimeString + CHR(13) + CHR(10),"",0,100)
    SerialIn (Warning,AdcpPort,100,-1,100) 'get echo of CS command
    Delay (1,1,Sec)'wait for reply
    SerialOut (AdcpPort,"CS"+ CHR(13) + CHR(10),"",0,100)
    SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
  EndIf
  SetVMTimeFlg = false 'set the flag back to false until next time sychro
  VMTimeEnd = Timer(DebugTimer,msec,4)
  VMTimeEnd = VMTimeEnd/1000
  VMTotTime = VMTimeEnd - VMTimeStart
EndSub
'Set time on EXO
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Sub SetEXOTime
    'The set time command to the VM Requires leading zeros, so the logger timestamp is split out and leading zeros added if needed
    RawSetTime = Status.Timestamp 'get latest time from datalogger
    SplitStr (SplitTime(),RawSetTime," ",6,0) 'take apart the time string
    Public SendEXOHour As String
    Public SendEXOMin As String
    Public SendEXOSec As String
    Public CalcHour As Float
    CalcHour = SplitTime(4)
    If DWRSonde = False Then
      CalcHour = CalcHour + 8
    Else
      CalcHour = CalcHour
    EndIf
    If CalcHour >= 24 Then CalcHour = CalcHour - 24

    If CalcHour < 10 Then 'add leading zero to hour
      SendEXOHour = "0" + CalcHour
    Else
      SendEXOHour = CalcHour
    EndIf
    If SplitTime(5) < 10 Then
      SendEXOMin = "0" + SplitTime(5)
    Else
      SendEXOMin = SplitTime(5)
    EndIf
    If Round(SplitTime(6),0) < 10 Then
      SendEXOSec = "0" + Round(SplitTime(6),0) 'eliminate fractional seconds
    Else
      SendEXOSec = Round(SplitTime(6),0)
    EndIf
    EXOTimeString = SendEXOHour + ":" + SendEXOMin + ":" + SendEXOSec 'Reconstruct UTC time string to send to EXO
    Call OpenWQPort
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"setsonde 0" + CHR(13) + CHR(10),"OK",3,50)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"time " + EXOTimeString + CHR(13) + CHR(10),"OK",3,50)
    Delay (1,200,mSec)
    SerialFlush(WqSerialPort)
    #If TopBottom Then
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"setsonde 1" + CHR(13) + CHR(10),"OK",3,50)
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"time " + EXOTimeString + CHR(13) + CHR(10),"OK",3,50)
      Delay (1,200,mSec)
      SerialFlush(WqSerialPort)
    #EndIf
    SerialClose(WqSerialPort)
    SetEXOTimeFlg = False
  End Sub
#EndIf
'________________________________Cycle VM Power -- This is used similarly to the 'break' command because the CR1000 does not seem to have the ability to
'generate a break signal from its existing firmware -- I'm sure it's available in the UART, it's just not implimented!! _________________________________
'If power switch is installed then cycle VM power
Sub CycleVMPower
  '  If PowerSwitch = True Then
  Select Case IsSubmersed
  Case False
    SerialFlush (AdcpPort)
    'Turn Power on and off to ADCP assuming NC relay
    If isVMNClosed Then
      PortSet (VMSwitchPort,1 )
      Delay (1,3,Sec)
      PortSet (VMSwitchPort,0)
    Else
      PortSet (VMSwitchPort,0 )
      Delay (1,3,Sec)
      PortSet (VMSwitchPort,1)
    EndIf
  Case True
    SerialFlush (AdcpPort)
    #If LoggerType = CR1000 Then SW12(0)
    #ElseIf LoggerType = CR6 Then SW12(1,0)
    #EndIf
    Delay (1,3,Sec)
    #If LoggerType = CR1000 Then SW12(1)
    #ElseIf LoggerType = CR6 Then SW12(1,1)
    #EndIf
  EndIf
  '  EndIf
EndSub
'_________________________________Turns VM Off if user selected VMPower = false __________________________________________________________________
Sub ToggleVMPower
  '  If PowerSwitch = True
  Select Case IsSubmersed
  Case False
    If VMPower = True Then
      ExitSub
    EndIf
    If VMPower = False Then
      SerialFlush (AdcpPort)
      'Turn Power on and off to ADCP
      If isVMNClosed Then
        PortSet (VMSwitchPort,1) 'assumes NC relay
      Else
        PortSet (VMSwitchPort,0) 'NO relay
      EndIf
    EndIf
  Case True
    If VMPower = True Then
      #If LoggerType = CR1000 Then SW12(1)
      #ElseIf LoggerType = CR6 Then SW12(1,1)
      #EndIf
      ExitSub
    Else
      SerialFlush (AdcpPort)
      #If LoggerType = CR1000 Then SW12(0)
      #ElseIf LoggerType = CR6 Then SW12(1,0)
      #EndIf
    EndIf
  End Select
  '  EndIf
EndSub

'_____________________Check VM Recorder Memory Free__________________
Sub GetVMFreeMem
  Banner = ""
  Warning = ""
  If IsWorkhorse = False Then ExitSub
  If IfTime(10,1440,Min) AND RecCalibData = False Then
    SerialOut (AdcpPort,"+++" + CHR(13) + CHR(10),"",0,100) 'Send ALT+Break
    SerialIn (Banner,AdcpPort,500,">",200) 'Get response in "Banner"
    SerialIn (Prompt,AdcpPort,100,-1,100)  'Get response in "Prompt"
    SerialFlush (AdcpPort)
    Delay (1,500,mSec)
    SerialOut (AdcpPort,"RS?" + CHR(13) + CHR(10),"",0,100) 'Send "RS?" to check see how much memory is free on WH recorder
    SerialIn (VMMemString,AdcpPort,150,-1,150) 'Get response back from "RS?" command in "VMMemString" variable
    SerialFlush (AdcpPort)
    SerialOut (AdcpPort,"CS" + CHR(13) + CHR(10),"",0,100)'CS command to start pinging
    SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
    SerialFlush (AdcpPort)
    SendCMD = False
    VMMemFree = Mid (VMMemString,17,3)    ' Parse amount of memory free out of VM Response
  Else
    VMMemString = "" 'make this string blank
    If VMMemFree <= VMLowMemVal Then      'Set flag to notify if low memory on VM (determined per site), how many times?
      VMLowMem = True
      VMLowMemCount = VMLowMemCount + 1
    Else
      VMLowMem = False
      VMLowMemCount = 0
    EndIf
    If VMMemFree = 0 Then                 'Set Flag to notify if VM is out of memory, how many times?
      VMNoMem = True
      VMNoMemCount = VMNoMemCount + 1
    Else
      VMNoMem = False
      VMNoMemCount = 0
    EndIf
  EndIf
EndSub
'----------------------------------------------------------------------------------------------
'define EXO data locations
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Sub DefineLocs 'tells datalogger where to put the parameters.
    WqLocDate = t(1)
    WqLocTime = t(2)
    WqLocTempC = t(3)
    WqLocTempF = t(4)
    WqLocCond = t(5)
    WqLocTurbFNU = t(6)
    WqLocDoSat = t(7)
    WqLocDOmgL = t(8)
    WqLocDepthFt = t(9)
    WqLocDepthMeters = t(10)
    WqLocBatt = t(11)
    WqLocpH = t(12)
    WqLocpHmV = t(13)
    WqLocORP = t(14)
    WqLocChlugL = t(15)
    WqLocChlRFU = t(16)
    WqLocBGApcRFU = t(17)
    WqLocBGApcugL = t(18)
    WqLocFDomRFU = t(19)
    WqLocFDomQSU = t(20)
    WqLocNH4 = t(21)
    WqLocNO3 = t(22)
    WqLocCL = t(23)
    WqLocWiperPos = t(24)
    #If TopBottom Then
      BtmWqLocDate = BTM_t(1)
      BtmWqLocTime = BTM_t(2)
      BtmWqLocTempC = BTM_t(3)
      BtmWqLocTempF = BTM_t(4)
      BtmWqLocCond = BTM_t(5)
      BtmWqLocTurbFNU = BTM_t(6)
      BtmWqLocDoSat = BTM_t(7)
      BtmWqLocDOmgL = BTM_t(8)
      BtmWqLocDepthFt = BTM_t(9)
      BtmWqLocDepthMeters = BTM_t(10)
      BtmWqLocBatt = BTM_t(11)
      BtmWqLocpH = BTM_t(12)
      BtmWqLocpHmV = BTM_t(13)
      BtmWqLocORP = BTM_t(14)
      BtmWqLocChlugL = BTM_t(15)
      BtmWqLocChlRFU = BTM_t(16)
      BtmWqLocBGApcRFU = BTM_t(17)
      BtmWqLocBGApcugL = BTM_t(18)
      BtmWqLocFDomRFU = BTM_t(19)
      BtmWqLocFDomQSU = BTM_t(20)
      BtmWqLocNH4 = BTM_t(21)
      BtmWqLocNO3 = BTM_t(22)
      BtmWqLocCL = BTM_t(23)
      BtmWqLocWiperPos = BTM_t(24)
    #EndIf
  EndSub
#EndIf
'-----------------------------Parameter check-----Gets the parameter order from serial connected EXO sondes-----
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Sub ParamCheck 'gets the parameter codes from the EXO in whichever order they are being output
    Call OpenWQPort 'open the port
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10) 'a zero is required to wake up the sonde for other commands to be recieved. if not sonde will respond with"command?"
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"setsonde 0"+CHR(13)+CHR(10),"OK",3,50)'configure logger/SOA to talk to the top sonde
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10) 'after chosing what sonde to talk to, another zero must be sent to wake it up again.
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"para" + CHR(13) + CHR(10),"",1,0)'gives the parameter order
    Delay (1,300,mSec)
    SerialIn (WqIn,WqSerialPort,100,&H0D0A,200)
    WqIn = Trim(WqIn)
    SplitStr (WqParamOrder,WqIn,CHR(32),WqNparams,0)
    NoSondeTrig = InStr(1,WqIn,"Sonde",2)
    Delay (1,200,mSec)
    SerialFlush(WqSerialPort)
    #If TopBottom Then
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)'a zero is required to wake up the sonde for other commands to be recieved. if not sonde will respond with"command?"
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"setsonde 1"+CHR(13)+CHR(10),"OK",3,50) 'configure logger/SOA to talk to the bottom sonde
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10) 'after chosing what sonde to talk to, another zero must be sent to wake it up again.
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"para" + CHR(13) + CHR(10),"",1,0) 'gives the parameter order
      Delay (1,300,mSec)
      SerialIn (BtmWqIn,WqSerialPort,100,&H0D0A,200)
      BtmWqIn = Trim(BtmWqIn)
      SplitStr (BtmWqParamOrder,BtmWqIn,CHR(32),BtmWqNparams,0)
      BtmNoSondeTrig = InStr(1,BtmWqIn,"Sonde",2)
      Delay (1,200,mSec)
      SerialFlush(WqSerialPort)
    #EndIf
    SerialClose(WqSerialPort)
  EndSub
#EndIf
' SetDilim -----------Sets the serial connected EXO to comma delimited output----
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Sub SetDelim 'sets the EXO to comma delimited output
    Call OpenWQPort
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"setsonde 0"+CHR(13)+CHR(10),"OK",3,50)'set to communicate to top sonde
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"setdelim 2" + CHR(13) + CHR(10),"OK",3,50) 'set to comma delimited
    Delay (1,300,mSec)
    SerialIn (WqIn,WqSerialPort,100,&H0D0A,200)
    NoSondeTrig = InStr(1,WqIn,"Sonde",2)
    Delay (1,20,mSec)
    SerialFlush(WqSerialPort)
    #If TopBottom Then
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"setsonde 1"+CHR(13)+CHR(10),"OK",3,50)'set to communicate to bottom sonde
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"setdelim 2" + CHR(13) + CHR(10),"OK",3,50)'set to comma delimited
      Delay (1,300,mSec)
      SerialIn (BtmWqIn,WqSerialPort,100,&H0D0A,200)
      BtmNoSondeTrig = InStr(1,BtmWqIn,"Sonde",2)
      Delay (1,20,mSec)
      SerialFlush(WqSerialPort)
    #EndIf
    SerialClose(WqSerialPort)
  EndSub
#EndIf
'----------GetWQ_Serial------Gets a single set of data from the serial connected EXO
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Sub GetWQ_Serial 'gets single data point from EXO
    Call OpenWQPort
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"setsonde 0"+CHR(13)+CHR(10),"OK",3,50)'communicate to top sonde
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"data" + CHR(13) + CHR(10),"",1,0)'retrieve instant YSI filtered data point
    Delay (1,200,mSec)
    SerialIn (WqIn,WqSerialPort,100,&H0D0A,200)
    Erase WqData()
    WqIn = Trim(WqIn)
    SplitStr (WqData,WqIn,",",WqNparams,0)
    NoSondeTrig = InStr(1,WqIn,"Sonde",2)
    Delay (1,20,mSec)
    SerialFlush(WqSerialPort)
    #If TopBottom Then
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"setsonde 1"+CHR(13)+CHR(10),"OK",3,50)'communicate to bottom sonde
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"data" + CHR(13) + CHR(10),"",1,0) 'retrieve instant YSI filtered data point
      Delay (1,200,mSec)
      SerialIn (BtmWqIn,WqSerialPort,100,&H0D0A,200)
      Erase BtmWqData()
      BtmWqIn = Trim(BtmWqIn)
      SplitStr (BtmWqData,BtmWqIn,",",BtmWqNparams,0)
      BtmNoSondeTrig = InStr(1,BtmWqIn,"Sonde",2)
      Delay (1,20,mSec)
      SerialFlush(WqSerialPort)
    #EndIf
    SerialClose(WqSerialPort)
  EndSub
#EndIf
'-----------------Parses data from a serial connected EXO ------------------
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Sub ParseData 'Parses data into correct locations
    If (WqData(WqLocDate) <> NAN) AND (WqData(WqLocDate)<> 0) AND (WqData(WqLocTime)<> OldEXOTime)  Then
      OldEXOTime = WqData(WqLocTime)
      WqError = False
      WqDead = False
      'WqDeadCnt = 0
      WqErrCount = 0
      WqPwrCycleCnt = 0
    Else
      WqError = True
      OldEXOTime = WqData(WqLocTime)
      #If DWRSonde = False Then
        Call WQ_Mark_Bad
        Exit Sub
      #EndIf
    EndIf
    If WqLocDate > 0 Then WqDate = WqData(WqLocDate)
    If WqLocTime > 0 Then WqTime = WqData(WqLocTime)
    If WqLocTempC > 0 Then WqTempC = WqData(WqLocTempC)
    If WqLocTempF > 0 Then WqTempF = WqData(WqLocTempF)
    If WqLocCond > 0 Then WqSpCond = WqData(WqLocCond)
    If WqLocTurbFNU > 0 Then WqTurbFNU = WqData(WqLocTurbFNU)
    If WqLocDoSat > 0 Then WqDOSat = WqData(WqLocDoSat)
    If WqLocDOmgL > 0 Then WqDOMgl = WqData(WqLocDOmgL)
    If WqLocDepthFt > 0 Then WqDepthFt = WqData(WqLocDepthFt)
    If WqLocDepthMeters > 0 Then WqDepthMeters = WqData(WqLocDepthMeters)
    If WqLocBatt > 0 Then WqBattV = WqData(WqLocBatt)
    If WqLocpH > 0 Then WqPH = WqData(WqLocpH)
    If WqLocpHmV > 0 Then WqPHmv = WqData(WqLocpHmV)
    If WqLocORP > 0 Then WqORP = WqData(WqLocORP)
    If WqLocChlugL > 0 Then WqChlugL = WqData(WqLocChlugL)
    If WqLocChlRFU > 0 Then WqChlRFU = WqData(WqLocChlRFU)
    If WqLocBGApcRFU > 0 Then WqBGArfu = WqData(WqLocBGApcRFU)
    If WqLocBGApcugL > 0 Then WqBGAugl = WqData(WqLocBGApcugL)
    If WqLocFDomRFU > 0 Then WqFDOMrfu = WqData(WqLocFDomRFU)
    If WqLocFDomQSU > 0 Then WqFDOMqsu = WqData(WqLocFDomQSU)
    If WqLocNH4 > 0 Then WqNH4mgl = WqData(WqLocNH4)
    If WqLocNO3 > 0 Then WqNO3mgl = WqData(WqLocNO3)
    If WqLocCL > 0 Then WqCLmgl = WqData(WqLocCL)
    If WqLocWiperPos > 0 Then WqWiperPos = WqData(WqLocWiperPos)
    #If TopBottom Then
      If (BtmWqData(BtmWqLocDate) <> NAN) AND (BtmWqData(BtmWqLocDate)<> 0) AND (BtmWqData(BtmWqLocTime)<> BtmOldEXOTime)  Then
        BtmOldEXOTime = BtmWqData(BtmWqLocTime)
        BtmWqError = False
        BtmWqDead = False
        'WqDeadCnt = 0
        BtmWqErrCount = 0
        BtmWqPwrCycleCnt = 0
      Else
        BtmWqError = True
        BtmOldEXOTime = BtmWqData(BtmWqLocTime)
        #If DWRSonde = False Then
          Call Btm_WQ_Mark_Bad
          Exit Sub
        #EndIf
      EndIf
      If BtmWqLocDate > 0 Then BtmWqDate = BtmWqData(BtmWqLocDate)
      If BtmWqLocTime > 0 Then BtmWqTime = BtmWqData(BtmWqLocTime)
      If BtmWqLocTempC > 0 Then BtmWqTempC = BtmWqData(BtmWqLocTempC)
      If BtmWqLocTempF > 0 Then BtmWqTempF = BtmWqData(BtmWqLocTempF)
      If BtmWqLocCond > 0 Then BtmWqSpCond = BtmWqData(BtmWqLocCond)
      If BtmWqLocTurbFNU > 0 Then BtmWqTurbFNU = BtmWqData(BtmWqLocTurbFNU)
      If BtmWqLocDoSat > 0 Then BtmWqDOSat = BtmWqData(BtmWqLocDoSat)
      If BtmWqLocDOmgL > 0 Then BtmWqDOMgl = BtmWqData(BtmWqLocDOmgL)
      If BtmWqLocDepthFt > 0 Then BtmWqDepthFt = BtmWqData(BtmWqLocDepthFt)
      If BtmWqLocDepthMeters > 0 Then BtmWqDepthMeters = BtmWqData(BtmWqLocDepthMeters)
      If BtmWqLocBatt > 0 Then BtmWqBattV = BtmWqData(BtmWqLocBatt)
      If BtmWqLocpH > 0 Then BtmWqPH = BtmWqData(BtmWqLocpH)
      If BtmWqLocpHmV > 0 Then BtmWqPHmv = BtmWqData(BtmWqLocpHmV)
      If BtmWqLocORP > 0 Then BtmWqORP = BtmWqData(BtmWqLocORP)
      If BtmWqLocChlugL > 0 Then BtmWqChlugL = BtmWqData(BtmWqLocChlugL)
      If BtmWqLocChlRFU > 0 Then BtmWqChlRFU = BtmWqData(BtmWqLocChlRFU)
      If BtmWqLocBGApcRFU > 0 Then BtmWqBGArfu = BtmWqData(BtmWqLocBGApcRFU)
      If BtmWqLocBGApcugL > 0 Then BtmWqBGAugl = BtmWqData(BtmWqLocBGApcugL)
      If BtmWqLocFDomRFU > 0 Then BtmWqFDOMrfu = BtmWqData(BtmWqLocFDomRFU)
      If BtmWqLocFDomQSU > 0 Then BtmWqFDOMqsu = BtmWqData(BtmWqLocFDomQSU)
      If BtmWqLocNH4 > 0 Then BtmWqNH4mgl = BtmWqData(BtmWqLocNH4)
      If BtmWqLocNO3 > 0 Then BtmWqNO3mgl = BtmWqData(BtmWqLocNO3)
      If BtmWqLocCL > 0 Then BtmWqCLmgl = BtmWqData(BtmWqLocCL)
      If BtmWqLocWiperPos > 0 Then BtmWqWiperPos = BtmWqData(BtmWqLocWiperPos)
    #EndIf
  EndSub
#EndIf
'-------------------DefineParamsOrder----Automatically determines the order of the incoming serial connected EXO data ------
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Sub DefineParamsOrder 'used to automatically determine which order parameters are coming in
    t(1) = FindSpa (DateCode,DateCode,1,WqParamOrder())
    t(2) = FindSpa (TimeCode,TimeCode,1,WqParamOrder())
    t(3) = FindSpa (TempCCode,TempCCode,1,WqParamOrder())
    t(4) = FindSpa (TempFCode,TempFCode,1,WqParamOrder())
    t(5) = FindSpa (CondCode,CondCode,1,WqParamOrder())
    t(6) = FindSpa (TurbFNUCode,TurbFNUCode,1,WqParamOrder())
    t(7) = FindSpa (DoSatCode,DoSatCode,1,WqParamOrder())
    t(8) = FindSpa (DOmgLCode,DOmgLCode,1,WqParamOrder())
    t(9) = FindSpa (DepthFtCode,DepthFtCode,1,WqParamOrder())
    t(10) = FindSpa (DepthMetersCode,DepthMetersCode,1,WqParamOrder())
    t(11) = FindSpa (BattCode,BattCode,1,WqParamOrder())
    t(12) = FindSpa (pHCode,pHCode,1,WqParamOrder())
    t(13) = FindSpa (pHmVCode,pHmVCode,1,WqParamOrder())
    t(14) = FindSpa (ORPCode,ORPCode,1,WqParamOrder())
    t(15) = FindSpa (ChlugLCode,ChlugLCode,1,WqParamOrder())
    t(16) = FindSpa (ChlRFUCode,ChlRFUCode,1,WqParamOrder())
    t(17) = FindSpa (BGApcRFUCode,BGApcRFUCode,1,WqParamOrder())
    t(18) = FindSpa (BGApcugLCode,BGApcugLCode,1,WqParamOrder())
    t(19) = FindSpa (FDomRFU,FDomRFU,1,WqParamOrder())
    t(20) = FindSpa (FDomQSU,FDomQSU,1,WqParamOrder())
    t(21) = FindSpa (NH4Code,NH4Code,1,WqParamOrder())
    t(22) = FindSpa (NO3Code,NO3Code,1,WqParamOrder())
    t(23) = FindSpa (CLCode,CLCode,1,WqParamOrder())
    t(24) = FindSpa (WiperPos,WiperPos,1,WqParamOrder())
    #If TopBottom Then
      BTM_t(1) = FindSpa (DateCode,DateCode,1,BtmWqParamOrder())
      BTM_t(2) = FindSpa (TimeCode,TimeCode,1,BtmWqParamOrder())
      BTM_t(3) = FindSpa (TempCCode,TempCCode,1,BtmWqParamOrder())
      BTM_t(4) = FindSpa (TempFCode,TempFCode,1,BtmWqParamOrder())
      BTM_t(5) = FindSpa (CondCode,CondCode,1,BtmWqParamOrder())
      BTM_t(6) = FindSpa (TurbFNUCode,TurbFNUCode,1,BtmWqParamOrder())
      BTM_t(7) = FindSpa (DoSatCode,DoSatCode,1,BtmWqParamOrder())
      BTM_t(8) = FindSpa (DOmgLCode,DOmgLCode,1,BtmWqParamOrder())
      BTM_t(9) = FindSpa (DepthFtCode,DepthFtCode,1,BtmWqParamOrder())
      BTM_t(10) = FindSpa (DepthMetersCode,DepthMetersCode,1,BtmWqParamOrder())
      BTM_t(11) = FindSpa (BattCode,BattCode,1,BtmWqParamOrder())
      BTM_t(12) = FindSpa (pHCode,pHCode,1,BtmWqParamOrder())
      BTM_t(13) = FindSpa (pHmVCode,pHmVCode,1,BtmWqParamOrder())
      BTM_t(14) = FindSpa (ORPCode,ORPCode,1,BtmWqParamOrder())
      BTM_t(15) = FindSpa (ChlugLCode,ChlugLCode,1,BtmWqParamOrder())
      BTM_t(16) = FindSpa (ChlRFUCode,ChlRFUCode,1,BtmWqParamOrder())
      BTM_t(17) = FindSpa (BGApcRFUCode,BGApcRFUCode,1,BtmWqParamOrder())
      BTM_t(18) = FindSpa (BGApcugLCode,BGApcugLCode,1,BtmWqParamOrder())
      BTM_t(19) = FindSpa (FDomRFU,FDomRFU,1,BtmWqParamOrder())
      BTM_t(20) = FindSpa (FDomQSU,FDomQSU,1,BtmWqParamOrder())
      BTM_t(21) = FindSpa (NH4Code,NH4Code,1,BtmWqParamOrder())
      BTM_t(22) = FindSpa (NO3Code,NO3Code,1,BtmWqParamOrder())
      BTM_t(23) = FindSpa (CLCode,CLCode,1,BtmWqParamOrder())
      BTM_t(24) = FindSpa (WiperPos,WiperPos,1,BtmWqParamOrder())
    #EndIf
  EndSub
#EndIf
' -------------------SetBurst-------if collecting burst then Setup EXO for burst-----
#If WqSonde = "WQ_SERIAL_BURST" Then
  Sub SetBurst 'sets to run and receives string
    Call OpenWQPort
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)'wake up SOA
    Delay (1,20,mSec)
    SerialOut (WqSerialPort,"setsonde 0" +CHR(13)+CHR(10),"OK",3,50)'communicate to top sonde
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)'wake up SOA now that it is set to the top sonde
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"setperiod " + BurstPeriod + CHR(13) + CHR(10),"OK",3,50)
    'We won't use baude rate 9600 any more
    '    #If WqBaud = 9600 Then
    '      SerialOut (WqSerialPort,"setperiod 1170" + CHR(13) + CHR(10),"OK",3,50)
    '    #Else
    '      SerialOut (WqSerialPort,"setperiod 1000" + CHR(13) + CHR(10),"OK",3,50)
    '    #EndIf
    Delay (1,200,msec)
    SerialOut (WqSerialPort,"#" + CHR(13),"#" + CHR(13),3,100)
    SerialOut (WqSerialPort,"run" + CHR(13),"run" + CHR(13),3,10) 'Starts the Wq sampling at 1Hz
    Delay (1,1,Sec)
  End Sub
  Sub GetBurstArray 'Gets 30 second burst from sonde and stores in burst array
    BurstCount = 0
    Dim Lcount As Long
    For Lcount = 1 To 30
      SerialIn (BurstIn,WqSerialPort,100,"#",150)
      Delay(1,50,mSec)
      If BurstIn = "" Then
        WqError = true
        iCount = 1
        Exit Sub
      EndIf
      BurstIn = Replace (BurstIn,"-nan","-9999")
      SplitStr (BurstArray(iCount,1),BurstIn,CHR(32),17,0)'parse the raw string and store in burst array (process after loop)
      Delay(1,20,mSec)
      Erase(BurstIn)
      SerialFlush(WqSerialPort)
      iCount = iCount+1
      #If WqBaud = 9600 Then
        Delay(1,1100,mSec)'needs a little extra time at 9600 baud
      #Else
        Delay (1,930,mSec)
      #EndIf
    Next Lcount
    Delay (1,20,mSec)
    SerialOut (WqSerialPort,"0" + CHR(13) + CHR(10),"#",3,50)
    SerialClose(WqSerialPort)
  End Sub
  #If TopBottom Then
    Sub SetBtmBurst 'sets to run and receives string
      Call OpenWQPort
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)'wake up SOA
      Delay (1,20,mSec)
      SerialOut (WqSerialPort,"setsonde 1" +CHR(13)+CHR(10),"OK",3,50)'communicate to bottom sonde
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)'wake up SOA now that is is set to bottom sonde
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"setperiod " + BurstPeriod + CHR(13) + CHR(10),"OK",3,50)
      'We won't use baude rate 9600 any more
      '    #If WqBaud = 9600 Then
      '      SerialOut (WqSerialPort,"setperiod 1170" + CHR(13) + CHR(10),"OK",3,50)
      '    #Else
      '      SerialOut (WqSerialPort,"setperiod 1000" + CHR(13) + CHR(10),"OK",3,50)
      '    #EndIf
      Delay (1,200,msec)
      SerialOut (WqSerialPort,"#" + CHR(13),"#" + CHR(13),3,100)
      SerialOut (WqSerialPort,"run" + CHR(13),"run" + CHR(13),3,10) 'Starts the Wq sampling at 1Hz
      Delay (1,1,Sec)
    End Sub
    Sub GetBtmBurstArray 'Gets 30 second burst from sonde and stores in burst array
      BurstCount = 0
      Dim Lcount As Long
      For Lcount = 1 To 30
        SerialIn (BtmBurstIn,WqSerialPort,100,"#",150)
        Delay(1,50,mSec)
        If BtmBurstIn = "" Then
          BtmWqError = true
          iCount = 1
          Exit Sub
        EndIf
        BtmBurstIn = Replace (BtmBurstIn,"-nan","-9999")
        SplitStr (BtmBurstArray(iCount,1),BtmBurstIn,CHR(32),17,0)'parse the raw string and store in burst array (process after loop)
        Delay(1,20,mSec)
        Erase(BtmBurstIn)
        SerialFlush(WqSerialPort)
        iCount = iCount+1
        #If WqBaud = 9600 Then
          Delay(1,1100,mSec)'needs a little extra time at 9600 baud
        #Else
          Delay (1,930,mSec)
        #EndIf
      Next Lcount
      Delay (1,20,mSec)
      SerialOut (WqSerialPort,"0" + CHR(13) + CHR(10),"#",3,50)
      SerialClose(WqSerialPort)
    EndSub
  #EndIf
#EndIf
'------ParseBurst---------if collecting burst with Wq then parse the burst------------------------
#If WqSonde = "WQ_SERIAL_BURST" Then
  Sub ParseBurst 'Parses burst data into correct locations
    If (BurstData(WqLocDate) <> NAN) AND (BurstData(WqLocDate) <> 0) Then
      WqError = False
      WqDead = False
      WqErrCount = 0
      WqPwrCycleCnt = 0
      'WqDeadCnt = 0
    Else
      WqError = True
    EndIf
    If WqLocDate > 0 Then BurstDate = BurstData(WqLocDate)
    If WqLocTime > 0 Then BurstTime = BurstData(WqLocTime)
    If WqLocTempC > 0 Then BurstTempC = BurstData(WqLocTempC)
    If WqLocTempF > 0 Then BurstTempF = BurstData(WqLocTempF)
    If WqLocCond > 0 Then BurstSpCond = BurstData(WqLocCond)
    If WqLocTurbFNU > 0 Then BurstTurbFNU = BurstData(WqLocTurbFNU)
    If WqLocDoSat > 0 Then BurstDOSat = BurstData(WqLocDoSat)
    If WqLocDOmgL > 0 Then BurstDOmgL = BurstData(WqLocDOmgL)
    If WqLocDepthFt > 0 Then BurstDepthFt = BurstData(WqLocDepthFt)
    If WqLocDepthMeters > 0 Then BurstDepthMeters = BurstData(WqLocDepthMeters)
    If WqLocBatt > 0 Then BurstBattV = BurstData(WqLocBatt)
    If WqLocpH > 0 Then BurstpH = BurstData(WqLocpH)
    If WqLocpHmV > 0 Then BurstpHmV = BurstData(WqLocpHmV)
    If WqLocORP > 0 Then BurstORP = BurstData(WqLocORP)
    If WqLocChlugL > 0 Then BurstChlugL = BurstData(WqLocChlugL)
    If WqLocChlRFU > 0 Then BurstChlRFU = BurstData(WqLocChlRFU)
    If WqLocBGApcRFU > 0 Then BurstBGApcRFU = BurstData(WqLocBGApcRFU)
    If WqLocBGApcugL > 0 Then BurstBGApcugL = BurstData(WqLocBGApcugL)
    If WqLocFDomRFU > 0 Then BurstFdomRFU = BurstData(WqLocFDomRFU)
    If WqLocFDomQSU > 0 Then BurstFDomQSU = BurstData(WqLocFDomQSU)
    If WqLocNH4 > 0 Then BurstNH4Amgl = BurstData(WqLocNH4)
    If WqLocNO3 > 0 Then BurstNO3Nmgl = BurstData(WqLocNO3)
    If WqLocCL > 0 Then BurstCLmgl = BurstData(WqLocCL)
    If WqLocWiperPos > 0 Then BurstWiperPos = BurstData(WqLocWiperPos)
  EndSub
  #If TopBottom Then
    Sub ParseBtmBurst
      If (BtmBurstData(BtmWqLocDate) <> NAN) AND (BtmBurstData(BtmWqLocDate) <> 0) Then
        BtmWqError = False
        BtmWqDead = False
        BtmWqErrCount = 0
        BtmWqPwrCycleCnt = 0
        'WqDeadCnt = 0
      Else
        BtmWqError = True
      EndIf
      If BtmWqLocDate > 0 Then BtmBurstDate = BtmBurstData(BtmWqLocDate)
      If BtmWqLocTime > 0 Then BtmBurstTime = BtmBurstData(BtmWqLocTime)
      If BtmWqLocTempC > 0 Then BtmBurstTempC = BtmBurstData(BtmWqLocTempC)
      If BtmWqLocTempF > 0 Then BtmBurstTempF = BtmBurstData(BtmWqLocTempF)
      If BtmWqLocCond > 0 Then BtmBurstSpCond = BtmBurstData(BtmWqLocCond)
      If BtmWqLocTurbFNU > 0 Then BtmBurstTurbFNU = BtmBurstData(BtmWqLocTurbFNU)
      If BtmWqLocDoSat > 0 Then BtmBurstDOSat = BtmBurstData(BtmWqLocDoSat)
      If BtmWqLocDOmgL > 0 Then BtmBurstDOmgL = BtmBurstData(BtmWqLocDOmgL)
      If BtmWqLocDepthFt > 0 Then BtmBurstDepthFt = BtmBurstData(BtmWqLocDepthFt)
      If BtmWqLocDepthMeters > 0 Then BtmBurstDepthMeters = BtmBurstData(BtmWqLocDepthMeters)
      If BtmWqLocBatt > 0 Then BtmBurstBattV = BtmBurstData(BtmWqLocBatt)
      If BtmWqLocpH > 0 Then BtmBurstpH = BtmBurstData(BtmWqLocpH)
      If BtmWqLocpHmV > 0 Then BtmBurstpHmV = BtmBurstData(BtmWqLocpHmV)
      If BtmWqLocORP > 0 Then BtmBurstORP = BtmBurstData(BtmWqLocORP)
      If BtmWqLocChlugL > 0 Then BtmBurstChlugL = BtmBurstData(BtmWqLocChlugL)
      If BtmWqLocChlRFU > 0 Then BtmBurstChlRFU = BtmBurstData(BtmWqLocChlRFU)
      If BtmWqLocBGApcRFU > 0 Then BtmBurstBGApcRFU = BtmBurstData(BtmWqLocBGApcRFU)
      If BtmWqLocBGApcugL > 0 Then BtmBurstBGApcugL = BtmBurstData(BtmWqLocBGApcugL)
      If BtmWqLocFDomRFU > 0 Then BtmBurstFdomRFU = BtmBurstData(BtmWqLocFDomRFU)
      If BtmWqLocFDomQSU > 0 Then BtmBurstFDomQSU = BtmBurstData(BtmWqLocFDomQSU)
      If BtmWqLocNH4 > 0 Then BtmBurstNH4Amgl = BtmBurstData(BtmWqLocNH4)
      If BtmWqLocNO3 > 0 Then BtmBurstNO3Nmgl = BtmBurstData(BtmWqLocNO3)
      If BtmWqLocCL > 0 Then BtmBurstCLmgl = BtmBurstData(BtmWqLocCL)
      If BtmWqLocWiperPos > 0 Then BtmBurstWiperPos = BtmBurstData(BtmWqLocWiperPos)
    EndSub
  #EndIf
#EndIf

'------------------Set Burst Variables to NAN-------------------------------
'Prevent duplicate values from being populated in case new values don't get read in in time. Set all values to NAN until they're actually populated by the burst
#If (WqSonde = "WQ_SERIAL_BURST") Then
  Sub ResetBurstVars
    MedBurstDate = BadDataIndicator
    MedBurstTime = BadDataIndicator
    MedTempC = BadDataIndicator
    MedTempF = BadDataIndicator
    MedSpCond = BadDataIndicator
    MedTurbFNU = BadDataIndicator
    MedDOSat = BadDataIndicator
    MedDOmgL= BadDataIndicator
    MedORP= BadDataIndicator
    MedDepthFt = BadDataIndicator
    MedDepthMeters = BadDataIndicator
    MedBattV= BadDataIndicator
    MedpH= BadDataIndicator
    MedpHmV= BadDataIndicator
    MedChlugL= BadDataIndicator
    MedChlRFU= BadDataIndicator
    MedBGApcRFU= BadDataIndicator
    MedBGApcugL= BadDataIndicator
    MedFdomRFU= BadDataIndicator
    MedFDomQSU= BadDataIndicator
    MedNH4Amgl= BadDataIndicator
    MedNO3Nmgl= BadDataIndicator
    MedCLmgl= BadDataIndicator
    MedWiperPos= BadDataIndicator
  EndSub
  #If TopBottom Then
    Sub ResetBtmBurstVals
      BtmMedBurstDate = BadDataIndicator
      BtmMedBurstTime = BadDataIndicator
      BtmMedTempC = BadDataIndicator
      BtmMedTempF = BadDataIndicator
      BtmMedSpCond = BadDataIndicator
      BtmMedTurbFNU = BadDataIndicator
      BtmMedDOSat = BadDataIndicator
      BtmMedDOmgL= BadDataIndicator
      BtmMedORP= BadDataIndicator
      BtmMedDepthFt = BadDataIndicator
      BtmMedDepthMeters = BadDataIndicator
      BtmMedBattV= BadDataIndicator
      BtmMedpH= BadDataIndicator
      BtmMedpHmV= BadDataIndicator
      BtmMedChlugL= BadDataIndicator
      BtmMedChlRFU= BadDataIndicator
      BtmMedBGApcRFU= BadDataIndicator
      BtmMedBGApcugL= BadDataIndicator
      BtmMedFdomRFU= BadDataIndicator
      BtmMedFDomQSU= BadDataIndicator
      BtmMedNH4Amgl= BadDataIndicator
      BtmMedNO3Nmgl= BadDataIndicator
      BtmMedCLmgl= BadDataIndicator
      BtmMedWiperPos= BadDataIndicator
    EndSub
  #EndIf
  '_______________________Copy the calculated medians to a variable to be sampled into the Aquarius table___________________
  Sub CopyMedBurstVals
    MedBurstDate = Burst.BurstDate_Med
    MedBurstTime = Burst.BurstTime_Med
    MedBurstTime = Round(MedBurstTime,0) 'round the time because the median value of an even set of numbers is the average of the two median values
    MedTempC = Burst.BurstTempC_Med
    MedTempF = Burst.BurstTempF_Med
    MedSpCond = Burst.BurstSpCond_Med
    MedTurbFNU = Burst.BurstTurbFNU_Med
    MedDOSat = Burst.BurstDOSat_Med
    MedDOmgL= Burst.BurstDOmgL_Med
    MedORP= Burst.BurstORP_Med
    MedDepthFt = Burst.BurstDepthFt_Med
    MedDepthMeters = Burst.BurstDepthMeters_Med
    MedBattV= Burst.BurstBattV_Med
    MedpH= Burst.BurstpH_Med
    MedpHmV= Burst.BurstpHmV_Med
    MedChlugL= Burst.BurstChlugL_Med
    MedChlRFU= Burst.BurstChlRFU_Med
    MedBGApcRFU= Burst.BurstBGApcRFU_Med
    MedBGApcugL= Burst.BurstBGApcugL_Med
    MedFdomRFU= Burst.BurstFdomRFU_Med
    MedFDomQSU= Burst.BurstFDomQSU_Med
    MedNH4Amgl= Burst.BurstNH4Amgl_Med
    MedNO3Nmgl= Burst.BurstNO3Nmgl_Med
    MedCLmgl= Burst.BurstCLmgl_Med
    MedWiperPos= Burst.BurstWiperPos_Med

  EndSub
  #If TopBottom Then
    Sub CopyBtmMedBurstVals
      BtmMedBurstDate = BtmBurst.BtmBurstDate_Med
      BtmMedBurstTime = BtmBurst.BtmBurstTime_Med
      BtmMedBurstTime = Round(BtmMedBurstTime,0) 'round the time because the median value of an even set of numbers is the average of the two median values
      BtmMedTempC = BtmBurst.BtmBurstTempC_Med
      BtmMedTempF = BtmBurst.BtmBurstTempF_Med
      BtmMedSpCond = BtmBurst.BtmBurstSpCond_Med
      BtmMedTurbFNU = BtmBurst.BtmBurstTurbFNU_Med
      BtmMedDOSat = BtmBurst.BtmBurstDOSat_Med
      BtmMedDOmgL= BtmBurst.BtmBurstDOmgL_Med
      BtmMedORP= BtmBurst.BtmBurstORP_Med
      BtmMedDepthFt = BtmBurst.BtmBurstDepthFt_Med
      BtmMedDepthMeters = BtmBurst.BtmBurstDepthMeters_Med
      BtmMedBattV= BtmBurst.BtmBurstBattV_Med
      BtmMedpH= BtmBurst.BtmBurstpH_Med
      BtmMedpHmV= BtmBurst.BtmBurstpHmV_Med
      BtmMedChlugL= BtmBurst.BtmBurstChlugL_Med
      BtmMedChlRFU= BtmBurst.BtmBurstChlRFU_Med
      BtmMedBGApcRFU= BtmBurst.BtmBurstBGApcRFU_Med
      BtmMedBGApcugL= BtmBurst.BtmBurstBGApcugL_Med
      BtmMedFdomRFU= BtmBurst.BtmBurstFdomRFU_Med
      BtmMedFDomQSU= BtmBurst.BtmBurstFDomQSU_Med
      BtmMedNH4Amgl= BtmBurst.BtmBurstNH4Amgl_Med
      BtmMedNO3Nmgl= BtmBurst.BtmBurstNO3Nmgl_Med
      BtmMedCLmgl= BtmBurst.BtmBurstCLmgl_Med
      BtmMedWiperPos= BtmBurst.BtmBurstWiperPos_Med
    EndSub
  #EndIf
#EndIf

'-------WipWQ-----Wipe the serial connected EXO sensors----------------------------------------
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Sub WipeWq 'tells Wq to wipe
    Call OpenWQPort
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay(1,10,mSec)
    SerialOut (WqSerialPort,"setsonde 0" + CHR(13)+CHR(10),"OK",3,50)
    Delay(1,10,mSec)
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"twipeb" + CHR(13) + CHR(10),"",1,0)
    SerialIn (WqIn,WqSerialPort,100,&H0D0A,200)
    SplitStr (WqDelay,WqIn,"",1,0)
    SerialFlush (WqSerialPort)
  EndSub

  #If TopBottom Then
    Sub WipeBtmWQ
      Call OpenWQPort
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
      Delay(1,10,mSec)
      SerialOut (WqSerialPort,"setsonde 1" + CHR(13)+CHR(10),"OK",3,50)
      Delay(1,10,mSec)
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"twipeb" + CHR(13) + CHR(10),"",1,0)
      SerialIn (BtmWqIn,WqSerialPort,100,&H0D0A,200)
      SplitStr (BtmWqDelay,BtmWqIn,"",1,0)
      SerialFlush (WqSerialPort)
    EndSub
  #EndIf
  'if operator sets the manual power cycle flag then cycle WQ power
#EndIf

'----------CycleWQPower-----------Switches off the WQ power until the next Scan ------------
#If (WqSonde <> "NONE") Then
  Sub CycleWQPower
    #If LoggerType = CR1000 Then
      If IsWQNClosed Then
        PortSet(WqSwitchPort,1)
      Else
        PortSet(WqSwitchPort,0)
      EndIf 'is normally closed
    #ElseIf LoggerType = CR6 Then
      If  UseSW12_2_forWQ Then 'using SW12 port 2
        SW12(2,0)
      Else
        If IsWQNClosed Then
          PortSet(WqSwitchPort,1)
        Else
          PortSet(WqSwitchPort,0)
        EndIf
      EndIf
    #EndIf
    WqPwrCycleCnt = 0
    #If TopBottom Then
      BtmWqPwrCycleCnt = 0
      #EndIf
    WqManualCycle = False
    ErrorEvent = "Cycle Sonde Power"
    #If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
      Redeploy = true
    #EndIf
  EndSub
#EndIf
'--------GetWq_SDI12------Gets one dataset from the SDI12 connected Sonde
#If WqSonde = "WQ_SDI12" Then
  '___________________________Get YSI Sonde Data_______________________
  Sub GetWq_SDI12
    'first see if YSI or EXO Sonde is turned on...
    'YsiSonde = LowerCase(YsiSonde)
    'If YsiSonde = "yes" Then 'if user picked yes from keypad
    'first initialize variables
    'Get YSI Sonde data
    Select Case WqSDIPort 'based upon keypad choice
    Case 3
      SDI12Recorder (WqSDI12Sensor(),WqCom3,WqAddr,"C!",1.0,0)
    Case 5
      SDI12Recorder (WqSDI12Sensor(),wqCom5,WqAddr,"C!",1.0,0)
    EndSelect
    If (WqSDI12Sensor(1) <> NAN) AND (WqSDI12Sensor(1) <> 0)  Then 'if data came through then
      WqError = No
      WqErrCount = 0
      WqDead = No 'if we're getting data again let's reset the Wq counters
      'WqDeadCnt = 0
      'let's assign meaningful variable names to YSI data - based upon keypad choices.
      If LocTempC > 0 Then WqTempC = WqSDI12Sensor(LocTempC)
      If LocSpCond > 0 Then WqSpCond = WqSDI12Sensor(LocSpCond)
      If MilliToMicro = Yes Then WqSpCond = WqSpCond * 1000
      If LocVolts > 0 Then WqBattV = WqSDI12Sensor(LocVolts)
      If LocDOmgL > 0 Then WqDOMgl = WqSDI12Sensor(LocDOmgL)
      If LocDOSat > 0 Then WqDOSat = WqSDI12Sensor(LocDOSat)
      If LocPH > 0 Then WqPH = WqSDI12Sensor(LocPH)
      If LocORP > 0 Then WqORP = WqSDI12Sensor(LocORP)
      If LocDepthFt > 0 Then WqDepthFt = WqSDI12Sensor(LocDepthFt)
      If LocDepthMeters > 0 Then WqDepthMeters = WqSDI12Sensor(LocDepthMeters)
      If LocTurbFNU > 0 Then WqTurbFNU = WqSDI12Sensor(LocTurbFNU)
      If LocFdomRFU > 0 Then WqFDOMrfu = WqSDI12Sensor(LocFdomRFU)
      If LocFdomQSU > 0 Then WqFDOMqsu = WqSDI12Sensor(LocFdomQSU)
      If LocChlorMGL > 0 Then WqChlugL = WqSDI12Sensor(LocChlorMGL)
      If LocChlorRFU > 0 Then WqChlRFU = WqSDI12Sensor(LocChlorRFU)
      If LocBGA > 0 Then WqBGAugl = WqSDI12Sensor(LocBGA)
      If LocAmmonium > 0 Then WqNH4mgl = WqSDI12Sensor(LocAmmonium)
      If LocNitrate > 0 Then WqNO3mgl = WqSDI12Sensor(LocNitrate)
      If LocChloride > 0 Then WqCLmgl = WqSDI12Sensor(LocChloride)
      If LocWiperPos > 0 Then WqWiperPos = WqSDI12Sensor(LocWiperPos)
      WqTempF = WqTempC*1.8+32
      '____________________TESTING THE FOLLoWING_____________________________________________________________
      '____________________Won't affect any measurements____________________________________________________
      Wiper1Min = Data1m.wqWiperPos
      If WqWiperPos > Data1m.wqWiperPos + 0.1 OR WqWiperPos < Data1m.wqWiperPos - 0.1 Then
        WiperErrCount = WiperErrCount + 1
      Else
        WiperErrCount = 0
        WiperTestCount = WiperTestCount + 1
      EndIf
      If WiperErrCount >= 15 Then
        WiperOut = True
      Else
        WiperOut = False
      EndIf
      If WqWiperPos < Data1m.wqWiperPos + 0.1 AND WqWiperPos > Data1m.wqWiperPos - 0.1 Then
        WiperInCount = WiperInCount + 1
      EndIf
      '_______________TESTING ABOVE___________________________________________________________________________
      '
    Else 'we have no data

      WqErrCount = WqErrCount + 1
      WqPwrCycleCnt = WqPwrCycleCnt + 1
      WqError = True
      'WqSdiErr = Yes 'used to flag data for sys info file
      WqBattV = -999999 'flag volts to more easily see if problem
      WqSDI12Sensor() = NAN 'flag all WqSDI12Sensors to NAN to easily see there's a problem
      Call WQ_Mark_Bad
      If WqDead Then 'YSI has sent no data for an hour or more
        'need to change this to wqswitchport
        Call CycleWQPower
        'reset dead counter
        'WqDeadCnt = 0
        'set Wq to be alive again
      Else
        'were still counting up the Wq dead minutes
        If WqErrCount >= WQDeadCntMax Then
          WqDead = Yes
        Else
          WqDead = No
        EndIf
      EndIf
      '      If YsiWiperPos > Data1m.YsiWiperPos + 0.1 OR YsiWiperPos < Data1m.YsiWiperPos - 0.1 Then
      '        WiperErrCount = WiperErrCount + 1
      '      Else
      '        WiperErrCount = 0
      '        WiperTestCount = WiperTestCount + 1
      '      EndIf
      '      If WiperErrCount >= 15 Then
      '        WiperOut = True
      '      Else
      '        WiperOut = False
      '      EndIf
      '      If YsiWiperPos < Data1m.YsiWiperPos + 0.1 AND YsiWiperPos > Data1m.YsiWiperPos - 0.1 Then
      '        WiperInCount = WiperInCount + 1
      '      EndIf
    EndIf
  EndSub
#EndIf

'--------WQ_Mark_Bad-------- If no incoming data mark it bad
#If (WqSonde <> "NONE") Then
  Sub WQ_Mark_Bad 'if WQerror then Zero all wqdata
    WqDate = ""
    WqTime =""
    'Public WqNparams As Long
    WqTempC = BadDataIndicator
    WqTempF = BadDataIndicator
    WqSpCond = BadDataIndicator
    WqTurbFNU = BadDataIndicator
    WqChlugL = BadDataIndicator
    WqChlRFU = BadDataIndicator
    WqDOMgl = BadDataIndicator
    WqDOSat = BadDataIndicator
    WqPH = BadDataIndicator
    WqPHmv = BadDataIndicator
    WqORP = BadDataIndicator
    WqDepthFt = BadDataIndicator
    WqDepthMeters = BadDataIndicator
    WqBattV = BadDataIndicator
    WqBGAugl = BadDataIndicator
    WqBGArfu = BadDataIndicator
    WqFDOMrfu = BadDataIndicator
    WqFDOMqsu = BadDataIndicator
    WqNH4mgl = BadDataIndicator
    WqNO3mgl = BadDataIndicator
    WqCLmgl = BadDataIndicator
    WqWiperPos = BadDataIndicator
  EndSub
  #If TopBottom Then
    Sub Btm_WQ_Mark_Bad
      BtmWqDate = ""
      BtmWqTime =""
      'Public WqNparams As Long
      BtmWqTempC = BadDataIndicator
      BtmWqTempF = BadDataIndicator
      BtmWqSpCond = BadDataIndicator
      BtmWqTurbFNU = BadDataIndicator
      BtmWqChlugL = BadDataIndicator
      BtmWqChlRFU = BadDataIndicator
      BtmWqDOMgl = BadDataIndicator
      BtmWqDOSat = BadDataIndicator
      BtmWqPH = BadDataIndicator
      BtmWqPHmv = BadDataIndicator
      BtmWqORP = BadDataIndicator
      BtmWqDepthFt = BadDataIndicator
      BtmWqDepthMeters = BadDataIndicator
      BtmWqBattV = BadDataIndicator
      BtmWqBGAugl = BadDataIndicator
      BtmWqBGArfu = BadDataIndicator
      BtmWqFDOMrfu = BadDataIndicator
      BtmWqFDOMqsu = BadDataIndicator
      BtmWqNH4mgl = BadDataIndicator
      BtmWqNO3mgl = BadDataIndicator
      BtmWqCLmgl = BadDataIndicator
      BtmWqWiperPos = BadDataIndicator
    EndSub
  #EndIf
#EndIf
'___________________New Stage Subroutine______________________________
Sub GetStage
  If IsWorkhorse Then
    VMpressure = WHpressure 'It's a workhorse and there is no "VMPress" from CM
  EndIf
  Call GetPSPress 'Get SDI-12 data from PS1
  Call GetPsPress2 'Get SDI-12 data from PS2
  UpBeamStg = VMupBeam + UpBeamOffset
  VMPressStg = VMpressure + VMPressOffset
  PS1Stg = PsPress1Stg(1) + PS1Offset
  PS2Stg = PSpress2Stg(1) + PS2Offset
  #If WqSonde <> "NONE" Then
    SondeStg = WqDepthFt + SondeOffset
  #EndIf
  Select Case SelStgPrime
  Case UPbeam 'User selected Upbeam to be used as Stage
    If (VMdataIn = Yes AND VMupBeam <> NAN) Then 'If there are data coming in and they are valid
      StagePrime = UpBeamStg
      BadStgFlag = No
    Else 'otherwise flag data as bad
      BadStgFlag = Yes
      StagePrime = BadDataIndicator
    EndIf
  Case VMpress 'User Selected VM Pressure sensor to be used as stage
    If (VMdataIn = Yes AND VMpressure <> NAN) Then 'If there are data coming in and they are valid
      StagePrime = VMPressStg
      BadStgFlag = No
    Else ' Otherwise flag data as bad
      BadStgFlag = Yes
      StagePrime = BadDataIndicator
    EndIf
  Case PSpress 'User selected Pressure sensor 1 to be used as stage
    If PSPressDataIn = Yes Then
      StagePrime = PS1Stg
      BadStgFlag = No
    Else ' Otherwise flag data as bad
      BadStgFlag = Yes
      StagePrime = BadDataIndicator
    EndIf
  Case PSpress2 'User selected Pressure Sensor 2 to be used as stage
    If PSpress2DataIn = Yes Then 'if there are data then
      StagePrime = PS2Stg
      BadStgFlag = No
    Else 'otherwise flag the data as bad
      BadStgFlag = Yes
      StagePrime = BadDataIndicator
    EndIf
    'need all sondes checked for stage
    #If WqSonde <> "NONE" Then
    Case WqPress 'User selected YSI for Stage
      'Get YSI Stage Data
      If WqError = No Then 'If there are data then
        StagePrime = SondeStg
        BadStgFlag = No
      Else 'Otherwise flag the data as bad
        BadStgFlag = Yes
        StagePrime = BadDataIndicator
      EndIf
    #EndIf
  EndSelect

  Select Case SelStgSecnd
  Case UPbeam 'User selected Upbeam to be used as Stage
    If (VMdataIn = Yes AND VMupBeam <> NAN) Then 'If there are data coming in and they are valid
      StageSecnd = UpBeamStg
    Else 'otherwise flag data as bad
      StageSecnd = BadDataIndicator
    EndIf
  Case VMpress 'User Selected VM Pressure sensor to be used as stage
    If (VMdataIn = Yes AND VMpressure <> NAN) Then 'If there are data coming in and they are valid
      StageSecnd = VMPressStg
    Else ' Otherwise flag data as bad
      StageSecnd = BadDataIndicator
    EndIf
  Case PSpress 'User selected Pressure sensor 1 to be used as stage
    If PSPressDataIn = Yes Then
      StageSecnd = PS1Stg
    Else ' Otherwise flag data as bad
      StageSecnd = BadDataIndicator
    EndIf
  Case PSpress2 'User selected Pressure Sensor 2 to be used as stage
    If PSpress2DataIn = Yes Then 'if there are data then
      StageSecnd = PS2Stg
    Else 'otherwise flag the data as bad
      StageSecnd = BadDataIndicator
    EndIf
    #If WqSonde <> "NONE" Then
    Case WqPress 'User selected YSI for Stage
      'Get YSI Stage Data
      If WqError = No Then 'If there are data then
        StageSecnd = SondeStg
      Else 'Otherwise flag the data as bad
        StageSecnd = BadDataIndicator
      EndIf
    #EndIf
  EndSelect

  'now check to make sure primary stage is within range
  'this is the stage used to calculate flows
  If BadStgFlag = No Then 'if stage data is still good then...
    'lets check to see if within the expected range
    If (StagePrime > MaxExpStg) OR (StagePrime < MinExpStg) Then 'if out of range
      BadStgFlag = Yes 'set bad stage flag to true
      StagePrime = BadDataIndicator
      BadStgCount = BadStgCount + 1 'incriment bad stage counter
      '        StgLoop = 0 'initialize variable for Stg Filter below
    Else 'if stage is still good
      '        Call StgFilter 'call secondary stage filter
    EndIf
  Else 'if Bad Stage Flag was already true (from above code)
    BadStgCount = BadStgCount + 1 'incriment bad stage counter
    '      StgLoop = 0 'initialize variable for Stg Filter below
  EndIf
  'which stage insturment type being used will be stored in the output files
  StgSelect = SelStgPrime + ":" + SelStgSecnd 'indicates stage type being used
EndSub

Sub TrueStage
  'Now lets get correct offsets for each instrument to produce an accurate "Stage"
  If TrueUpBeamStg = BadDataIndicator AND TrueVMPressStg = BadDataIndicator AND TruePS1Stg = BadDataIndicator AND TruePS2Stg = BadDataIndicator AND TrueSondeStg = BadDataIndicator Then
    ExitSub
  EndIf
  If ((TrueUpBeamStg <> BadDataIndicator) AND (VMupBeam <> BadDataIndicator)) Then ' if user types in a reference stage for Upbeam then
    UpBeamOffset = TrueUpBeamStg-VMupBeam ' get offset for UpBeam
  EndIf 'Otherwise do nothing
  If ((TrueVMPressStg <> BadDataIndicator) AND (VMpressure <> BadDataIndicator)) Then 'if user types in a reference stage VM Pressure sensor then
    VMPressOffset = TrueVMPressStg-VMpressure 'get offset for VM pressure sensor
  EndIf 'otherwise do nothing
  If ((TruePS1Stg <> BadDataIndicator) AND (PsPress1Stg(1) <> BadDataIndicator)) Then 'if user types in a reference stage for Pressure sensor1 then
    PS1Offset = TruePS1Stg-PsPress1Stg(1) 'Get offset for pressure sensor 1
  EndIf 'Otherwise do nothing
  If ((TruePS2Stg <> BadDataIndicator) AND (PSpress2Stg(1) <> BadDataIndicator)) Then 'if user types in a reference stage for pressure sensor2 then
    PS2Offset = TruePS2Stg - PSpress2Stg(1)
  EndIf 'Otherwise do nothing
  #If WqSonde <> "NONE" Then
    If ((TrueSondeStg <> BadDataIndicator) AND (WqDepthFt <> BadDataIndicator)) Then 'if user types in a reference stage for YSI then
      SondeOffset = TrueSondeStg - WqDepthFt
    EndIf
  #EndIf
  'Otherwise do nothing
EndSub

'______________Stage Difference Routine________________________
'Used to produce a graph in RTMC to see the difference between stage values at a finer scale, indication of drifting
Sub StageDiff
  StgDiff = StagePrime - StageSecnd
  Round (StgDiff,3)
EndSub


'_____________________________________PsPressure Subroutine_______________________________
Sub GetPsPress
  Select Case PSPressPort
  Case 3
    SDI12Recorder (PsPress1Stg(),PS1Com3,PSPressAddr,"M!",1.0,0)
  Case 5
    SDI12Recorder (PsPress1Stg(),PS1Com5,PSPressAddr,"M!",1.0,0)
  EndSelect
  If PsPress1Stg(1) = NAN Then 'if no data commes in
    PSPressDataIn = No
  Else 'if there is PS Pressure data
    PSPressDataIn = Yes
  EndIf
EndSub

'__________________________________Pressure Sensor 2 Subroutine______________________________
Sub GetPSpress2
  Select Case PSpress2Port
  Case 3
    SDI12Recorder (PSpress2Stg(),PS2Com3,PSpress2Addr,"M!",1.0,0)
  Case 5
    SDI12Recorder (PSpress2Stg(),PS2Com5,PSpress2Addr,"M!",1.0,0)
  EndSelect
  If PSpress2Stg(1) = NAN Then 'if no data comes in
    PSpress2DataIn = No
  Else 'if there is Float Recorder data
    PSpress2DataIn = Yes
  EndIf
EndSub

'__________________________Get Instrument Serial Numbers_________________
Sub GetSN
  If (ModDay > 79270) AND (ModDay < 79390) AND RecCalibData = False Then 'if 2200hrs + 1-3 minutes and not Calbrating then get serial numbers of all
    AdcpSN = AdcpSN
    If AdcpSN <> InitialAdcpSN Then
      NewADCP = True
      InitialAdcpSN = AdcpSN 'set the new s/n to initial
    Else
      NewADCP = False
    EndIf
    Select Case PSPressPort
    Case 3
      SDI12Recorder (PS1SN,PS1Com3,PSPressAddr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from pressure sensors.
      If PS1SN <> InitialPS1SN Then
        NewPS1 = True
        InitialPS1SN = PS1SN 'Set the new sn to initial
      Else
        NewPS1 = False
      EndIf  'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
    Case 5
      SDI12Recorder (PS1SN,PS1Com5,PSPressAddr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from pressure sensors.
      If PS1SN <> InitialPS1SN Then
        NewPS1 = True
        InitialPS1SN = PS1SN 'Set the new sn to initial
      Else
        NewPS1 = False
      EndIf                                      'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
    EndSelect
    Select Case PSpress2Port
    Case 3
      SDI12Recorder (PS2SN,PS2Com3,PSpress2Addr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from pressure sensors.
      If PS2SN <> InitialPS2SN Then
        NewPS2 = True
        InitialPS2SN = PS2SN 'Set the new sn to initial
      Else
        NewPS2 = False
      EndIf                                     'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
    Case 5
      SDI12Recorder (PS2SN,PS2Com5,PSpress2Addr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from pressure sensors.
      If PS2SN <> InitialPS2SN Then
        NewPS2 = True
        InitialPS2SN = PS2SN 'Set the new sn to initial
      Else
        NewPS2 = False
      EndIf                                     'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
    EndSelect
  EndIf 'end if midnight
EndSub

'____________________________________Calculates interval for filter loops
Sub CalcLoopInterval
  Dim UnitMult As Float
  Select Case ScanUnit
  Case = 1
    UnitMult = 60000  'milliseconds in minute
  Case = 2
    UnitMult = 60     'seconds in minute
  Case = 3
    UnitMult = 1    'minutes in minute
  Case = 4
    UnitMult = 0.0166666666  'hours in minute (ok we'll probably never use this scan rate but just to be safe!!!!)
  Case = 5
    UnitMult = 0.0006944444  'days in minute (Only if we're measuring lake evaportation!!!!)
  EndSelect
  LoopInterval = (UnitMult/ScanRate) * 15 'number of scans in 15 minutes

  Select Case FastScanUnit
  Case = 1
    UnitMult = 60000  'milliseconds in minute
  Case = 2
    UnitMult = 60     'seconds in minute
  Case = 3
    UnitMult = 1    'minutes in minute
  Case = 4
    UnitMult = 0.0166666666  'hours in minute (ok we'll probably never use this scan rate but just to be safe!!!!)
  Case = 5
    UnitMult = 0.0006944444  'days in minute (Only if we're measuring lake evaportation!!!!)
  EndSelect
  FastLoopInterval = (UnitMult/FastScanRate) * 15 'number of scans in 15 minutes
EndSub

'______________________________Main Decoder___________________________________________________________
'Main Decoder for Workhorse PD0 file.  This Is run after incoming data has passed checks in main program scan.
'This decoder parses out the various data types and the varibles that are contained in the fixed header data type.
'The variable data types are decoded in separate subroutines and those subroutines are called from this subroutine.
Sub MainDecode
  Dim OffsetCounter As Long
  Dim TypeCounter As Long
  Dim IdCounter As Long
  'First decode PD0 header
  Datatypes = Longarray(6)
  Datatypes = Datatypes + 1 'Include the vertical data"
  OffsetCounter = 1
  'Get data offsets for each data type
  For TypeCounter = 1 To (Datatypes*2) Step 2
    LSB = Longarray(TypeCounter+6)
    MSB = Longarray(TypeCounter+7)
    Offsets(OffsetCounter)=(LSB + (MSB*256)) + 1
    OffsetCounter = OffsetCounter + 1
  Next TypeCounter
  'Get fixed leader offset
  FixedLeadOffset = Offsets(1)
  'Get variable leader offset
  VarLeadOffset = Offsets(2)
  'Now decode the fixed leader
  'get number of Beams
  NumBeams = Longarray(FixedLeadOffset + 8)
  'Get number of Bins
  NumADCPBins = Longarray(FixedLeadOffset + 9)
  If NumADCPBins >= MaxBins Then
    Numbins = MaxBins
  EndIf
  'Get Pings per Ensemble
  LSB = Longarray(FixedLeadOffset + 10)
  MSB = Longarray(FixedLeadOffset + 11)
  EnsPings = LSB + (MSB * 256)
  'Get Bin Size
  LSB = Longarray(FixedLeadOffset + 12)
  MSB = Longarray(FixedLeadOffset + 13)
  BinSize = LSB + (MSB * 256)
  'Get Blanking distance
  LSB = Longarray(FixedLeadOffset + 14)
  MSB = Longarray(FixedLeadOffset + 15)
  BlankDist = LSB + (MSB * 256)
  EX = Longarray(FixedLeadOffset + 25)
  If EX <= 7 Then
    Coord = "BEAM"
    Select Case NumBeams
    Case 2
      Decode = "Radial Velocities - V1=Beam1 V2=Beam2 disregard V3 and V4"
    Case 3
      Decode = "Radial Velocities - V1=Beam1 V2=Beam2 V3=Beam3 disregard V4"
    Case 4
      Decode = "Radial Velocities - V1=Beam1 V2=Beam2 V3=Beam3 V4=Beam4"
    Case Else
      Decode = "System could not be decoded"
    End Select
    RecordAll = true 'Beam coordinates are only used by special studies
    UseDir = false
  EndIf
  If (EX <= 15) AND (EX > 7) Then
    Coord = "INST"
    Select Case NumBeams
    Case 2
      Decode = "Instrument Coordinates - V1=X V2=Y disregard V3 and V4"
      BiRatOK = True 'sets flag indication that this is a channel master in instrument coordinates and it's ok to use a bi-directional rating if needed
    Case 3
      Decode = "Instrument Coordinates - V1=X V2=Y disregard V3 V4=Error"
      If IsVADCP = False Then
        BiRatOK = True 'It's ok to use the bi-rating if it is a 3-beam system and NOT an uplooker
      Else
        BiRatOK = False
      EndIf
    Case 4
      Decode = "Instrument Coordinates - V1=X V2=Y V3=Z and V4=Error"
      BiRatOK = False 'Don't allow use of bi-rating with uplookers.
    Case Else
      Decode = "System could not be decoded"
    End Select
    UseDir = false
  EndIf
  If (EX <= 23) AND (EX > 15) Then
    Coord = "SHIP"
    Select Case NumBeams
    Case 2
      Decode = "Error! --  Cannot set CM to ship coordinates"
    Case 3
      Decode = "Ship Coordinates - V1=Port V2=Starbord V3=Z and V4=Error"
    Case 4
      Decode = "Ship Coordinates - V1=Port V2=Starbord V3=Z and V4=Error"
    Case Else
      Decode = "System could not be decoded"
    End Select
    UseDir = false
  EndIf
  If (EX <= 31) AND (EX > 23) Then
    Coord = "EARTH"
    Select Case NumBeams
    Case 2
      Decode = "Error! --  Cannot set CM to Earth coordinates"
    Case 3
      Decode = "Earth Coordinates - V1=East V2=North V3=Z and V4=Error"
      RecordAll = true 'Special studies also uses earth coordinates
      UseDir = false
    Case 4
      Decode = "Earth Coordinates - V1=East V2=North V3=Z and V4=Error"
      RecordAll = true 'Special studies also uses earth coordinates
    Case Else
      Decode = "System could not be decoded"
    End Select
  EndIf
  'get instrument s/n
  ADCPSN01 = Longarray(FixedLeadOffset + 57)
  ADCPSN02 = Longarray(FixedLeadOffset + 56)
  ADCPSN03 = Longarray(FixedLeadOffset + 55)
  ADCPSN04 = Longarray(FixedLeadOffset + 54)
  AdcpSN = ADCPSN04 + (ADCPSN03*256) + (ADCPSN02*65536) +(ADCPSN01*16777216)
  '  TestADCPSN = ADCPSN04 + (ADCPSN03*256) + (ADCPSN02*65536) +(ADCPSN01*16777216)

  'get Variable Header Data
  Call VarLeadDecode
  'Loop through remaining data types, verify thier profile IDs and assign proper offsets'  Other data can be accomodated here if need be IE percent good etc
  'If profile IDs match the required data types, then call the appropriate decoders
  IsCM = No
  IsVADCP = No
  IsWorkhorse = No
  For IdCounter = 3 To Datatypes
    LSB = Longarray(Offsets(IdCounter))
    MSB = Longarray(Offsets(IdCounter) + 1)
    TempId = LSB + (MSB * 256)
    IDwords(IdCounter) = TempId
    Select Case TempId
    Case CorrelationProfileID
      'Ok it matches Correlation ID
      CorrDatOffset = Offsets(IdCounter)
      Call CorrelationDecode
    Case RSSIProfileID
      'OK it matches RSSI ID
      RSSIDatOffset = Offsets(IdCounter)
      Call RSSIDecode
    Case VelocityProfileID
      'OK it matches Velocity ID
      VelDatOffset = Offsets(IdCounter)
      Call VelDecode
    Case VMStageID
      'Ok it matches Surface track (vertical beam) Status ID
      VMStageDatOffset = Offsets(IdCounter)
      If NumBeams = 2 Then
        IsCM = Yes
      Else
        IsVADCP = Yes
        Call VADCPTransform
      EndIf
      Call VMStageDecode
    EndSelect
  Next IdCounter
  If (IsCM = No) AND (IsVADCP = No)
    If (NumBeams = 4) OR (NumBeams = 3) Then IsWorkhorse = Yes 'It's a 4 beamworkhorse or 3 beam Hadcp)
  EndIf
  'After calling all the decoders, Zero out the LongArray
  Erase (Longarray())
EndSub
'__________________________Variable Leader Decoder______________________________________
'This Sub decodes the variable leader from the longArray
Sub(VarLeadDecode)
  VarLeadOffset = VarLeadOffset - 1 'to line up with RDI Documentation
  'When you decode 2 byte binary data, you have to multiply the most significant byte
  'by 256
  LSB = 0
  MSB = 0
  temp = 0
  'get Ensemble Number
  LSB = Longarray(VarLeadOffset + 3)
  MSB = Longarray(VarLeadOffset + 4)
  MSB1 = Longarray(VarLeadOffset + 12)
  EnsembleNo = (65536 * MSB1) + (256 * MSB) + LSB
  'get Vm time
  VMYear = Longarray(VarLeadOffset + 5)
  VMMonth = Longarray(VarLeadOffset + 6)
  VMDay = Longarray(VarLeadOffset + 7)
  VMHour = Longarray(VarLeadOffset + 8)
  VMMinute = Longarray(VarLeadOffset + 9)
  VMSecond = Longarray(VarLeadOffset + 10)
  VMTime = VMYear + "/" + VMMonth + "/" + VMDay + " " + VMHour + ":" + VMMinute + ":" + VMSecond
  'get Buit in test results
  LSB = Longarray(VarLeadOffset + 13)
  MSB = Longarray(VarLeadOffset + 14)
  BIT = (256 * MSB) + LSB
  'get Heading
  LSB = Longarray(VarLeadOffset + 19)
  MSB = Longarray(VarLeadOffset + 20)
  VMHeading = ((256 * MSB) + LSB) * 0.01 'Heading scale factor
  'get Pitch
  LSB = Longarray(VarLeadOffset + 21)
  MSB = Longarray(VarLeadOffset + 22)
  temp = (256 * MSB) + LSB
  If temp > 32767 Then
    temp = temp - 65536
  EndIf
  VMpitch = temp * 0.01 'Pitch scale factor
  'get Roll
  LSB = Longarray(VarLeadOffset + 23)
  MSB = Longarray(VarLeadOffset + 24)
  temp = (256 * MSB) + LSB
  If temp > 32767 Then
    temp = temp - 65536
  EndIf
  VMroll = temp * 0.01 'Roll scale factor
  'Get Salinity
  LSB = Longarray(VarLeadOffset + 25)
  MSB = Longarray(VarLeadOffset + 26)
  temp = (256 * MSB) + LSB
  ES = temp
  'Get Temperature
  LSB = Longarray(VarLeadOffset + 27)
  MSB = Longarray(VarLeadOffset + 28)
  temp = (256 * MSB) + LSB
  If temp > 32767 Then
    temp = temp - 65536
  EndIf
  VMtempC = temp * 0.01 'Temperature scale factor
  VMtempF = VMtempC * 9/5 + 32
  'get WHvolts
  VMVolts = Longarray(VarLeadOffset + 36)

  'get pressure from Workhorse
  WHpressure = 0
  WHTempM = 0
  WHTempK = 0
  WHPSTemp = 0
  DepthLSB = 0
  DepthLSB1 = 0
  DepthMSB = 0
  DepthMSB1 = 0
  'Get corrected Max pressure (depth) from ensemble
  DepthLSB = Longarray(VarLeadOffset + 49)
  DepthLSB1 = Longarray(VarLeadOffset + 50)
  DepthMSB = Longarray(VarLeadOffset + 51)
  DepthMSB1 = Longarray(VarLeadOffset + 52)
  WHPSTemp = (16777216 * DepthMSB1) + (65536 * DepthMSB) + (256 * DepthLSB1) + DepthLSB 'this seems quite large, Better call RDI
  If WHPSTemp <> 0 Then
    WHTempK = WHPSTemp/100 'convert from decapascals to kpa
    WHTempM = (WHTempK * (1.02-0.00069*ES))/10
    WHpressure = WHTempM * Meters_to_Feet 'convert to feet
  Else
    WHpressure = BadDataIndicator
  EndIf
  ScanDiff = EnsembleNo - ScanNo
EndSub

'_______________Decode Correlation data and averages beams for each bin_________________
Sub(CorrelationDecode)
  'initialize output Arrays
  For Bin = 1 To MaxBins
    For Beam = 1 To MaxBeams
      ensCorr(Bin,Beam) = 0
    Next Beam
  Next Bin
  BinStep = 1
  EnsBin = 0
  CorrDatOffset = CorrDatOffset + 1 'to get past 2 byte ID
  For Bin = 1 To Numbins 'Start at Bin 1 Beam 1
    nCorr = 0
    AccumCorr = 0
    temp = CorrDatOffset + (4 * EnsBin) 'jump down 4 bytes each bin
    EnsBin = EnsBin + BinStep
    For Beam = 1 To NumBeams 'only grab one byte each loop
      AccumCorr = AccumCorr + Longarray(temp + Beam)
      nCorr = nCorr + 1
      ensCorr(Bin,Beam) = Longarray(temp + Beam) 'could also average here
    Next Beam
    Select Case nCorr 'average beams for each bin
    Case 0
      AvgCorr(Bin)= 0
    Case 1
      AvgCorr(Bin) = AccumCorr
    Case 2 To 4
      AvgCorr(Bin) = AccumCorr / nCorr
    Case Else
      AvgCorr(Bin) = 0
    EndSelect
  Next Bin
  'Call CorrspikeAdd
EndSub

'_________Decode Backscattered Amplitude data and averages beams for each bin___________
Sub(RSSIDecode)
  'initialize output Arrays
  For Bin = 1 To MaxBins
    For Beam = 1 To MaxBeams
      ensRSSI(Bin,Beam) = 0
    Next Beam
  Next Bin
  BinStep = 1
  EnsBin = 0
  RSSIDatOffset = RSSIDatOffset + 1 'to get past 2 byte ID
  For Bin = 1 To Numbins 'Start at Bin 1 Beam 1
    nRSSI = 0 'zero beamwise rssi counter
    AccumRSSI = 0 'zero beamwise rssi accumulator
    AvgRSSIAccum = 0 'zero binwise rssi accumulator
    AvgRSSIcounter = 0 'zero binwise rssi counter
    temp = RSSIDatOffset + (4 * EnsBin) 'jump down 4 bytes each bin
    EnsBin = EnsBin + BinStep
    For Beam = 1 To NumBeams 'only grab one byte each loop
      AccumRSSI = AccumRSSI + Longarray(temp + Beam)
      nRSSI = nRSSI + 1
      ensRSSI(Bin,Beam) = Longarray(temp + Beam) 'could also average here
    Next Beam
    Select Case nRSSI 'average beams for each bin
    Case 0
      AvgRSSI(Bin)= 0
    Case 1
      AvgRSSI(Bin) = AccumRSSI
    Case 2 To 4
      AvgRSSI(Bin) = AccumRSSI / nRSSI
    Case Else
      AvgRSSI(Bin) = 0
    EndSelect
  Next Bin
  'Call RSSIspikeAdd
  'calculate average RSSI from Swath of data (User Selected Bins)
  For Bin = AvgRSSIStartBin To AvgRSSIEndBin
    If AvgRSSI(Bin) <> 0 Then 'average the bins
      AvgRSSIAccum = AvgRSSIAccum + AvgRSSI(Bin)
      AvgRSSIcounter = AvgRSSIcounter + 1
    EndIf
  Next Bin
  If (AvgRSSIAccum <> 0) AND (AvgRSSIcounter <> 0) Then 'if either the accumulator is zero or the counter is zero then set avgrssi to bad
    AvgSwathRSSI = AvgRSSIAccum/AvgRSSIcounter
  Else
    AvgSwathRSSI = BadDataIndicator
  EndIf
EndSub

'_________________________________Channel Master Stage Decoder___________

Sub(VMStageDecode)
  If IsWorkhorse Then
    VMpressure = BadDataIndicator
    VMupBeam = BadDataIndicator
    Exit Sub
  EndIf
  VMStageDatOffset = VMStageDatOffset - 1 'to line up with RDI Documentation
  'When you decode 4 byte binary data, you have to multiply the most significant byte
  'by 16777216
  '--------------Debugging variables
  DepthLSB = 0
  DepthLSB1 = 0
  DepthMSB = 0
  DepthMSB1 = 0
  '---------------Debugging variables
  temp = 0
  TempM = 0
  LSBTemp = 0
  LSB1Temp = 0
  MSBTemp = 0
  MSB1Temp = 0
  '---------------------Get get corrected Surface track (depth) from ensemble
  DepthLSB = Longarray(VMStageDatOffset + 3)
  DepthLSB1 = Longarray(VMStageDatOffset + 4)
  DepthMSB = Longarray(VMStageDatOffset + 5)
  DepthMSB1 = Longarray(VMStageDatOffset + 6)
  VMTemp = (16777216 * DepthMSB1) + (65536 * DepthMSB) + (256 * DepthLSB1) + DepthLSB
  If VMTemp <> 0 Then
    TempM = VMTemp/10000
  Else
    TempM = BadDataIndicator
  EndIf
  VMupBeam = TempM 'This is the range to the surface from the upward beam
  '-----------------------------------------------------get uncorrected depth
  LSBTemp = Longarray(VMStageDatOffset + 7)
  LSB1Temp = Longarray(VMStageDatOffset + 8)
  MSBTemp = Longarray(VMStageDatOffset + 9)
  MSB1Temp = Longarray(VMStageDatOffset + 10)
  '    RawDepth = (16777216 * MSB1Temp) + (65536 * MSBTemp) + (256 * LSB1Temp) + LSBTemp
  '----------------Get Signal Amplitude at Surface
  LSBTemp = Longarray(VMStageDatOffset + 12)
  '    DepthSig = LSBTemp
  '--------------------------------Get Percent Good of Surface Track
  LSBTemp = Longarray(VMStageDatOffset + 13)
  '    PercGoodSurface = LSBTemp
  LSB = 0
  L1SB = 0
  MSB = 0
  M1SB = 0
  temp = 0
  TempM = 0
  'Get corrected Max pressure (depth) from ensemble
  LSB = Longarray(VMStageDatOffset + 43)
  L1SB = Longarray(VMStageDatOffset + 44)
  MSB = Longarray(VMStageDatOffset + 45)
  M1SB = Longarray(VMStageDatOffset + 46)
  VMPSTemp = (16777216 * M1SB) + (65536 * MSB) + (256 * L1SB) + LSB 'this seems quite large, Better call RDI
  If VMPSTemp <> 0 Then
    TempM = VMPSTemp/10000
  Else
    TempM = BadDataIndicator
  EndIf
  VMpressure = TempM
  VMupBeam = VMupBeam * Meters_to_Feet 'convert to Feet
  VMpressure = VMpressure * Meters_to_Feet 'convert to Feet
EndSub

'________________________________Velocity Decoder_______________________________________
Sub(VelDecode)
  'initialize output Arrays
  If FlowSign = 0 Then FlowSign = 1
  For Bin = 1 To MaxBins
    For Beam = 1 To MaxBeams
      ensVelocity(Bin,Beam) = NAN
    Next Beam
    V1(Bin) = NAN
    V2(Bin) = NAN
    V3(Bin) = NAN
    V4(Bin) = NAN
    V1Disable(Bin) = False
    V2Disable(Bin) = False
    V3Disable(Bin) = False
    V4disable(Bin) = False
  Next Bin
  BinStep = 1
  EnsBin = 0
  For Bin = 1 To Numbins 'Start at Bin 1 Beam 1
    temp = VelDatOffset + 8 * EnsBin 'jump down 8 bytes each bin
    EnsBin = EnsBin + BinStep
    For Beam = 1 To NumBeams
      Index = temp + 2 * Beam 'index down Two bytes each beam
      LSB = Longarray(Index)
      MSB = Longarray(Index + 1)
      BinVel = (256 * MSB) + LSB
      If BinVel = 32768 Then
        ensVelocity(Bin, Beam) = NAN 'bad data
      Else
        If BinVel > 32767 Then 'Handle twos compliment (negative velocity)
          BinVel = BinVel - 65536
          If BinVel < -32767 Then 'smallest allowable velocity
            BinVel = NAN 'bad data
          Else 'apply flow sign
            BinVel = BinVel * VelocityScaleWater
            BinVel = BinVel * FlowSign
          EndIf
          ensVelocity(Bin,Beam) = BinVel
        Else
          If BinVel > 32767 Then 'largest allowable velocity
            BinVel = NAN
          Else 'apply flow sign
            BinVel = BinVel * VelocityScaleWater
            BinVel = BinVel * FlowSign
          EndIf
          ensVelocity(Bin,Beam) = BinVel
        EndIf
      EndIf
    Next Beam
    'uplooker will use Zvel and Evel
    V1(Bin) = ensVelocity(Bin,1) 'Separate the big array into sub arrays
    If V1(Bin) = NAN Then V1Disable(Bin) = True 'disable the median or average calc
    V2(Bin) = ensVelocity(Bin,2) 'Could also use a small temp array for 'ensVelocity()
    If V2(Bin) = NAN Then V2Disable(Bin) = True 'disable the median or average calc
    V3(Bin) = ensVelocity(Bin,3)
    If V3(Bin) = NAN Then V3Disable(Bin) = True 'disable the median or average calc
    V4(Bin) = ensVelocity(Bin,4)
    If V4(Bin) = NAN Then V4disable(Bin) = True 'disable the median or average calc
  Next Bin
EndSub
#If UseAutoRange = true Then
  Sub CalcRangeBin
    'Dim Range As Float
    Dim DucerDepth As Float 'this is in FT
    Dim Sensordepth As Float 'this is in FT
    Dim DucerDepthCM As Float 'convert ducer depth to Centimeters
    'calculate range to water surface and set endbin appropriately
    ' Const UPbeam = 1
    ' Const VMpress = 2
    ' Const PSpress = 3
    ' Const PSpress2 = 4
    ' Const WqPress = 5
    Select Case RangeSource
    Case UPbeam
      Sensordepth = VMupBeam
    Case VMpress
      Sensordepth = VMpress
    Case PSpress
      Sensordepth = PsPress1Stg(1)
    Case PSpress2
      Sensordepth = PSpress2Stg(1)
    Case WqPress
      Sensordepth = WqDepthFt
    End Select
    DucerDepth = Sensordepth + DucerDepthOffset
    DucerDepthCM = DucerDepth * 30.48
    RangedBin = (FIX((DucerDepthCM - BlankDist)/BinSize))-CutOffBins 'remove user selected number of bins (based on beamchecks)
  End Sub
#EndIf

'________________________________Last Good Bin Filter_______________________________________
' Check the validity of bin data based on user defined thresholds
'Sub CalcLastGoodBin 'must call RSSIDecode and CorrelationDecode before calling this subroutine
'  LastGoodBin = 0
'  cntBin = 0
'  cntBin2 = 0
'  Beam = 0
'  Dim P As Long 'counter for tempcorr
'  For cntBin = 1 To NumBins
'    'zero the TempCorr array
'    For P = 1 To 4
'      TempCorr(P) = 0
'    Next P
'    For Beam = 1 To NumBeams
'      'put each beam corr into TempCorr array
'      TempCorr(Beam) = ensCorr(cntBin,Beam)
'    Next Beam
'    'now run swath std on the temp array
'    StdDevSpa (StdDevCorr(cntBin),4,TempCorr(1))'see parameter list help for StdDevSpa
'  Next cntBin
'
'  'Runs a series of checks for bin validity, based on user defined thresholds
'  For cntBin = 3 To NumBins 'starts test between bin 3 and bin 2; assumes bin 1 is good b/c sometimes bin 1 spikes
'    Select Case SelectFilter
'    Case = 0
'      ExitSub
'    Case = 1
'      If (AvgRSSI(cntBin) > (AvgRSSI(cntBin - 1)) + RSSIThreshold) Then
'        LastGoodBin = cntBin - 1
'        ExitSub
'      ElseIf cntBin = NumBins Then
'        For cntBin2 = 3 To NumBins
'          If ((AvgCorr(cntBin2) <= (AvgCorr(cntBin2-1)) - CorrThreshold)) OR ((AvgCorr(cntBin2) >= (AvgCorr(cntBin2-1)) + CorrThreshold))  Then
'            LastGoodBin = cntBin2 - 1
'            ExitSub
'          EndIf
'        Next
'      ElseIf cntBin2 = NumBins Then
'        LastGoodBin = cntBin2
'      EndIf
'    EndSelect
'  Next
'EndSub

'_______________________________Last Good Bin Check_____________________________________
'Checks to see is the LastGoodBin for the last 15 timestamps is within
' +/- 1 of the running average of the LastGoodBin.  If current LastGoodBin falls
'outside of accepted range then a counter is tripped.  This will test the overall effectiveness
'of thresholds for CalcLastGoodBin subroutine.  At a later date can add ability to filter
'out the bad ensembles.
'Sub LastGoodBinCheck
'  TestEns = LastGoodBin
'  '  If IfTime (0,15,Min) Then RunEnsSpikes = 0 'resets every 15 minutes
'  If RunEnsSpikes = 5 Then EnsLoop = 0 'resets EnsLoop if too many spikes encounter in 15 minutes
'  If EnsLoop < LoopInterval Then 'waits for 15 Minutes before preceeding with checks
'    EnsLoop = EnsLoop + 1
'  ElseIf TestEns < (AvgRunEns - 1) OR TestEns > (AvgRunEns + 1) Then
'    BadEnsFlag = True
'    BadEnsCount = BadEnsCount + 1
'    RunEnsSpikes = RunEnsSpikes + 1
'  Else
'    BadEnsFlag = False
'  EndIf
'  If BadEnsFlag = False Then AvgRun(AvgRunEns,1,TestEns,15) 'creates a 15 muinute running average of the LastGoodBin values
'EndSub

'____________________________1 Minute Velocity Average__________________________________
'subroutine averages all good bins for each ensemble for V1,V2, V3,and V4
'Min and Max acceptable Vel ranges are set by user with keypad
'defaults values are -5 and 5 respectively
Sub(OneMinuteCalcs)
  Dim TotBins As Long
  Dim BinVelCount As Long
  Public MidBin As Long
  Public EbbDir As Boolean = true
  ' If IfTime (0,1440,Min) Then BadVelCount = 0 'initialize counter
  V1Cnt = 0
  V1EbbCnt = 0
  V1FldCnt = 0
  V2Cnt = 0
  V2EbbCnt = 0
  V2FldCnt = 0
  V3Cnt = 0
  V4Cnt = 0
  V1Sum = 0
  V1EbbSum = 0
  V1FldSum = 0
  V2Sum = 0
  V2EbbSum = 0
  V2FldSum = 0
  V3Sum = 0
  V4Sum = 0
  IndexVel = 0
  For BinVelCount = 1 To MaxBins
    VMBinVel(BinVelCount) = NAN
    VmBinVelDisable(BinVelCount) = False
  Next BinVelCount
  VelCount = 0 'Zero out VelCount variable
  '  If UseAutoLastBin = True Then
  '    EndBin = LastGoodBin
  '  EndIf
  If (BiRatOK = True) AND (BiRating = True) Then 'Ok the user wants a bi-directional rating and we are using a channel master (instrument coordinates)
    UseBiRat = True 'we can do it
  Else
    UseBiRat = False'we can't do it (or user doesn't want it
  EndIf
  TotBins = EndBin - StartBin
  'lets deterimine flow dir from V1 just in case we are using bi-rating
  MidBin = TotBins/2
  If V1(MidBin) > BiRatTran Then 'Calculate flow direction (CM) if using Ebb/Flood rating (only used for CM with Instrument velocities)
    EbbDir = true 'flow is positive
  Else
    EbbDir = false 'flow is negative
  EndIf
  For Cnt = StartBin To EndBin
    If (V1(Cnt) <> NAN) AND (V1(Cnt)>= MinExpVel) AND (V1(Cnt)<= MaxExpVel) 'its probably good
      V1Sum = V1Sum + V1(Cnt)
      V1Cnt = V1Cnt + 1
      If UseBiRat = true Then 'Ok we have a bi-directional rating
        If EbbDir Then 'flow is positive (ebb) use the EBB bins
          'Calc Ebb bin sum here
          If (Cnt >= StartEbbBin) AND (Cnt <= EndEbbBin) Then 'let's do this bin
            V1EbbSum += V1(Cnt)
            V1EbbCnt += 1
          EndIf 'if it's in range
        Else 'Ok it's Flood direction (negative)
          'Calc Fld bin sum here
          If (Cnt >= StartFldBin) AND (Cnt <= EndFldBin)Then 'lets do this one
            V1FldSum += V1(Cnt)
            V1FldCnt += 1
          EndIf 'if it's in-range
        EndIf 'direction
      EndIf 'if Birating
    Else
      BadBinCnt = BadBinCnt + 1
      V1(Cnt) = BadDataIndicator
    EndIf
  Next
  If V1Sum <> 0 Then
    V1AVG = V1Sum/V1Cnt 'Calculate normal V1
  Else
    V1AVG = 0
  EndIf
  If V1EbbSum <> 0 Then
    V1EbbAvg = V1EbbSum/V1EbbCnt 'Calculate Bi-rating Ebb bin average
  Else
    V1EbbAvg = 0
  EndIf
  If V1FldSum <> 0 Then
    V1FldAvg = V1FldSum/V1FldCnt 'Calculate Bi-rating Flood bin average
  Else
    V1FldAvg = 0
  EndIf
  For Cnt = StartBin To EndBin 'OK, in case we are using both X(V1) and Y(V2) velocities to calculate iVel then we have to calc V2 averages
    If (V2(Cnt) <> NAN) AND (V2(Cnt)>= MinExpVel) AND (V2(Cnt)<= MaxExpVel)
      V2Sum = V2Sum +  V2(Cnt) 'Calculate normal V2
      V2Cnt = V2Cnt + 1
      If UseBiRat = true Then 'Ok we have a bi-directional rating
        If EbbDir Then
          'Calc Ebb bin sum here
          If (Cnt >= StartEbbBin) AND (Cnt <= EndEbbBin) Then 'let's do this bin
            V2EbbSum += V2(Cnt)
            V2EbbCnt += 1
          EndIf 'if it's in range
        Else 'Ok it's Flood direction
          'Calc Fld bin sum here
          If (Cnt >= StartFldBin) AND (Cnt <= EndFldBin)Then 'ok let's do this bin
            V2FldSum += V2(Cnt)
            V2FldCnt += 1
          EndIf 'if it's in-range
        EndIf 'direction
      EndIf 'if Birating
    Else
      BadBinCnt = BadBinCnt + 1
      V2(Cnt) = BadDataIndicator
    EndIf
  Next
  If V2Sum <> 0 Then
    V2AVG =  V2Sum/V2Cnt 'Calculate normal V2
  Else
    V2AVG = 0
  EndIf
  If V2EbbSum <> 0 Then
    V2EbbAvg = V2EbbSum/V2EbbCnt 'Calculate Bi-rating Ebb bin average (V2)
  Else
    V2EbbAvg = 0
  EndIf
  If V2FldSum <> 0 Then
    V2FldAvg = V2FldSum/V2FldCnt  'Calculate Bi-rating Flood bin average (V2)
  Else
    V2FldAvg = 0
  EndIf
  For Cnt = StartBin To EndBin
    If (V3(Cnt) <> NAN) AND (V3(Cnt)>= MinExpVel) AND (V3(Cnt)<= MaxExpVel)
      V3Sum = V3Sum +  V3(Cnt)
      V3Cnt = V3Cnt + 1
    Else
      BadBinCnt = BadBinCnt + 1
      V3(Cnt) = BadDataIndicator
    EndIf
  Next
  If V3Sum <> 0 Then
    V3AVG =  V3Sum/V3Cnt
  Else
    V3AVG = 0
  EndIf
  For Cnt = StartBin To EndBin
    If (V4(Cnt) <> NAN) AND (V4(Cnt)>= MinExpVel) AND (V4(Cnt)<= MaxExpVel)
      V4Sum = V4Sum +  V4(Cnt)
      V4Cnt = V4Cnt + 1
    Else
      BadBinCnt = BadBinCnt + 1
      V4(Cnt) = BadDataIndicator
    EndIf
  Next
  If V4Sum <> 0 Then
    V4AVG =  V4Sum/V4Cnt
  Else
    V4AVG = 0
  EndIf

  If UseV2 = Yes Then
    If BiRating Then 'calculate proper direction
      If EbbDir Then
        IndexVel = SQR(V1EbbAvg^2 + V2EbbAvg^2) 'pos flow
      Else
        IndexVel = SQR(V1FldAvg^2 + V2FldAvg^2) 'neg flow
      EndIf
    Else
      IndexVel = SQR(V1AVG^2 + V2AVG^2)'reg calc
    EndIf 'birating = true
    For Cnt = 1 To MaxBins
      If (V1(Cnt)<> BadDataIndicator) AND (V2(Cnt)<> BadDataIndicator) Then
        VMBinVel(Cnt) = SQR (V1(Cnt)^2 + V2(Cnt)^2)
        If ((Cnt >= StartBin) AND (Cnt <= EndBin)) Then
          VelCount = VelCount + 1
        EndIf
      Else
        VMBinVel(Cnt) = BadDataIndicator
        VmBinVelDisable(Cnt) = True
      EndIf
    Next
  ElseIf UseDir = Yes Then
    IndexVel = (V1AVG * SIN(DegToRad * PosFlowDir)) + (V2AVG * COS(DegToRad * PosFlowDir))
    For Cnt = 1 To MaxBins
      If (V1(Cnt)<> BadDataIndicator) AND (V2(Cnt)<> BadDataIndicator) Then
        VMBinVel(Cnt) = (V1 * SIN(DegToRad * PosFlowDir)) + (V2 * COS(DegToRad * PosFlowDir))
        If ((Cnt >= StartBin) AND (Cnt <= EndBin)) Then
          VelCount = VelCount + 1
        EndIf
      Else
        VMBinVel(Cnt) = BadDataIndicator
        VmBinVelDisable(Cnt) = True
      EndIf
    Next
  Else 'just normal computation using V1
    If BiRating Then 'we're using Ebb and Flood
      If EbbDir Then
        IndexVel = V1EbbAvg
      Else 'if flood
        IndexVel = V1FldAvg
      EndIf
    Else 'bi-rating is false
      IndexVel = V1AVG
    EndIf
    For Cnt = 1 To MaxBins
      If V1(Cnt) <> BadDataIndicator Then
        VMBinVel(Cnt) = V1(Cnt)
        If ((Cnt >= StartBin) AND (Cnt <= EndBin)) Then
          VelCount = VelCount + 1
        EndIf
      Else
        VMBinVel(Cnt) = BadDataIndicator
        VmBinVelDisable(Cnt) = True
      EndIf
    Next
  EndIf
  If VelCount >=  EndBin - StartBin Then 'if VelCount < EndBin, then must have been some bad bins (allow one missing bin)
    BadVelFlag = No 'initialize flag to false again
    Call VelFilter 'call velocity filter
  Else 'if VelCount isn't close to number of bins, then
    BadVelFlag = Yes 'set flag to true
    IndexVel = BadDataIndicator
    BadVelCount = BadVelCount + 1
    '  VelLoop = 0 'initialize variable for Vel Filter below
  EndIf
  'now lets count the bad velocity bins to keep track of them
  BadBinCount = (((EndBin+1)-StartBin)- VelCount)
  'check for above and below rating for more than 60 readings if below 60 readings then reset flag
  If ((IndexVel<>BadVel) AND (IndexVel<LowRatVel)) Then 'Ok we are below the rating
    LowCount = LowCount + 1
  ElseIf ((IndexVel<>BadVel) AND (IndexVel>HighRatVel)) Then 'Ok we a above the rating
    HighCount = HighCount + 1
  Else
    If HighCount > 0 Then HighCount = HighCount - 1
    If LowCount > 0 Then LowCount = LowCount - 1
  EndIf
  If HighCount > 60 Then HighMeas = true
  If LowCount > 60 Then LowMeas = true
  'Call VelspikeAdd
EndSub

'___________________Reseting High/Low Measurement Flags___________________
'This code is used to resent the high/low measurement flags when someone changes the "HighRatVel" or "LowRatVel",
'indicating that someone has been out to measure during those velocities.
Sub ResetMeasFlags
  If HighRatVel <> InitialHRV Then 'if user changes upper velocity rating value
    InitialHRV = HighRatVel 'make "initial" equal to the new value
    HighMeas = False 'reset high flow measurment needed indicator to false
    HighCount = 0 'reset number of times high flow (above rated) occurs to 0
  EndIf
  If LowRatVel <> InitialLRV Then 'if user changes lower velocity rating value
    InitialLRV = LowRatVel 'make "initial" equal to the new value
    LowMeas = False 'reset low flow measurement needed indicator to false
    LowCount = 0 'reset number of times low flow occurs (below rated) to 0
  EndIf
EndSub

'_________________________________Velocity Filter_________________________________________
Sub VelFilter
  If IndexVel <> 0 OR BadDataIndicator Then 'if there is data, then probably good to go...
    If (IndexVel >= MinExpVel) AND (IndexVel <= MaxExpVel) Then 'if  Vel is in range, then
      BadVelFlag = False 'We have valid data but maybe it's a spike
    Else 'if vel not in range...
      BadVelFlag = Yes
      BadVelCount = BadVelCount + 1
      IndexVel = BadDataIndicator
      ExitSub 'dont pass out of range data through filter
    EndIf
  Else 'otherwise, if no data in buffer, or serial error then
    DataErr = DataErr + 1
    BadVelFlag = Yes
    BadVelCount = BadVelCount + 1
    IndexVel = BadDataIndicator
    ExitSub 'don't pass bad data through filter
  EndIf
EndSub

Sub VADCPTransform 'reverse the V1 and V2 components because the brilliant RDI guys have them reversed on the VADCP
  If IsVADCP = Yes Then
    Dim TempV1(MaxBins) As Float
    Dim TempV1Disable(MaxBins) As Boolean
    Dim TempV2(MaxBins) As Float
    Dim TempV2Disable(MaxBins) As Boolean
    Dim TempCounter As Long
    For TempCounter = 1 To MaxBins
      TempV2(TempCounter) = V1(TempCounter) 'copy them out
      tempV2disable(TempCounter) = V1Disable(TempCounter) 'have to switch out the disable booleans also
      TempV1(TempCounter) = V2(TempCounter)
      TempV1disable(TempCounter) = V2Disable(TempCounter)
      V2(TempCounter) = TempV2(TempCounter) 'put them back in the opposite array
      V2Disable(TempCounter) = TempV2disable(TempCounter)
      V1(TempCounter) = TempV1(TempCounter)
      V1Disable(TempCounter) = TempV1disable(TempCounter)
      'V1 should now be X velocity and V2, Y velocity when using a VADCP
    Next TempCounter
  EndIf
EndSub
Function Ftime (TimeIn As String * 25) As String * 25 'converts datalogger time string into MM/DD/YYYY HH:MM:SS
  'RawTime = Public.Timestamp

  SplitStr (FSplitTime(),TimeIn," ",6,0)
  Dim SendMonth As String
  Dim SendDay As String
  Dim SendHour As String
  Dim SendMin As String
  Dim SendSec As String
  Dim SendYear As String

  If FSplitTime(1) < 10 Then
    SendMonth = "0" + FSplitTime(1)
  Else
    SendMonth = FSplitTime(1)
  EndIf
  If FSplitTime(2) < 10 Then
    SendDay = "0" + FSplitTime(2)
  Else
    SendDay = FSplitTime(2)
  EndIf
  If FSplitTime(4) < 10 Then
    SendHour = "0" + FSplitTime(4)
  Else
    SendHour = FSplitTime(4)
  EndIf
  If FSplitTime(5) < 10 Then
    SendMin = "0" + FSplitTime(5)
  Else
    SendMin = FSplitTime(5)
  EndIf

  If Round(FSplitTime(6),0) < 10 Then
    SendSec = "0" + Round(FSplitTime(6),0)
  Else
    SendSec = Round(FSplitTime(6),0)
  EndIf
  SendYear = Right(FSplitTime(3),4)
  ftime = SendMonth + "/" + SendDay + "/" + SendYear + " " + SendHour + ":" + SendMin + ":" + SendSec
End Function
#If HasVM Then
  Sub CheckSpikes 'change name later
    'check the RSSI, Correlation, and velocity queues against incoming data for spikes.  Queues must be full before call
    'Outputs the spike data to a file on the Card.
    Dim BinCount As Long
    Dim BeamCount As Long
    Dim TimeOut As String * 25
    Dim RSSIStd As Float
    Dim RSSIAvg As Float
    Dim CorrStd As Float
    Dim CorrAvg As Float
    Dim VelStd As Float
    Dim DataLine As String * 500
    Dim velAvg As Float
    Dim Top As Float = 0
    Dim Bottom As Float = 0
    Dim QueueCorrSpikes As Long = 0
    Dim QueueRSSISpikes As Long = 0
    Dim QueueVelSpikes As Long = 0
    Dim RSSITemp(16) As Float
    Dim CorrTemp(16) As Float
    Dim VelTemp(16) As Float
    #If SeeAllVel = True Then
      Public Binspikes(MaxBins) As Long
      Public BinResults(2) As Long
    #Else
      Dim Binspikes(MaxBins) As Long
      Public BinResults(2) As Long
    #EndIf
    Dim n As Long
    'Dim QueueTotalSpikes As Long = 0
    Dim QueueAvgStage As Float = 0
    Dim QueueVel As Float = 0
    'Dim QueueAvgVel As Float = 0
    If InStr(1,Status.CardStatus,"No Card",2) = 0 Then 'if the cards not there no point in checking spikes
      SpikeFileName = "CRD:VmSpikes-" & SiteID & ".csv"
      FileHandle = FileOpen (SpikeFileName,"a+b",-1)'open the spike file here
      If SendHeader Then
        '---------------commented out for spike test
        'FileHeader = "Spike: ," & "Timestamp" & "," & "Type" & "," & "Value" & "," & "Bin" & "," & "Beam" & "," & "STD last 15" & "," & "Mean last 15" & "," & "Threshold (n*std)" & "," & "Ivel" & "," & "StagePrime"
        'write file header, otherwise just write to file below
        'FileWrite (FileHandle, FileHeader & CHR(13) & CHR(10),0)
        'DataLine = "Stats: ," & TimeOut & "," & "Ivel = " & IVel & "," & "StageAvg = " & QueueAvgStage & "," & "CorrSpikes = " & QueueCorrSpikes & "," & "RSSI Spikes = " & QueueRSSISpikes & "," & "Vel Spikes = " & QueueVelSpikes & "," & "DQI = " & QueueDQI
        'FileHeader = "Stats: ," & "Timestamp" & "," & "Ive" & "," & "Stage Avg" & "," & "Corr spikes" & "," & "RSSI Spikes" & "," & "Vel Spikes" & "," & "DQI = " & QueueDQI
        '-----------------------------------------------
        FileHeader = "Type," & "Timestamp," & "NumBeams," & "NumBins," & "StartBin,"& "EndBin,"& "BinSize," & "Ivel," & "Stage Avg,"& "Corr spikes," & "RSSI Spikes," & "Vel Spikes," & "DQI," & ">1 spikes," & "Bin"
        FileWrite (FileHandle, FileHeader & CHR(13) & CHR(10),0)
        SendHeader = False
      EndIf
      QueueCorrSpikes = 0
      QueueRSSISpikes = 0
      QueueVelSpikes = 0
      QueueAvgStage = 0
      QueueDQI = 0
      QueueVel = 0
      Erase Binspikes()
      ' Dim SampleCount As Long
      'should use startbin to endbin to eliminate unwanted spikes
      For BinCount = StartBin To EndBin
        For BeamCount = 1 To NumBeams
          Erase RSSITemp()
          Erase VelTemp()
          Erase CorrTemp()
          For n = 1 To 16
            RSSITemp(n) = RSSIspike(BinCount,BeamCount,n)
            Veltemp(n) = Velspike(BinCount,BeamCount,n)
            CorrTemp(n)= Corrspike(BinCount,BeamCount,n)
          Next n
          'StdDevSpa(RSSIStd,15,RSSIspike(BinCount,BeamCount,1) 'compute standard deviation of RSSI Queue
          StdDevSpa(RSSIStd,15,rssitemp(1))
          If RSSIStd = 0 Then RSSIStd = 0.1 'set to minimum if zero
          'AvgSpa(RSSIAvg,15,RSSIspike(BinCount,BeamCount,1)
          AvgSpa(RSSIAvg,15,RSSITemp(1))
          Top = RSSIAvg + (RSSIStd * RSSIStdNo)
          Bottom = RSSIAvg - (RSSIStd * RSSIStdNo)
          If (ensRSSI(BinCount,BeamCount) < Bottom) OR (ensRSSI(BinCount,BeamCount) > Top) Then
            SpikeCounter = SpikeCounter + 1
            Binspikes(BinCount) = Binspikes(BinCount) + 1
            QueueRSSISpikes = QueueRSSISpikes + 1
            TimeOut = Ftime(Public.Timestamp)
            TestTime = TimeOut
            'commented out for spike test-----------------------------------------
            'DataLine = "Spike: ," & TimeOut & "," & "RSSI" & "," & ensRSSI(BinCount,BeamCount) & "," & BinCount & "," & BeamCount & "," & Round(RSSIStd,2) & "," & Round(RSSIAvg,2) & "," & RSSIStdNo & "," & Round(iVel,3) & "," & Round(StagePrime,2)
            'FileWrite (FileHandle,DataLine & CHR(13) & CHR(10),0)
          EndIf
          'StdDevSpa(CorrStd,15,Corrspike(BinCount,BeamCount,1) 'compute standard deviation of Correlation Queue
          StdDevSpa(CorrStd,15,corrtemp(1))
          If CorrStd = 0 Then CorrStd = 0.1 'set to minimum if zero
          'AvgSpa(CorrAvg,15,Corrspike(BinCount,BeamCount,1)
          AvgSpa(CorrAvg,15,CorrTemp(1))
          Top = CorrAvg + (CorrStd * CorrStdNo)
          Bottom = CorrAvg - (CorrStd * CorrStdNo)
          If (ensCorr(BinCount,BeamCount) < Bottom) OR (ensCorr(BinCount,BeamCount) > Top) Then
            SpikeCounter = SpikeCounter + 1
            Binspikes(BinCount) = Binspikes(BinCount) + 1
            QueueCorrSpikes = QueueCorrSpikes + 1
            TimeOut = Ftime(Public.Timestamp)
            'commented out for spike test----------------------------------------
            'DataLine = "Spike: ," & TimeOut & "," & "Corr" & "," & ensCorr(BinCount,BeamCount) & "," & BinCount & "," & BeamCount & "," & Round(CorrStd,2) & "," & Round(CorrAvg,2) & "," & CorrStdNo & "," & Round(iVel,3) & "," & Round(StagePrime,2)
            'FileWrite (FileHandle,DataLine & CHR(13) & CHR(10),0)
          EndIf
          StdDevSpa(VelStd,15,veltemp(1))
          If VelStd = 0 Then VelStd = .1
          'AvgSpa(velAvg,15,Velspike(BinCount,BeamCount,1) 'Velocity average for Queue
          AvgSpa(velAvg,15,veltemp(1))
          Top = velAvg + (VelStd * VelStdNo)
          Bottom = velAvg - (VelStd * VelStdNo)
          If (ensVelocity(BinCount,BeamCount) < Bottom) OR (ensVelocity(BinCount,BeamCount) > Top) Then
            'for future use, we can set the disable variables here, but we need to call this before calling the velocity output table
            SpikeCounter = SpikeCounter + 1
            Binspikes(BinCount) = Binspikes(BinCount) + 1
            QueueVelSpikes = QueueVelSpikes + 1
            TimeOut = Ftime(Public.Timestamp)
            'commented out for spike test------------------------------------------------
            'DataLine = "Spike: ," & TimeOut & "," & "Velocity" & "," & Round(ensVelocity(BinCount,BeamCount),2) & "," & BinCount & "," & BeamCount & "," & Round(VelStd,2) & "," & Round(velAvg,2) & "," & VelStdNo & "," & Round(iVel,3) & "," & Round(StagePrime,2)
            'FileWrite (FileHandle,DataLine & CHR(13) & CHR(10),0)
          EndIf
          'StdDevSpa(VelStd,15,Velspike(BinCount,BeamCount,1) 'compute standard deviation of Velocity Queue

          'need to output Velocity average here every 15 mins regardless of spikes to provide a velocity scale for visualization
        Next BeamCount
      Next BinCount
      QueueDQI = (QueueCorrSpikes + QueueRSSISpikes + QueueVelSpikes)/15 'number of ensembles per period
      QueueDQI = Round(QueueDQI,2)
      velAvg = Round(velAvg,2)
      AvgSpa(QueueAvgStage,15,StageSpike(1)
      QueueAvgStage = Round(QueueAvgStage,2)
      QueueVel = Round(IndexVel,2)
      TimeOut = Ftime(Public.Timestamp)
      MaxSpa(BinResults(),MaxBins,Binspikes())
      If BinResults(1) < 2 Then
        BinResults(1) = 0
        BinResults(2) = 0
      EndIf
      'DataLine = "Stats: ," & TimeOut & "," & velAvg & "," & QueueAvgStage & "," & QueueCorrSpikes & "," & QueueRSSISpikes & "," & QueueVelSpikes & "," & QueueDQI
      DataLine = "Stats: ," & TimeOut & "," & NumBeams & "," & Numbins & "," & StartBin & "," & EndBin & "," & BinSize & ","& QueueVel & "," & QueueAvgStage & "," & QueueCorrSpikes & "," & QueueRSSISpikes & "," & QueueVelSpikes & "," & QueueDQI & "," & BinResults(1) & "," & BinResults(2)
      FileWrite (FileHandle,DataLine & CHR(13) & CHR(10),0)
      FileClose(FileHandle)
    EndIf
    CardError = Status.CardStatus
  End Sub

#EndIf 'if hasvm
'----------------------------------------------------------------------------
'add spikes to correlation,RSSI and Velocity fifo Queues and advance to next queue position. Note: call after checkspikes
'---------------------------------------Sub AddSpikes-------------------------------------------------------------------
#If HasVM Then
  Sub AddSpikes
    Dim BinCount As Long
    Dim BeamCount As Long
    Dim SampleCount As Long
    If BadVelFlag Then Exit Sub
    For BinCount = 1 To Numbins 'get all bins for storage
      For BeamCount = 1 To NumBeams
        Corrspike(BinCount,BeamCount,16) = ensCorr(BinCount,BeamCount) 'add new to end
        RSSIspike(BinCount,BeamCount,16) = ensRSSI(BinCount,BeamCount) 'add new to end
        Velspike(BinCount,BeamCount,16) = ensVelocity(BinCount,BeamCount) 'add new to end
        For SampleCount = 1 To 15
          'Jack out first and copy in last
          Corrspike(BinCount,BeamCount,SampleCount) = Corrspike(BinCount,BeamCount,SampleCount + 1)
          RSSIspike(BinCount,BeamCount,SampleCount)=RSSIspike(BinCount,BeamCount,SampleCount + 1)
          Velspike(BinCount,BeamCount,SampleCount) = Velspike(BinCount,BeamCount,SampleCount + 1)
        Next SampleCount
      Next BeamCount
    Next BinCount
    'add stage to stagespike queue
    StageSpike(16) = StagePrime
    For SampleCount = 1 To 15
      StageSpike(SampleCount) = StageSpike(SampleCount + 1)
    Next SampleCount
  End Sub
#EndIf

'--------------Store all 1 minute data to Card ----------------------------------------------
#If (StoreAllToCard = true) AND HasVM Then
  Sub StoreAllData
    Dim CorrDataLine As String * 1000
    Dim VelDataLine As String * 1000
    Dim RSSIDataLine As String * 1000
    Dim BeamCount As Long
    Dim BinCount As Long
    If InStr(1,Status.CardStatus,"Card OK.",2) = 0 Then 'if the cards not there no point in checking spikes
      CardBadCount = CardBadCount + 1
      ExitSub
    Else
      CardOkCount = CardOkCount + 1
      SpikeFileName = "CRD:VmSpikes-" & SiteID & ".csv"
      FileHandle = FileOpen (SpikeFileName,"a+b",-1)'open the spike file here
      'compose dataline and write here.
      For BeamCount = 1 To NumBeams
        Erase CorrDataLine
        Erase VelDataLine
        Erase RSSIDataLine
        CorrDataLine = CorrDataLine & "Corr: ," & BeamCount
        VelDataLine = VelDataLine & "Velocity: ," & BeamCount
        RSSIDataLine = RSSIDataLine & "RSSI: ," & BeamCount
        For BinCount = 1 To Numbins
          CorrDataLine = CorrDataLine & "," & ensCorr(BinCount,BeamCount)
          VelDataLine = VelDataLine & "," & Round(ensVelocity(BinCount,BeamCount),3)
          RSSIDataLine = RSSIDataLine & "," & ensRSSI(BinCount,BeamCount)
        Next BinCount
        FileWrite (FileHandle,RSSIDataLine & CHR(13) & CHR(10),0)
        FileWrite (FileHandle,CorrDataLine & CHR(13) & CHR(10),0)
        FileWrite (FileHandle,VelDataLine & CHR(13) & CHR(10),0)
      Next BeamCount
      FileClose(FileHandle)
    EndIf
    CardError = Status.CardStatus
  End Sub
#EndIf
'__________________________________Calculate Q Subroutine_________________________________
Sub SubCalcQ 'calculate discharge
  If CalcQ = Yes Then ' if Q calculations are wanted
    If Trans = BadDataIndicator Then 'if there is no valid transition point
      'then use standard velocity rating info for meanvel calculation
      MeanVel = VelOffset + (VelCoef * IndexVel) + (VelCoef2 * IndexVel^2) + (VelCoef3 * IndexVel^3)
    Else 'if there is a valid transition point
      If IndexVel >= Trans Then 'if iVel is greater or equal to the transition point
        'then use upper meanvel rating information
        MeanVel = UpVelOffset + (UpVelCoef * IndexVel) + (UpVelCoef2 * IndexVel^2) + (UpVelCoef3 * IndexVel^3)
      ElseIf IndexVel <= Trans Then 'if iVel is less than the transition point
        'then use lower meanvel rating information
        MeanVel = LowVelOffset + (LowVelCoef * IndexVel) + (LowVelCoef2 * IndexVel^2) + (LowVelCoef3 * IndexVel^3)
      EndIf
    EndIf
    If BadVelFlag = False AND  BadStgFlag = False Then 'Ok, now if both iVel and Stage are still good, then
      BadQFlag = False 'then Q data is still good
      'user enters rating values with keypad
      Area = StgOffset + (StgCoef*StagePrime) + (StgCoef2 * StagePrime^2)
      'check to see if iVel data is good
      Qcfs = Area * MeanVel 'calculate Q
      If Qcfs = 0 Then 'if calculated Q is exactly zero
        'then don't believe it (probably no rating data entered)
        BadQFlag = True 'Q data is now bad, so don't average it
        BadQCount = BadQCount + 1 'Q is now bad
        Qcfs = BadDataIndicator
      EndIf
    Else 'if stage or velocity were bad, then
      BadQFlag = True 'Q data is now bad, so don't average it
      BadQCount = BadQCount + 1 'and increment counter
      Qcfs = BadDataIndicator
    EndIf
  Else ' if Q calculations are not wanted (CalcQ = no)
    BadQCount = 0
    Area = NAN
    MeanVel = NAN
    Qcfs = 0
    BadQFlag = True
  EndIf
EndSub

'____________________________________Zero all Velocity Meter Arrays__________________________
#If HasVM = True Then
  Sub ZeroVMArrays
    Dim ZeroCounter As Long
    'Zero The raw data array
    Erase (Longarray())
    'Zero the bin velocity arrays
    For Bin = 1 To MaxBins
      For Beam = 1 To MaxBeams
        ensVelocity(Bin,Beam) = Nan
      Next Beam
    Next Bin
    For ZeroCounter = 1 To MaxBins
      V1(ZeroCounter) = Nan
      V2(ZeroCounter) = Nan
      VMBinVel(ZeroCounter) = Nan
    Next ZeroCounter
    IndexVel = NaN
    '  For Bin = 1 To MaxBins
    '    For Beam = 1 To MaxBeams
    '      ensCorr(Bin,Beam) = 0
    '    Next Beam
    '    AvgCorr(Bin) = 0
    '  Next Bin
    Erase (ensCorr())
    '  For Bin = 1 To MaxBins
    '    For Beam = 1 To MaxBeams
    '      ensRSSI(Bin,Beam) = 0
    '    Next Beam
    '    AvgRSSI(Bin) = 0
    '  Next Bin
    Erase (AvgRSSI())
    Erase Velspike()
    Erase RSSIspike()
    Erase Corrspike()
  EndSub
#EndIf
'----------------------------------------------------
'Read variables in from USR file (preserved variables)
Sub ReadVariables
  Public PreserveHandle As Long
  Public PreserveFileLen As Long
  Public Closeerror
  PreserveHandle = FileOpen("USR:VariableStore.txt","r",-1) 'open the preserve variable file here
  Delay (1,30,mSec)
  PreserveFileLen = FileRead(PreserveHandle,PreserveFile,500)
  Closeerror = FileClose(PreserveHandle)
  If PreserveFileLen = 0 Then
    '    'set error txt
    ExitSub
  EndIf
  Dim InVar(41) As String
  SplitStr(InVar,PreserveFile,",",41,0)
  StartBin = InVar(1)
  EndBin = InVar(2)
  StartEbbBin = InVar(3)
  EndEbbBin = InVar(4)
  StartFldBin = InVar(5)
  EndFldBin = InVar(6)
  BiRating = InVar(7)
  BiRatTran = InVar(8)
  LowRatVel = InVar(9)
  HighRatVel = InVar(10)
  SelStgPrime = InVar(11)
  SelStgSecnd = InVar(12)
  UpBeamOffset = InVar(13)
  VMPressOffset = InVar(14)
  PS1Offset = InVar(15)
  PS2Offset = InVar(16)
  SondeOffset = InVar(17)
  CalcQ = InVar(18)
  StgOffset = InVar(19)
  StgCoef = InVar(20)
  StgCoef2 = InVar(21)
  VelOffset = InVar(22)
  VelCoef = InVar(23)
  VelCoef2 = InVar(24)
  VelCoef3 = InVar(25)
  UpVelOffset = InVar(26)
  UpVelCoef = InVar(27)
  UpVelCoef2 = InVar(28)
  UpVelCoef3 = InVar(29)
  LowVelOffset = InVar(30)
  LowVelCoef = InVar(31)
  LowVelCoef2 = InVar(32)
  LowVelCoef3 = InVar(33)
  RangeSource = InVar(34)
  DucerDepthOffset = InVar(35)
  IsSubmersed = InVar(36)
  IsWQNClosed = InVar(37)
  isVMNClosed = InVar(38)
  BurstPeriod = InVar(39)
  OneMinConsistent= InVar(40) 'if you want constant 1min data this will keep it on in case of power cycle
  FlowSign = InVar(41)
EndSub

'Store Variables to USR File (preserve variables)
'--------------------------------------------------
Sub StoreVariables
  'store variables out
  Dim Var(41) As String
  Public SendVarString As String * 500
  Public VarStringLen As Long
  Public VarHandle = Long
  Public Varbytes = Long
  Public StoreCloseErr As Long
  Dim VarCnt As Long
  Var(1) = StartBin
  Var(2) = EndBin
  Var(3) = StartEbbBin
  Var(4) = EndEbbBin
  Var(5) = StartFldBin
  Var(6) = EndFldBin
  Var(7) = BiRating
  Var(8) = BiRatTran
  Var(9) = LowRatVel
  Var(10) = HighRatVel
  Var(11) = SelStgPrime
  Var(12) = SelStgSecnd
  Var(13) = UpBeamOffset
  Var(14) = VMPressOffset
  Var(15) = PS1Offset
  Var(16) = PS2Offset
  Var(17) = SondeOffset
  Var(18) = CalcQ
  Var(19) = StgOffset
  Var(20) = StgCoef
  Var(21) = StgCoef2
  Var(22) = VelOffset
  Var(23) = VelCoef
  Var(24) = VelCoef2
  Var(25) = VelCoef3
  Var(26) = UpVelOffset
  Var(27) = UpVelCoef
  Var(28) = UpVelCoef2
  Var(29) = UpVelCoef3
  Var(30) = LowVelOffset
  Var(31) = LowVelCoef
  Var(32) = LowVelCoef2
  Var(33) = LowVelCoef3
  Var(34) = RangeSource
  Var(35) = DucerDepthOffset
  Var(36) = IsSubmersed
  Var(37) = IsWQNClosed
  Var(38) = isVMNClosed
  Var(39) = BurstPeriod
  Var(40) = OneMinConsistent
  Var(41) = FlowSign
  'build send string
  SendVarString = Var(1)
  For VarCnt = 2 To 41
    SendVarString = SendVarString + "," + Var(VarCnt)
  Next VarCnt
  VarStringLen = Len(SendVarString)
  VarHandle = FileOpen("USR:VariableStore.txt","w",-1)
  Delay(1,100,mSec)
  Varbytes = FileWrite(VarHandle,SendVarString,VarStringLen + 50)
  StoreCloseErr = FileClose(VarHandle)
  StoreVariablesFlg = False
EndSub

'_______________________________________________________Calculate a Checksum for the ensemble and extract ensemble checksum ____________________________________
#If HasVM = True Then
  Sub ChecksumCheck
    'Get ensemble length (from the header)
    Dim CkSumCount As Long
    LSB = Longarray(3)
    MSB = Longarray(4)
    EnsembleLen = LSB + (MSB*256)
    'calculate checksum here to see if it matches the checksum sent by the ADCP
    CalcCheckSum = 0
    CkSumCount = 0
    For CkSumCount = 1 To EnsembleLen
      CalcCheckSum = CalcCheckSum + Longarray(CkSumCount)
    Next CkSumCount
    CalcCheckSum = 65535 AND CalcCheckSum
    EnsChecksum = Longarray(CkSumCount)
    TempL = Longarray(CkSumCount + 1)
    EnsChecksum = EnsChecksum + TempL * 256
  EndSub
#EndIf

'_____________________________________Zero Counters___________________________________________________________
Sub ZeroErrCounters
  BadBinCnt = 0
  BadEnsemble = 0
  BadEnsCount = 0
  VMRestartAttempts = 0
  BadStgCount = 0 'initialize bad stage counter
  #If WqSonde <> "NONE" Then
    WqPwrCycleCnt = 0 'set counter to zero at midnight
  #EndIf
  BadQCount = 0
  BadVelCount = 0 'initialize counter
  EventVoltFlag  = No ' reset the catastrophic event flags
  EventYSIFlag  = No
  EventQFlag  = No
  EventCDMAFlag = No
  CDMAFailure = No
  NewADCP = False
  NewPS1 = False
  NewPS2 = False
EndSub

#If RadioNetwork = True Then
  '__________________________READ IN CURRENT SETTINGS OF RADIO_______________________
  Sub ReadRF
    RadOn = Settings.RadioEnable
    RadOpMode = Settings.RadioOpMode
    RadFreqKey = Settings.RadioFreqKey
    RadMaxPacket = Settings.RadioMaxPacket
    RadMinPacket = Settings.RadioMinPacket
    RadDataRate = Settings.RadioDataRate
    RadTxPwr = Settings.RadioTxPwr
    RadRetryTO = Settings.RadioRetryTimeout
    RadLowPwr = Settings.RadioLowPwr
    RadRepeaters = Settings.RadioRepeaters
    RadPacketRepeat = Settings.RadioPacketRepeat
    RadSlaveRetry = Settings.RadioSlaveRetry
    RadFreqRepeat = Settings.RadioFreqRepeat
    RadSlaveRepeat = Settings.RadioSlaveRepeat
    RadRxSubID = Settings.RadioRxSubID
    RadTxSubID = Settings.RadioTxSubID
    RadNetID = Settings.RadioNetID
    ReadRadSettings = False
  EndSub

  '_________________________STORE THE SETTINGS TO USR DRIVE BASED ON THE ABOVE SUBROUTINE VARIABLES___________________
  Sub StoreRadSettings
    Public RadVar(17) As String 'establish a placeholder array
    Public SendRadSetString As String * 256 'create a string that will be used to send to the USR drive
    Public RadStringLen As Long 'length of string being stored
    Public RadVarHandle As Long 'short name to be used in opening/reading/writing the User Radio Settings
    Public RadVarBytes As Long 'number of bytes successfully written to file
    Public StoreRadCloseErr 'variable to store whether file closure was a success or not. 0 = success, -1 = FileHandle referenced is not valid or if file was not previously opened/is already closed.
    Public RadVarCnt As Long 'counter to establish number of times For To loop needs to continue
    RadVar(1) = RadOn 'assign each value in RadVar() to a variable previously read in in the ReadRF subroutine
    RadVar(2) = RadOpMode
    RadVar(3) = RadFreqKey
    RadVar(4) = RadMaxPacket
    RadVar(5) = RadMinPacket
    RadVar(6) = RadDataRate
    RadVar(7) = RadTxPwr
    RadVar(8) = RadRetryTO
    RadVar(9) = RadLowPwr
    RadVar(10) = RadRepeaters
    RadVar(11) = RadPacketRepeat
    RadVar(12) = RadSlaveRetry
    RadVar(13) = RadFreqRepeat
    RadVar(14) = RadSlaveRepeat
    RadVar(15) = RadRxSubID
    RadVar(16) = RadTxSubID
    RadVar(17) = RadNetID
    SendRadSetString = RadVar(1) 'start writing the string out starting with the first value in the array
    For RadVarCnt = 2 To 17 'from RadVar(2) through RadVar(n) build the string using For To Next Loop
      SendRadSetString = SendRadSetString + "," + RadVar(RadVarCnt) 'SendRadSetString gets built using a comma for a delimiter for the entire length of the array
    Next RadVarCnt 'move to next variable in array until string is complete
    RadStringLen = Len(SendRadSetString) 'Len returns the length of the string in bytes
    RadVarHandle = FileOpen("USR:UserRadSettings.txt","w",-1) 'Establish the "FileHandle" by opening (or creating if first open call) the file "UserRadSettings.txt" in the USR drive.
    Delay (1,100,msec) 'delay processing to make sure file was opened
    RadVarBytes = FileWrite (RadVarHandle,SendRadSetString,RadStringLen + 15) 'record how many bytes were written to file. Added 15 bytes to the expected length to make sure nothing gets missed
    StoreRadCloseErr = FileClose(RadVarHandle) 'close the file, return whether closure was successful
  EndSub
  'EndSub




  '_______________________RESET RADIO TO FACTORY DEFAULT SETTINGS_______________________
  '__________Factory setting for RadioEnabled is True (On). I turn it off, as the purpose of this is to essentially reboot the radio system
  Sub ResetRadDefault
    SetSetting("RadioEnable",DefRadOn) 'SetSetting for the settings in quotes based on the Const values establish in variable declarations, Ex: DefRadOn = 0, DefOpMode = 2, etc.)
    SetSetting("RadioOpMode",DefOpMode)
    SetSetting("RadioFreqKey",DefFreqKey)
    SetSetting("RadioMaxPacket",DefMaxPacket)
    SetSetting("RadioMinPacket",DefMinPacket)
    SetSetting("RadioDataRate",DefDataRate)
    SetSetting("RadioTxPwr",DefTxPwr)
    SetSetting("RadioRetryTimeout",DefRetryTO)
    SetSetting("RadioLowPwr",DefLowPwr)
    SetSetting("RadioRepeaters",DefRepeaters)
    SetSetting("RadioPacketRepeat",DefPacketRepeat)
    SetSetting("RadioSlaveRetry",DefSlaveRetry)
    SetSetting("RadioFreqRepeat",DefFreqRepeat)
    SetSetting("RadioSlaveRepeat",DefSlaveRepeat)
    SetSetting("RadioRxSubID",DefRxSubID)
    SetSetting("RadioTxSubID",DefTxSubID)
    SetSetting("RadioNetID",DefNetID)
  EndSub

  '_________________________RESET RADIO BACK TO USER SETTINGS PREVIOUSLY STORED IN USR______________________
  '
  Sub SetRadSetting
    'Set Radio Settings to User settings from USR Drive
    Public UserRadSettings As String * 60 'Variable to store settings string from USR
    Public SetRadHandle As Long 'FileHandle of the "UserRadSettings.txt"
    Public SetRadFileLen As Long 'Length of the user settings file in bytes
    Public SetCloseErr 'If the file was closed successfully or not. 0 = successful, -1 = FileHandle not valid or handle was not opened
    Public RadFileClosure As String * 26 'Text to let User know whether reading settings was successful or not (based on number of bytes)
    SetRadHandle = FileOpen("USR:UserRadSettings.txt","r",-1) 'open saved user settings for radio
    Delay (1,30,mSec) 'delay processing
    SetRadFileLen = FileRead(SetRadHandle,UserRadSettings,500) 'read in the file, store it to the variable "UserRadSettings"
    SetCloseErr = FileClose(SetRadHandle) 'indicate whether the closure was successful
    If SetRadFileLen = 0 Then 'if FileLength = 0
      RadFileClosure = "Error: Settings not found!" 'Show text to user
      SetRadSettings = False 'Don't set radio settings
      ExitSub 'exit the subroutine
    EndIf
    Public InRadVar(17) As String 'create array to store the values from string once it's split
    SplitStr(InRadVar,UserRadSettings,",",17,0) 'split the "UserRadSettings" string into InRadVar(), comma delimited, n array size
    RadOn = InRadVar(1) 'fill each variable with appropriate value from array
    RadOpMode = InRadVar(2)
    RadFreqKey = InRadVar(3)
    RadMaxPacket = InRadVar(4)
    RadMinPacket = InRadVar(5)
    RadDataRate = InRadVar(6)
    RadTxPwr = InRadVar(7)
    RadRetryTO = InRadVar(8)
    RadLowPwr = InRadVar(9)
    RadRepeaters = InRadVar(10)
    RadPacketRepeat = InRadVar(11)
    RadSlaveRetry = InRadVar(12)
    RadFreqRepeat = InRadVar(13)
    RadSlaveRepeat = InRadVar(14)
    RadRxSubID = InRadVar(15)
    RadTxSubID = InRadVar(16)
    RadNetID = InRadVar(17)
    SetSetting("RadioEnable",RadOn) 'now, SetSetting to set the radio to the settings read in from USR
    SetSetting("RadioOpMode",RadOpMode)
    SetSetting("RadioFreqKey",RadFreqKey)
    SetSetting("RadioMaxPacket",RadMaxPacket)
    SetSetting("RadioMinPacket",RadMinPacket)
    SetSetting("RadioDataRate",RadDataRate)
    SetSetting("RadioTxPwr",RadTxPwr)
    SetSetting("RadioRetryTimeout",RadRetryTO)
    SetSetting("RadioLowPwr",RadLowPwr)
    SetSetting("RadioRepeaters",RadRepeaters)
    SetSetting("RadioPacketRepeat",RadPacketRepeat)
    SetSetting("RadioSlaveRetry",RadSlaveRetry)
    SetSetting("RadioFreqRepeat",RadFreqRepeat)
    SetSetting("RadioSlaveRepeat",RadSlaveRepeat)
    SetSetting("RadioRxSubID",RadRxSubID)
    SetSetting("RadioTxSubID",RadTxSubID)
    SetSetting("RadioNetID",RadNetID)
    SetRadSettings = False 'turn off flag
  EndSub

  '_____________________________Establish means of verifying successful communication

  #If IsMaster = True Then 'if it's the master in the network
    Sub CheckLinks 'follow this subroutine
      SendToNetwork = SendToNetwork + 1 'placeholder variable used to send to slave loggers
      If SendToNetwork >= 150 Then 'count to 150
        SendToNetwork = 0 'then reset (arbitrary numbers)
      EndIf
      #If NetworkSlaves = 1 Then 'if there's one slave in the network
        SendVariables (SendToAresult,COMRF,-1,NeighborApb,NeighborASecCode,0,"Public","MasterReceive",SendToNetwork,1) 'send "SendToNetwork Variable to Node "A".
        If SendToAresult <> 0 Then 'Result from above, 0 = successful comms, non-0 = failure of some sort.
          SendToAFailCnt = SendToAFailCnt + 1 'if comms failed, count up
        Else 'if comms successful
          SendToAFailCnt = 0 'reset counter
          LinkToAdead = False 'set "Dead" flag to false
          ResetMaster = False 'don't set flag to reset the radio
          RadResetAttempts = 0 'Set reset attempt counter back to 0
        EndIf
        If SendToAFailCnt >= MaxAFails 'if fail counter exceeds threshold
          LinkToAdead = True 'all links are dead
          ResetMaster = True 'set reset flag
          SendToAFailCnt = 0 'reset counter to 0, use counter to make sure radio doesn't continually attempt to reset once the link is considered dead
        EndIf
      #EndIf
      #If NetworkSlaves = 2 Then 'if 2 slaves in the network, see comments above
        SendVariables (SendToAresult,COMRF,-1,NeighborApb,NeighborASecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave A
        If SendToAresult <> 0 Then
          SendToAFailCnt = SendToAFailCnt + 1
          RadResetAttempts = 0
        Else
          SendToAFailCnt = 0
          LinkToAdead = False
          ResetMaster = False 'don't set flag to reset the radio
        EndIf
        If SendToAFailCnt >= MaxAFails
          LinkToAdead = True
          SendToAFailCnt = 0
        EndIf
        SendVariables (SendToBresult,COMRF,-1,NeighborBpb,NeighborBSecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave B
        If SendToBresult <> 0 Then
          SendToBFailCnt = SendToBFailCnt + 1
        Else
          SendToBFailCnt = 0
          LinkToBdead = False
          ResetMaster = False 'don't set flag to reset the radio
          RadResetAttempts = 0
        EndIf
        If SendToBFailCnt >= MaxBFails
          LinkToBdead = True
        EndIf
        If LinkToAdead AND LinkToBdead Then 'only count towards fails if BOTH links are dead, something may be wrong with master.
          AllLinksDead = AllLinksDead + 1 'counter for how many times both links are dead
          If AllLinksDead >= MaxLinksDeadCnt Then 'if counter exceeds threshold
            ResetMaster = True 'set flag to reset master
            SendToAFailCnt = 0 'reset the counter for each slave
            SendToBFailCnt = 0
            AllLinksDead = 0 'reset the "AllLinksDead" counter
          EndIf
        #EndIf
        #If NetworkSlaves = 3 Then 'if 3 slaves in network
          SendVariables (SendToAresult,COMRF,-1,NeighborApb,NeighborASecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave A
          If SendToAresult <> 0 Then
            SendToAFailCnt = SendToAFailCnt + 1
          Else
            SendToAFailCnt = 0
            LinkToAdead = False
            ResetMaster = False 'don't set flag to reset the radio
            RadResetAttempts = 0
          EndIf
          If SendToAFailCnt >= MaxAFails
            LinkToAdead = True
          EndIf
          SendVariables (SendToBresult,COMRF,-1,NeighborBpb,NeighborBSecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave B
          If SendToBresult <> 0 Then
            SendToBFailCnt = SendToBFailCnt + 1
          Else
            SendToBFailCnt = 0
            LinkToBdead = False
            ResetMaster = False 'don't set flag to reset the radio
            RadResetAttempts = 0
          EndIf
          If SendToBFailCnt >= MaxBFails
            LinkToBdead = True
          EndIf
          SendVariables (SendToCresult,COMRF,-1,NeighborCpb,NeighborCSecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave C
          If SendToCresult <> 0 Then
            SendToCFailCnt = SendToCFailCnt + 1
          Else
            SendToCFailCnt = 0
            LinkToCdead = False
            ResetMaster = False 'don't set flag to reset the radio
            RadResetAttempts = 0
          EndIf
          If SendToCFailCnt >= MaxCFails
            LinkToCdead = True
          EndIf
          If LinkToAdead AND LinkToBdead AND LinkToCdead Then 'only count towards fails if ALL links are dead, something may be wrong with master.
            AllLinksDead = AllLinksDead + 1
            If AllLinksDead >= MaxLinksDeadCnt Then
              ResetMaster = True
              SendToAFailCnt = 0
              SendToBFailCnt = 0
              SendToCFailCnt = 0
              AllLinksDead = 0
            EndIf
          #EndIf
          #If NetworkSlaves = 4 Then '4 slaves in network
            SendVariables (SendToAresult,COMRF,-1,NeighborApb,NeighborASecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave A
            If SendToAresult <> 0 Then
              SendToAFailCnt = SendToAFailCnt + 1
            Else
              SendToAFailCnt = 0
              LinkToAdead = False
              ResetMaster = False 'don't set flag to reset the radio
              RadResetAttempts = 0
            EndIf
            If SendToAFailCnt >= MaxAFails
              LinkToAdead = True
            EndIf
            SendVariables (SendToBresult,COMRF,-1,NeighborBpb,NeighborBSecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave B
            If SendToBresult <> 0 Then
              SendToBFailCnt = SendToBFailCnt + 1
            Else
              SendToBFailCnt = 0
              LinkToBdead = False
              ResetMaster = False 'don't set flag to reset the radio
              RadResetAttempts = 0
            EndIf
            If SendToBFailCnt >= MaxBFails
              LinkToBdead = True
            EndIf
            SendVariables (SendToCresult,COMRF,-1,NeighborCpb,NeighborCSecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave C
            If SendToCresult <> 0 Then
              SendToCFailCnt = SendToCFailCnt + 1
            Else
              SendToCFailCnt = 0
              LinkToCdead = False
              ResetMaster = False 'don't set flag to reset the radio
              RadResetAttempts = 0
            EndIf
            If SendToCFailCnt >= MaxCFails
              LinkToCdead = True
            EndIf
            SendVariables (SendToDresult,COMRF,-1,NeighborDpb,NeighborDSecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave D
            If SendToDresult <> 0 Then
              SendToDFailCnt = SendToDFailCnt + 1
            Else
              SendToDFailCnt = 0
              LinkToDdead = False
              ResetMaster = False 'don't set flag to reset the radio
              RadResetAttempts = 0
            EndIf
            If SendToDFailCnt >= MaxDFails
              LinkToDdead = True
            EndIf
            If LinkToAdead AND LinkToBdead AND LinkToCdead AND LinkToDdead Then 'only count towards fails if ALL links are dead, something may be wrong with master.
              AllLinksDead = AllLinksDead + 1
              If AllLinksDead >= MaxLinksDeadCnt Then
                ResetMaster = True
                SendToAFailCnt = 0
                SendToBFailCnt = 0
                SendToCFailCnt = 0
                SendToDFailCnt = 0
                AllLinksDead = 0
              EndIf
            EndIf
          #EndIf
        EndIf
      EndSub
    #EndIf

    #If IsMaster = False Then 'if it's in a radio network, but not the master
      Sub CheckSlaveLink 'subroutine to run if it's a slave
        GetVariables (GetResult,COMRF,-1,MasterPB,MasterSecCode,0,"Public","SendToNetwork",MasterReceive,1) 'GetVariable "SendToNetwork" from master, store in MasterReceive
        If GetResult <> 0 Then 'if GetVariables was NOT successful (success = 0, fail <> 0)
          GetFailCnt = GetFailCnt + 1 'start counter
        Else 'if it was successful
          GetFailCnt = 0 'reset counter
          LinkDead = False 'link is not dead
          ResetSlave = False 'don't set flag to reset the radio
          RadResetAttempts = 0 'Set reset attempt counter to 0
        EndIf
        If GetFailCnt >= MaxGetFails Then 'if failure counter exceeds threshold
          LinkDead = True 'link is considered dead
        EndIf
        If LinkDead = True Then 'if the link is dead
          ResetSlave = True 'set flag to reset radio
          GetFailCnt = 0 'reset counter to 0
        EndIf
      EndSub
    #EndIf
  #EndIf

  '________________________________Sub to copy the burst stats to a new variable to store to the AQ table_______________________
  #If HasSuna = True Then
    Sub CopySunaStats
      AvgSunaNitrateuM = SunaStats.SunaNitrateuM_Avg
      MedSunaNitrateuM = SunaStats.SunaNitrateuM_Med
      StdSunaNitrateuM = SunaStats.SunaNitrateuM_Std
      AvgSunaNitratemgL = SunaStats.SunaNitratemgL_Avg
      MedSunaNitratemgL = SunaStats.SunaNitratemgL_Med
      AvgSunaFittingResult = SunaStats.SunaFittingResult_Avg
      StdSunaFittingResult = SunaStats.SunaFittingResult_Std
      AvgA254 = SunaStats.A254_Avg
      AvgSunaDarkAve = SunaStats.SunaDarkAve_Avg
      AvgSunaSpecAve = SunaStats.SunaSpecAve_Avg
      AvgTSpec = SunaStats.TSpec_Avg
      AvgTLamp = SunaStats.TLamp_Avg
      AvgSunaHumid = SunaStats.SunaHumid_Avg
      AvgSunaLampTime = SunaStats.SunaLampTime_Avg
      AvgSunaVoltMain = SunaStats.SunaVoltMain_Avg
      AvgSunaVoltLamp = SunaStats.SunaVoltLamp_Avg
    EndSub

    '_____________________________Sub to reset the new variables back to NANs so if data don't come in, we don't populate duplicate values into AQ____________________
    Sub ResetSunaStats
      AvgSunaNitrateuM = BadDataIndicator
      MedSunaNitrateuM = BadDataIndicator
      StdSunaNitrateuM = BadDataIndicator
      AvgSunaNitratemgL = BadDataIndicator
      MedSunaNitratemgL = BadDataIndicator
      AvgSunaFittingResult = BadDataIndicator
      StdSunaFittingResult = BadDataIndicator
      AvgA254 = BadDataIndicator
      AvgSunaDarkAve = BadDataIndicator
      AvgSunaSpecAve = BadDataIndicator
      AvgTSpec = BadDataIndicator
      AvgTLamp = BadDataIndicator
      AvgSunaHumid = BadDataIndicator
      AvgSunaLampTime = BadDataIndicator
      AvgSunaVoltMain = BadDataIndicator
      AvgSunaVoltLamp = BadDataIndicator
    EndSub

    '___________________________________________Reset Timers for Suna____________________
    Sub ResetSunaTimers
      WipeStart = 0
      WipeEnd = 0
      SunaWipeTotTime = 0
      SunaSampleStart = 0
      SunaOnTime = 0
      SunaProcessStart = 0
      SunaProcessEnd = 0
      SunaProcessTotTime = 0
    EndSub
  #EndIf

  '__________________________________Keypad Menus________________________________________
  Sub KeypadMenu
    DisplayMenu ("Main Menu",-4)
      SubMenu ("SystemInfo")
        DisplayValue ("LastScan",LastScan)
        DisplayValue ("Program",Program)
        DisplayValue ("ProgVersDate",ProgVersDate)
        DisplayValue ("DL_Firm",OSVers)
        DisplayValue ("SerNum",SerNum)
        DisplayValue ("ProgErrors",ProgErrors)
        DisplayValue ("DataErr",DataErr)
        DisplayValue ("Low12Volts",Low12Volts)
        DisplayValue ("LithBat",LithBat)
        DisplayValue ("SkipScans",SkipScans)
        DisplayValue ("FreeCFMem",FreeCFMem)
        DisplayValue ("Restart Attemps",VMRestartAttempts)
        DisplayValue ("NeedLowMeas",LowMeas)
        DisplayValue ("NeedHighMeas",HighMeas)
      EndSubMenu
      SubMenu ("VM Data")
        DisplayValue ("LastScan",LastScan)
        DisplayValue ("StagePrime",StagePrime)
        DisplayValue ("StageSecmd",StageSecnd)
        DisplayValue ("StgDiff",StgDiff)
        DisplayValue ("UpbeamStg",UpBeamStg)
        DisplayValue ("VMPressStg",VMPressStg)
        DisplayValue ("PS1Stg",PS1Stg)
        DisplayValue ("PS2Stg",PS2Stg)
        DisplayValue ("SondeStg",SondeStg)
        DisplayValue ("IndexVel",IndexVel)
        DisplayValue ("BadQCount",BadQCount)
        DisplayValue ("Qcfs",Qcfs)
        DisplayValue ("SiteVolts",CR1Volts)
        DisplayValue ("VMvolts",VMVolts)
        DisplayValue ("ExtWHConvertVolt",ExtWHConvertVolt)
        DisplayValue ("VMpitch",VMpitch)
        DisplayValue ("VMroll",VMroll)
        DisplayValue ("VMtempC",VMtempC)
        'DisplayValue ("LastGoodBin",LastGoodBin)
        DisplayValue ("BadVelCount",BadVelCount)
        DisplayValue ("BadStgCount",BadStgCount)
        DisplayValue ("StgSelect",StgSelect)
        DisplayValue ("VMUpBeam",VMupBeam)
        DisplayValue ("VMPressure",VMpressure)
        DisplayValue ("AvgSwathRSSI",AvgSwathRSSI)
        DisplayValue ("VMMemFree",VMMemFree)
      EndSubMenu
      SubMenu ("OtherSensorData")
        DisplayValue ("LastScan",LastScan)
        #If WqSonde <> "NONE" Then
          DisplayValue ("WQBattV",WqBattV)
          DisplayValue ("WqTempC",WqTempC)
          DisplayValue ("ExoSpCond",WqSpCond)
          DisplayValue ("ExoTurbFNU",WqTurbFNU)
          DisplayValue ("WQChlugL",WqChlugL)
          DisplayValue ("WQChlRFU",WqChlRFU)
          DisplayValue ("WQDOmgL",WqDOMgl)
          DisplayValue ("WQDOSat",WqDOSat)
          DisplayValue ("WQpH",WqPH)
          DisplayValue ("WQBGAugL",WqBGAugl)
          DisplayValue ("WQBGARFU",WqBGArfu)
          DisplayValue ("WQFDomQSU",WqFDOMqsu)
          DisplayValue ("WQFdomRFU",WqFDOMrfu)
          DisplayValue ("WQNH4mgl",WqNH4mgl)
          DisplayValue ("WQNO3mgl",WqNO3mgl)
          DisplayValue ("WQCLmgl",WqCLmgl)
          DisplayValue ("WQWiperPos",WqWiperPos)
        #EndIf
      EndSubMenu
      SubMenu ("SiteParameters")
        DisplayValue ("LastScan",LastScan)
        MenuItem ("Site Id",SiteID)
        MenuItem ("SiteNumb",SiteNum)
        MenuItem ("Tech?",Tech)
        MenuItem ("VisitReason",VisitReason)
        MenuPick (Site Visit,Calib Meas,Site Down,Beam Block,WQ Fouling,Program Update,Hardware Update,Other)
        MenuItem ("RecCalibData?",RecCalibData)
        MenuPick (Yes,No)
        MenuItem ("UpBeamOffSet",UpBeamOffset)
        MenuItem ("VMPressOffset",VMPressOffset)
        MenuItem ("PS1Offset",PS1Offset)
        MenuItem ("PS2Offset",PS2Offset)
        MenuItem ("SondeOffset",SondeOffset)
        MenuItem ("SelStgPrime =",SelStgPrime)
        MenuPick (UPbeam,VMpress,PSpress,PSpress2,WqPress)
        MenuItem ("SelStgSecnd =",SelStgSecnd)
        MenuPick (UPbeam,VMpress,PSpress,PSpress2,WqPress)
        MenuItem ("TruePS1Stg",TruePS1Stg)
        MenuItem ("TruePS2Stg",TruePS2Stg)
        MenuItem ("TrueUpBeamStg",TrueUpBeamStg)
        MenuItem ("TrueVMPressStg",TrueVMPressStg)
        MenuItem ("TrueYsiStg",TrueSondeStg)
        MenuItem ("StartBin",StartBin)
        MenuItem ("EndBin",EndBin)
        MenuItem ("StartEbbBin (Pos)",StartEbbBin) 'used for ebb/flood rating
        MenuItem ("EndEbbBin (Pos)",EndEbbBin) 'used for ebb/flood rating
        MenuItem ("StartFldBin (Neg)",StartFldBin)'used for ebb/flood rating
        MenuItem ("EndFldBin (Neg)",EndFldBin) 'used for ebb/flood rating
        MenuItem ("Use Ebb/Fld Rating",BiRating) 'used for ebb/flood rating
        MenuPick (Yes,No)
        MenuItem ("Ebb-Flood Tran (vel)",BiRatTran) 'used for ebb/flood rating
        MenuItem ("MinExpVel",MinExpVel)
        MenuItem ("MaxExpVel",MaxExpVel)
        MenuItem ("MinExpStg",MinExpStg)
        MenuItem ("MaxExpStg",MaxExpStg)
        MenuItem ("Flow Sign",FlowSign)
        MenuPick (1,-1)
        MenuItem ("HighRatVel",HighRatVel)'Highest velocity covered by rating
        MenuItem ("LowRatVel",LowRatVel)'lowest velocity covered by rating
        MenuItem ("CalcQs?",CalcQ)
        MenuPick (Yes,No)
        MenuItem ("Use Y vel?",UseV2)
        MenuPick (Yes,No)
        MenuItem ("Use Pos flow angle (earth)",UseDir)
        MenuPick (Yes,No)
        MenuItem ("Positive Flow Angle",PosFlowDir)
        MenuItem ("Record All Vel Data",RecordAll)
        MenuPick (Yes,No)
        MenuItem ("Store all Variables",StoreVariablesFlg)
        MenuPick (Yes,No)
        MenuItem ("Read in Variables",GetVariablesFlg)
        MenuPick (Yes,No)
        MenuItem ("VM Power",VMPower)
        MenuPick (Yes,No)
        MenuItem ("WakeUpVM",WakeUpVM)
        MenuPick (Yes,No)
        MenuItem ("HrsCdmaOff",HrsCdmaOff)
        MenuPick (1,2,4,8,12)
        MenuItem ("CycleCdmaPwr",CycleCdmaPwr)
        MenuPick (Yes,No)
        #If (WqSonde <> "NONE") Then
          MenuItem ("CycleEXOPwr" ,WqManualCycle)
          MenuPick (Yes,No)
        #EndIf
        MenuItem ("KeepCDMAon",KeepCDMAon)
        MenuPick (Yes,No)
        MenuItem ("UseNCcdmaRelay?",IsCDMANClosed) 'New entry for normally closed relay
        MenuPick (Yes,No)
        '      MenuItem ("UseAutoLastBin",UseAutoLastBin)
        '      MenuPick (Yes,No)
        MenuItem ("SelectFilter",SelectFilter)
        MenuPick (0,1)
        MenuItem ("RSSIThreshold",RSSIThreshold)
        MenuItem ("RSSI Avg Start Bin",AvgRSSIStartBin)
        MenuItem ("RSSI Avg End Bin",AvgRSSIEndBin)
        MenuItem ("StdCorrThreshold",StdCorrThreshold)
        MenuItem ("CorrThreshold",CorrThreshold)
        #If GetNoiseFloor = Yes Then
          MenuItem ("SendPT3",SendPT3)
          MenuPick (Yes,No)
        #EndIf

      EndSubMenu
      SubMenu ("AllBinData")
        DisplayValue ("Bin1",VMBinVel(1))
        DisplayValue ("Bin2",VMBinVel(2))
        DisplayValue ("Bin3",VMBinVel(3))
        DisplayValue ("Bin4",VMBinVel(4))
        DisplayValue ("Bin5",VMBinVel(5))
        DisplayValue ("Bin6",VMBinVel(6))
        DisplayValue ("Bin7",VMBinVel(7))
        DisplayValue ("Bin8",VMBinVel(8))
        DisplayValue ("Bin9",VMBinVel(9))
        DisplayValue ("Bin10",VMBinVel(10))
        DisplayValue ("Bin11",VMBinVel(11))
        DisplayValue ("Bin12",VMBinVel(12))
        DisplayValue ("Bin13",VMBinVel(13))
        DisplayValue ("Bin14",VMBinVel(14))
        DisplayValue ("Bin15",VMBinVel(15))
        DisplayValue ("Bin16",VMBinVel(16))
        DisplayValue ("Bin17",VMBinVel(17))
        DisplayValue ("Bin18",VMBinVel(18))
        DisplayValue ("Bin19",VMBinVel(19))
        DisplayValue ("Bin20",VMBinVel(20))
        DisplayValue ("Bin21",VMBinVel(21))
        DisplayValue ("Bin22",VMBinVel(22))
        DisplayValue ("Bin23",VMBinVel(23))
        DisplayValue ("Bin24",VMBinVel(24))
        DisplayValue ("Bin25",VMBinVel(25))
        DisplayValue ("Bin26",VMBinVel(26))
        DisplayValue ("Bin27",VMBinVel(27))
      EndSubMenu
      'uncomment when you have the submenu for WQ sonde

      #If WqSonde = "WQ_SDI12" Then
        SubMenu ("RawSondeData")
          DisplayValue ("WqSDI12Sensor(1)",WqSDI12Sensor(1))
          DisplayValue ("WqSDI12Sensor(2)",WqSDI12Sensor(2))
          DisplayValue ("WqSDI12Sensor(3)",WqSDI12Sensor(3))
          DisplayValue ("WqSDI12Sensor(4)",WqSDI12Sensor(4))
          DisplayValue ("WqSDI12Sensor(5)",WqSDI12Sensor(5))
          DisplayValue ("WqSDI12Sensor(6)",WqSDI12Sensor(6))
          DisplayValue ("WqSDI12Sensor(7)",WqSDI12Sensor(7))
          DisplayValue ("WqSDI12Sensor(8)",WqSDI12Sensor(8))
          DisplayValue ("WqSDI12Sensor(9)",WqSDI12Sensor(9))
          DisplayValue ("WqSDI12Sensor(10)",WqSDI12Sensor(10))
          DisplayValue ("WqSDI12Sensor(11)",WqSDI12Sensor(11))
          DisplayValue ("WqSDI12Sensor(12)",WqSDI12Sensor(12))
          DisplayValue ("WqSDI12Sensor(13)",WqSDI12Sensor(13))
          DisplayValue ("WqSDI12Sensor(14)",WqSDI12Sensor(14))
          DisplayValue ("WqSDI12Sensor(15)",WqSDI12Sensor(15))
          DisplayValue ("WqSDI12Sensor(16)",WqSDI12Sensor(16))
          DisplayValue ("WqSDI12Sensor(17)",WqSDI12Sensor(17))
          DisplayValue ("WqSDI12Sensor(18)",WqSDI12Sensor(18))
          DisplayValue ("WqSDI12Sensor(19)",WqSDI12Sensor(19))
          DisplayValue ("WqSDI12Sensor(20)",WqSDI12Sensor(20))
          DisplayValue ("WqSDI12Sensor(21)",WqSDI12Sensor(21))
          DisplayValue ("WqSDI12Sensor(22)",WqSDI12Sensor(22))
          DisplayValue ("WqSDI12Sensor(23)",WqSDI12Sensor(23))
        EndSubMenu
      #ElseIf (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST")
        SubMenu ("RawSondeData")
          DisplayValue ("WqData(1)",WqData(1))
          DisplayValue ("WqData(2)",WqData(2))
          DisplayValue ("WqData(3)",WqData(3))
          DisplayValue ("WqData(4)",WqData(4))
          DisplayValue ("WqData(5)",WqData(5))
          DisplayValue ("WqData(6)",WqData(6))
          DisplayValue ("WqData(7)",WqData(7))
          DisplayValue ("WqData(8)",WqData(8))
          DisplayValue ("WqData(9)",WqData(9))
          DisplayValue ("WqData(10)",WqData(10))
          DisplayValue ("WqData(11)",WqData(11))
          DisplayValue ("WqData(12)",WqData(12))
          DisplayValue ("WqData(13)",WqData(13))
          DisplayValue ("WqData(14)",WqData(14))
          DisplayValue ("WqData(15)",WqData(15))
          DisplayValue ("WqData(16)",WqData(16))
          DisplayValue ("WqData(17)",WqData(17))
          DisplayValue ("WqData(18)",WqData(18))
          DisplayValue ("WqData(19)",WqData(19))
          DisplayValue ("WqData(20)",WqData(20))
          DisplayValue ("WqData(21)",WqData(21))
          DisplayValue ("WqData(22)",WqData(22))
          DisplayValue ("WqData(23)",WqData(23))
          DisplayValue ("WqData(23)",WqData(23))
          ' put exo serial stuff here
        EndSubMenu
      #EndIf

      SubMenu ("StageRating")
        MenuItem ("StgOffset",StgOffset)
        MenuItem ("StgCoef",StgCoef)
        MenuItem ("StgCoef2",StgCoef2)
      EndSubMenu
      SubMenu ("meanvel_Rating")
        MenuItem ("VelOffset",VelOffset)
        MenuItem ("VelCoef",VelCoef)
        MenuItem ("VelCoef2",VelCoef2)
        MenuItem ("VelCoef3",VelCoef3)
        MenuItem ("Trans",Trans)
        MenuItem ("UpVelOffset",UpVelOffset)
        MenuItem ("UpVelCoef",UpVelCoef)
        MenuItem ("UpVelCoef2",UpVelCoef2)
        MenuItem ("UpVelCoef3",UpVelCoef3)
        MenuItem ("LowVelOffset",LowVelOffset)
        MenuItem ("LowVelCoef",LowVelCoef)
        MenuItem ("LowVelCoef2",LowVelCoef2)
        MenuItem ("LowVelCoef3",LowVelCoef3)
      EndSubMenu
      SubMenu ("SDI12_Setup")
        MenuItem ("PSPressPort",PSPressPort)
        MenuPick (3,5)
        MenuItem ("PSPressAddr",PSPressAddr)
        MenuPick (0,1,2,3,4)
        MenuItem ("PSpress2Port?",PSpress2Port)
        MenuPick (3,5)
        MenuItem ("PSpress2Addr?",PSpress2Addr)
        MenuPick (0,1,2,3,4)
        #If WqSonde ="WQ_SDI12" Then
          MenuItem ("WQ SDI Port?",WqSDIPort)
          MenuPick (3,5)
          MenuItem ("YSI Addr?",WqAddr)
          MenuPick (0,1,2,3,4)
        #EndIf
      EndSubMenu
      #If WqSonde = "WQ_SDI12" Then
        SubMenu ("WQSondeSetup")
          MenuItem ("MilliToMicro?",MilliToMicro)
          MenuPick (Yes,No)
          MenuItem ("LocTempC",LocTempC)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
          MenuItem ("LocSpCond",LocSpCond)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
          MenuItem ("LocVolts",LocVolts)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
          MenuItem ("LocDOmgL",LocDOmgL)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
          MenuItem ("LocDOSat",LocDOSat)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
          MenuItem ("LocPH",LocPH)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
          MenuItem ("LocORP",LocORP)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
          MenuItem ("LocDepth",LocDepth)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
          MenuItem ("LocTurbFNU",LocTurbFNU)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
          MenuItem ("LocFdomRFU",LocFdomRFU)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
          MenuItem ("LocFdomQSU",LocFdomQSU)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
          MenuItem ("LocChlorMGL",LocChlorMGL)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
          MenuItem ("LocChlorRFU",LocChlorRFU)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
          MenuItem ("LocBGA",LocBGA)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
          MenuItem ("LocAmmonium",LocAmmonium)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
          MenuItem ("LocNitrate",LocNitrate)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
          MenuItem ("LocChloride",LocChloride)
          MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        EndSubMenu
      #EndIf
    EndMenu
  EndSub

  '_______________________________________Main Program____________________________________
  'Main Program
  BeginProg
    'INITIALIZE variables here that will hold their value from scan to scan
    MissedEns = 0
    ScanDiff = 0
    #If HasVM Then
      SpikeCounter = 0
      SendHeader = True
    #EndIf
    'Set comms mode to Zero and include in open commands if using c1,c3 on cr6
    UseCommsZeroForADCP = False
    UseCommsOneForSonde = False 'if Max232 is present this flag should show true in the public table
    UseCommsZeroForSonde = False 'If no Max232 is present this flag should show true in the public table
    WqUseCPort = False 'If using C1/C3 this flag should be true. Future versions may have option to use U ports instead.
    #If LoggerType = CR6 Then
      If (AdcpPort = ComC1) OR (AdcpPort = ComC3) Then
        UseCommsZeroForADCP = True
      EndIf
      If (WqSerialPort = ComC1) OR (WqSerialPort = ComC3) Then
        WqUseCPort = True 'Variable to indicate if WQ is in the C port
      EndIf
      If (IsWqMax232 = True) AND (WqUseCPort = True) Then ' if sonde is using Max232 and is in a C port
        UseCommsOneForSonde = True 'then me need to use comms mode one to speak TTL
      EndIf
      If (IsWqMax232 = False) AND (WqUseCPort = True) Then 'ifsonde isn't using a Max232 and is in a c port
        UseCommsZeroForSonde = True 'then we need to uses comms mode zero to speak standard RS232
      EndIf
    #EndIf
    PanelTemp(PTempC,250)
    PTempF = PTempC * 9/5 + 32
    Call GetStartup 'setup all the statup\default info
    Call CalcLoopInterval 'calculate the loop interval from the ScanRate and ScanUnit
    Call Initialize 'initialize important variables
    SetVMTimeFlg = false
    RecDataFlag = No
    OneMinConsistent = False 'during initializationmake sure the continous 1min data is not enabled. Only user selections should activate it.
    CMD = ""
    SendCMD = FALSE
    #If RadioNetwork = True Then
      ResetTryOK = True 'It's ok to try a reset once initial dead thresholds have been met, no need to wait.
      NextTryCnt = MaxNextTryCnt 'set nexttry to maxnexttry so we can reset the radio without waiting the first time.
    #EndIf
    '---------------------------------------------------------------------
    ' This must be done inside scan
    '  If GetVariablesFlg = True Then
    '    Call ReadVariables
    '    GetVariablesFlg = False
    '  EndIf
    '--Start Scan ----------------------------------------------------------------------
    'The Scan starts here and we initialize variables that are changed during every scan
    '-----------------------------------------------------------------------------------
    Scan (ScanRate,ScanUnit,5,0)'set to scan every 60 seconds
      ScanStart = Timer(DebugTimer,mSec,2) 'Start a timer to time all functions
      ScanStart = ScanStart/1000 'convert mSec to seconds
      RealTime (rTime)' get current time from datalogger real time clock
      RealSeconds = (Hour * 3600) + (Minute * 60) + Second
      'see if time is close to 15 minute or Day Interval
      Mod5Minutes = RealSeconds MOD 300
      Mod15Minutes = RealSeconds MOD 900
      Mod60Minutes = RealSeconds MOD 3600
      ModDay = RealSeconds MOD 86400
      '------------------------------------------------------SUNA TIMING-------------------------------------
      '----------------Leave here to ensure it gets powered ASAP at beginning of scan------------------------
      #If HasSuna Then 'set all suna variables to false
        Call ResetSunaTimers
        SunaMissed = False
        SunaReady = False
        WipeSuna = False
        PortSet (SunaWipeSwitch,0)' keep wiper off
        If ManualSunaOn = True Then
          SerialOpen(SunaPort,115200,0,0,6000)
          PortSet(SunaSwitch,1)
        Else
          SerialFlush(SunaPort)
          SerialClose(SunaPort)
          PortSet(SunaSwitch,0)
        EndIf
        If Mod15Minutes = 840 Then 'if minute 14
          WipeSuna = True 'set the wiper flag to true
          Timer (SunaWipeTimer,mSec,2) 'start a timer so we can wipe late in the scan
          SerialFlush(SunaPort)
          SerialClose(SunaPort)
          PortSet(SunaSwitch,0)
          ManualSunaOn = False
        Else
          WipeSuna = False 'otherwise, don't wipe
        EndIf
        If Mod15Minutes = 0 Then 'If 15th minute
          PortSet (SunaSwitch,1) 'turn the Suna power ON
          Timer (SunaSampleTimer,mSec,2) 'start a timer to sample in 15sec
          SampleSuna = True 'set flag to trigger sampling routine
        ElseIf Mod15Minutes <> 0 AND ManualSunaOn = False
          PortSet (SunaSwitch,0) 'otherwise, keep suna off
          SampleSuna = False 'don't trigger sampling
        EndIf
      #EndIf
      '-------------------------------------------------------------------------------------------------------
      If ModDay = 0 Then 'At midnight
        SetVMTimeFlg = True
        Rec24HrFlag = True 'Trigger for QAQC table
        CallTable QAQCInfo
        #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then
          SetEXOTimeFlg = True
        #EndIf
        StoreVariablesFlg = True 'set flag to store the necessary variables to the USR drive
      Else
        Rec24HrFlag = False
      EndIf
      If ModDay = 300 Then 'Reset bad data counter at 5 minutes after Midnight
        'Reset all Daily flags or zero variables here
        Call ZeroErrCounters 'Reset Counters at midnight
        #If HasVM Then
          SpikeCounter = 0
        #EndIf
      EndIf
      If Mod15Minutes = 0 Then 'at the 15 minute mark
        Rec15minFlag = True ' set flag to record AQ and DataOut tables
        RecBeamCheckFlag = True 'set flag to record BeamCheck Table
        If RecordAll = True Then RecAllVelFlag = True 'set flag to record VelData table for special studies
      Else
        Rec15minFlag = False
        RecAllVelFlag = False
        RecBeamCheckFlag = False
      EndIf
      If RecCalibData = True Then 'if we want 1 min data
        Rec1MinFlag = True
      Else 'if the user set it back to false
        Rec1MinFlag = False 'stop recording 1min data
        OneMinCount = 0 'reset the counter
      EndIf
      If Rec1MinFlag = True Then
        OneMinCount = OneMinCount + 1
        If OneMinCount > 1439 Then 'If 24hours has been recorded
          RecCalibData = False
          Rec1MinFlag = False
          OneMinCount = 0
        EndIf
      EndIf
      #If WqSonde = "WQ_SERIAL_BURST" Then
        'On initial compile the burstperiod is set to zero. Have it switch to the standard 1150 unless user declares otherwise.
        If BurstPeriod = 0 Then
          BurstPeriod = 1150 'this is adjustable here and in the public table. Minimum value is 250 for the sonde. A cr6 seems to work at that rate or slower. A CR1000 needs a rate of no faster than 1150.
        ElseIf BurstPeriod < 250 Then 'if user enters values less than 250, but not 0, bring it up to 250. This is the max rate that the sonde can collect.
          BurstPeriod = 250
        EndIf
        #If TopBottom Then 'if we have a Top/Bottom sonde setup
          If Mod15Minutes = 720 Then 'if the 12th minute
            BtmWipeflag = True 'set flag to wipe the bottom sonde
          Else
            BtmWipeflag = False
          EndIf
          If Mod15Minutes = 780 Then 'If the 13th minute
            Timer(StartBtmBurstTimer,mSec,2) 'Start Timer to use to delay the burst to later in the minute
            GetBtmBurst = True 'set flag to initiate sample
          Else
            GetBtmBurst = False
          EndIf
        #EndIf
        If Mod15Minutes = 780 Then 'if the 13th minute
          Wipeflag = True 'wipe the top sonde (or only sonde not Top/Bottom
        Else
          Wipeflag = False
        EndIf
        If Mod15Minutes = 840 Then 'if the 14th minute
          Timer (StartTopBurstTimer,mSec,2) 'start timer for delaying the burst to later in the minute
          GetBurst = True
        Else
          GetBurst = False
        EndIf
      #EndIf
      Dim InCount As Long
      EnsBytes = 0
      Subscans = 0
      ScanNo = ScanNo + 1
      'Set the baudrates and open the serial ports
      Call OpenADCPPort
      '              'IMPORTANT Comment out the following code between dashed lines if this program is used at Freeport or if SlaveCom (C7 & C8)is being used by another porcess
      '              ----------------------------------------------------------------------------------------------------------------------------------
      #If HasSlave = Yes Then
        If (VemcoRTR = True) OR (SendFlowData = True) Then
          SerialOpen (SlaveCom,19200,0,0,2000)'this is if you are using a Vemco slave or you are transmitting data to another logger
        EndIf
      #EndIf
      '------------------------------------------------------------------------------------------------------------------------
      If GetVariablesFlg = True Then
        Call ReadVariables
        GetVariablesFlg = False
      EndIf
      If (SendCMD) Then Call SendSetup
      #If GetNoiseFloor = True Then
        'If SendPT3 = True AND TimeIntoInterval(PT3Time,5,Min) Then 'used for debugging
        If SendPT3 = True AND TimeIntoInterval(PT3Time,1440,Min) AND OneMinConsistent = False Then '3 minutes before midnight. Skip this if OneMinConsistent is true.
          CMD = "PT3"
          SendCMD = True
          Call SendSetup
        EndIf
        If CMD = "PT3" Then CallTable NoiseFloor
      #EndIf
      CMD = ""
      #If HasSlave = Yes Then
        If SendFlowData = True Then Call SerialDataOut 'This is to send specific flow data to a "slave" logger, that is running a special program, ex. Sac Waste Water.
      #EndIf
      Call ToggleVMPower 'if set to VMpower = yes then ok otherwise turns off VM
      Call TrueStage
      UpBeamStg = VMupBeam + UpBeamOffset
      VMPressStg = VMpressure + VMPressOffset
      PS1Stg = PsPress1Stg(1) + PS1Offset
      PS2Stg = PSpress2Stg(1) + PS2Offset
      #If WqSonde <> "NONE" Then
        SondeStg = WqDepthFt + SondeOffset
      #EndIf
      'If we have an EXO turn it on here
      #If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
        #If LoggerType = CR1000 Then 'turn on the Sonde
          If IsWQNClosed Then
            PortSet(WqSwitchPort,0)
          Else
            PortSet(WqSwitchPort,1)
          EndIf
        #ElseIf LoggerType = CR6 Then
          If UseSW12_2_forWQ Then 'use the SW12 port no 2
            SW12(2,1)
          Else
            If IsWQNClosed Then
              PortSet(WqSwitchPort,0)
            Else
              PortSet(WqSwitchPort,1)
            EndIf
          EndIf
        #EndIf
        #If WqSonde = "WQ_SERIAL_BURST" Then
          iCount=1
          Erase BurstIn
          Erase BurstArray()
          Erase BurstData()
          #If TopBottom Then
            iCount=1
            Erase BtmBurstIn
            Erase BtmBurstArray()
            Erase BtmBurstData()
          #EndIf
        #EndIf
        'Redeploy = False
        'Call SetBaud
      #EndIf
      Call GetStage


      'If user elects to wake up Channel Master because it has gone to sleep for some reason
      #If HasVM Then
        If WakeUpVM Then
          Call WakeVM
          WakeUpVM = No
        EndIf
      #EndIf
      Call GetLastScan
      Call GetSysInfo
      Call KeypadMenu
      #If ReadExtPwr Then
        Call ExtPwrSource
      #EndIf
      'If Event ocures, then
      '                If Tech <> "" OR VisitReason <> "" OR TrueStg1 <> NAN OR TrueStg2 <> NAN OR TrueStg3 <> NAN OR VisRefOK = True OR DiveVisit = True OR WQVisit = True OR FullVisit = True Then
      If Tech <> "" OR VisitReason <> "" OR TrueUpBeamStg <> NAN OR TrueVMPressStg <> NAN OR TruePS1Stg <> NAN OR TruePS2Stg <> NAN OR TrueSondeStg <> NAN Then
        ErrorEvent = "Tech Visit"
        CallTable SiteVisit
        ' checked to see if data are to be sent.
        Delay (0,200,mSec)
        Tech = "" 'set tech back to null value
        VisitReason = ""
        'now set TrueStg values back to BadDataIndicator
        TrueUpBeamStg = BadDataIndicator
        TrueVMPressStg = BadDataIndicator
        TruePS1Stg = BadDataIndicator
        TruePS2Stg = BadDataIndicator
        TrueSondeStg = BadDataIndicator
        'Now set Visit Variables back to False
      EndIf
      'The following code looks for the incoming data stream,stores the data in an array of longs, and passes the data through
      'a series of checks.  If those checks fail then the scan is truncated, the ruesulting
      'data is flagged, and the serial port is flushed.  On the next scan the next valid ensemble
      'is read, if there is good data in the buffer then that should be reflected in the output.
      ADCPDone = False
      Numbytes = 0 'Zero counters for ADCP Decoder
      InCount=0
      #If HasVM = true Then
        For ADCPLoop = 1 To 2
          Do While SerialInChk(AdcpPort)
            InCount=InCount+1
            SerialInBlock(AdcpPort,Nums(1),1)
            MoveBytes(Longarray(InCount),3,Nums(1),0,1)'this is required because ADCP outputs bytes (little indean - big indian) in the reverse order that is done in the cr10000 (Big-indian Little indian)
            If InCount > 5 Then
              If Longarray(1) <> 127 OR Longarray(2) <> 127 'These characters are at the start of each ensemble hex 7F7F
                FramingError = FramingError + 1
                InCount = InCount-2 'discard junk bytes and continue
              EndIf
            EndIf
            Numbytes = InCount
            If InCount > 4 Then 'get number of bytes per ensemble from adcp data
              LSB = Longarray(3)
              MSB = Longarray(4)
              EnsBytes = LSB + (MSB*256)
            EndIf
            If Numbytes > 4 AND EnsBytes = Numbytes - 2 Then 'we have all the bytes, let's get out of both loops
              SerialFlush(AdcpPort)
              ADCPDone = true
              ExitDo
            EndIf
            Delay (1,30,uSec)
          Loop
          If FramingError > 0 Then
            HeaderMismatch = HeaderMismatch + 1
            FramingError = 0
          EndIf
          Subscans = Subscans + 1
          If ADCPDone Then ExitFor
          Delay (1,5,Sec) 'Wait a bit for incoming ensemble, but not more than 10 seconds
        Next
      #EndIf
      ADCPEnd = Timer(DebugTimer,mSec,4)
      ADCPEnd = ADCPEnd/1000

      If Numbytes = ((EnsBytes *2) +4) Then MissedEns = MissedEns + 1
      CDMACheckStart = Timer(DebugTimer,msec,4)
      CDMACheckStart = CDMACheckStart/1000
      Call CDMAcheck
      CDMACheckEnd = Timer(DebugTimer,msec,4)
      CDMACheckEnd = CDMACheckEnd/1000
      CDMACheckTotTime = CDMACheckEnd-CDMACheckStart
      #If HasVM = True Then
        ZeroVMTimeStart = Timer(DebugTimer,msec,4)
        ZeroVMTimeStart = ZeroVMTimeStart/1000
        If NumbytesZero > 7 Then
          BadEnsemble = BadEnsemble + 1
          Call ZeroVMArrays
          VMdataIn = No
          SerialFlush(AdcpPort)
          NumbytesZero = 0
        EndIf
        If Numbytes < 1 Then
          NumbytesZero = NumbytesZero + 1
        Else
          NumbytesZero = 0
        EndIf
        ReceivedBytes = Numbytes
        InCount = 0
        ZeroVMTimeEnd = Timer(DebugTimer,msec,4)
        ZeroVMTimeEnd = ZeroVMTimeEnd/1000
        ZeroVMTotTime = ZeroVMTimeEnd - ZeroVMTimeStart
        ChkSumChkStart = Timer(DebugTimer,msec,4)
        ChkSumChkStart = ChkSumChkStart/1000
        Call ChecksumCheck
        If (CalcCheckSum <> EnsChecksum) OR (CalcCheckSum = 0) Then
          BadEnsemble = BadEnsemble + 1
          BadChecksum = BadChecksum + 1
          VMdataIn = No
          ChkSumChkEnd = Timer(DebugTimer,msec,4)
          ChkSumChkEnd = ChkSumChkEnd/1000
          ChkSumChkTotTime = ChkSumChkEnd - ChkSumChkStart
          'SerialFlush(AdcpPort)
        Else
          VMdataIn = Yes
        EndIf
      #EndIf
      BeforeBurst = Timer(DebugTimer,msec,4)
      BeforeBurst = BeforeBurst/1000
      #If WqSonde = "WQ_SDI12" Then
        Call GetWq_SDI12 'get YSI data
      #ElseIf (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
        If WqParamOrder(1) = BadDataIndicator OR NoSondeTrig <> 0 Then Redeploy = True 'checks for top sonde. If no new data redeploy
        #If TopBottom Then
          If BtmWqParamOrder(1) = BadDataIndicator OR NoSondeTrig <> 0 Then Redeploy = True 'checks for bottom sonde. If no new data redeploy
        #EndIf
        If Redeploy = True Then 'EXO not setup yet. If TopBottom the subroutines will redeploy both sondes
          Call ParamCheck
          Delay (1,10,mSec)
          Call DefineParamsOrder
          Delay (1,10,mSec)
          Call DefineLocs
          Delay (1,10,mSec)
          Call SetDelim
          Delay (1,10,mSec)
          Redeploy = False
        Else 'if not redeploy Get single data point
          Call GetWQ_Serial 'get a single data point
          Delay (1,30,mSec)
          Call ParseData
        EndIf '
        Delay (1,50,mSec)
        #If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then ' Check WQ flags and do things!!
          If Wipeflag = true Then
            Call WipeWQ
            Delay (1,50,mSec)
            WipeTime = Status.TimeStamp(0,1)
          EndIf
          #If TopBottom Then
            If BtmWipeflag = true Then
              Call WipeBtmWQ
              Delay (1,50,mSec)
              BtmWipeTime = Status.TimeStamp(0,1)
            EndIf
          #EndIf
          If GetBurst AND NOT Redeploy Then 'ok we need a burst
            #If WqSonde = "WQ_SERIAL_BURST" Then
              'If WqError = False  Then 'If sonde is having probs then don't burst <--- Commented this because I think we still want to try to set the Run function even
              ' if it didn't respond to the previous "data" attempt
              BurstReachedMod = Mod15Minutes
              #If TopBottom = False Then 'if we don't have a top/bottom sonde, get the burst sample as close to the 15min mark as we can by delaying
                Do
                  TopBurstDelay = Timer(StartTopBurstTimer,mSec,4)
                  TopBurstDelay = TopBurstDelay/1000
                  If TopBurstDelay >= 60 - (MaxBurstCnt + 8) Then 'delay until there will be a few seconds to spare at end of scan (sample rate is 1.15sec * 30 = 34.5seconds to complete)
                    StartTopBurst = True
                    ExitDo 'we reached out time threshold, start burst
                  Else
                    StartTopBurst = False
                  EndIf
                  Delay(1,250,mSec) 'delay 0.25sec before checking time again
                Loop
              #EndIf
              BurstTimeReached = Timer(DebugTimer,mSec,4)
              BurstTimeReached = BurstTimeReached/1000
              Call setburst 'set the period to output the data from the sonde
              Call GetBurstArray 'set up the array to store the burst values
              BurstDebugCount = BurstDebugCount+1 'we made it this far, count up
              '              BurstMedDate = ""
              '              BurstMedTime = ""
              BurstCount = 0 'reset our burst counter
              TotalBurstVals = 0 'reset variable that will store how many values used to calculate burst table
              BurstErrCnt = 0 'reset error counter
              GotToBurst = GotToBurst + 1 'we got to the burst (duplicate variable as the BurstDebugCount)
              jCount = 0 'reset j Loop counter
              kCount = 0 'reset k Loop counter
              For jCount = 1 To MaxBurstCnt 'de-construct BurstArray and send to table.  too slow to do in get loop
                For kCount = 1 To 23 'this is the loop to pull the parameters
                  BurstData(kCount) = BurstArray(jCount,kCount)' get one burst string
                Next kCount 'pull all 23 parameters within the k-th part of the j-loop and store in the array
                Call parseburst 'parse array into proper fields
                If WqError Then 'if we didn't get data
                  WqBadData = true 'set a flag
                Else
                  WqBadData = false 'otherwise, we are good
                EndIf
                '                StdDevSpa(StdTurbFNU,MaxBurstCnt,BurstArray(1,WqLocTurb))
                '                Delay(1,30,msec)
                BurstCount = BurstCount+1 'burst count increase
                If WqError Then 'an error occured while trying to read a burst value (in "ParseBurst" sub)
                  BurstErrCnt = BurstErrCnt + 1 'count up if the error occurs
                EndIf
                If BurstErrCnt > BurstMaxErrCnt Then 'if we have more errors than the threshold
                  TotalBurstVals = jCount - BurstErrCnt 'the total number of values used for the burst should be jCount - number of errors
                  SerialOut (WqSerialPort,"0" + CHR(13) + CHR(10),"#",3,50) 'send a "0" out to stop the SOA from attempting to burst
                  ExitFor 'if error occurs more than a threshold, exit the loop
                EndIf

                If BurstCount >= MaxBurstCnt Then 'if our burst count has reached our threshold
                  TotalBurstVals = jCount - BurstErrCnt 'if there's an interuption during the burst but it comes back online, we need to subtract how many times error happened to calculate a total number of values
                  BurstMissed = False 'we had good values coming in, so Make sure disable variable is set to false so the values get processed
                  RecBurstFlag = True 'set our output flag to true
                  CallTable SecBurst 'call the table that stores individual 1sec values
                  CallTable Burst 'call the burst table
                ElseIf BurstCount < MaxBurstCnt AND WqError = True Then
                  BurstMissed = False 'we have good values
                  RecBurstFlag = False 'don't set the output flag because we haven't reached our threshold
                  CallTable SecBurst 'store the next 1sec value
                ElseIf BurstCount < MaxBurstCnt AND WqError = False Then
                  BurstMissed = False
                  RecBurstFlag = False
                  CallTable SecBurst
                  CallTable Burst 'Need to call table to store the values in the table memory until the output flag (RecBurstFlag) is true
                EndIf
                Delay(1,1,msec)
              Next jCount 'restart the loop until we reach max burst count
              If BurstCount < MaxBurstCnt Then 'didn't reach our burst threshold, so let's Call and output SecBurst and Burst Tables
                BurstMissed = True 'Disable processing of Median values in burst table
                RecBurstFlag = True 'set the output flag to true
                CallTable SecBurst 'store the final value in the SecBurst table
                CallTable Burst 'Call the burst table to output median values no with however many 1sec values were collected
              EndIf

              If TotalBurstVals >= MinBurstVals Then 'if we reached our minimum threshold for 1sec values
                Call CopyMedBurstVals 'copy the values from the burst table to the "Med..." values to be sampled into the AQ table
              Else
                Call ResetBurstVars 'we didn't reach our minimum threshold, NAN all values to be sampled into AQ table
              EndIf
              SerialFlush (WqSerialPort) 'flush the port to ensure nothing gets inadvertantly populated
              BurstCount = 0 'reset our burst count back to 0
            #EndIf 'burst
          EndIf 'getburst and not redeploy
          '      EndIf 'Redeploy = true
          #If TopBottom Then
            If GetBtmBurst AND NOT Redeploy Then 'ok we need a burst
              #If WqSonde = "WQ_SERIAL_BURST" Then
                'If WqError = False  Then 'If sonde is having probs then don't burst <--- Commented this because I think we still want to try to set the Run function even
                ' if it didn't respond to the previous "data" attempt
                BurstReachedMod = Mod15Minutes
                Do
                  BtmBurstDelay = Timer(StartBtmBurstTimer,mSec,4)
                  BtmBurstDelay = BtmBurstDelay/1000
                  If BtmBurstDelay >= 60 - (MaxBurstCnt + 8) Then 'delay until there will be a few seconds to spare at end of scan (sample rate is 1.15sec * 30 = 34.5seconds to complete)
                    StartBtmBurst = True
                    ExitDo 'continue loop until we've reached the proper time
                  Else
                    StartBtmBurst = False
                  EndIf
                  Delay(1,250,mSec) 'delay 0.25sec before returning to top of loop
                Loop
                BurstTimeReached = Timer(DebugTimer,mSec,4)
                BurstTimeReached = BurstTimeReached/1000
                Call SetBtmBurst 'set the period to output the data from the sonde
                Call GetBtmBurstArray 'set up the array to store the burst values
                BtmBurstDebugCount = BtmBurstDebugCount+1 'we made it this far, count up
                '              BurstMedDate = ""
                '              BurstMedTime = ""
                BtmBurstCount = 0 'reset our burst counter
                TotalBurstVals = 0 'reset variable that will store how many values used to calculate burst table
                BtmBurstErrCnt = 0 'reset error counter
                GotToBurst = GotToBurst + 1 'we got to the burst (duplicate variable as the BurstDebugCount)
                BtmjCount = 0 'reset j Loop counter
                BtmkCount = 0 'reset k Loop counter
                For BtmjCount = 1 To MaxBurstCnt 'de-construct BurstArray and send to table.  too slow to do in get loop
                  For BtmkCount = 1 To 23 'this is the loop to pull the parameters
                    BtmBurstData(BtmkCount) = BtmBurstArray(BtmjCount,BtmkCount)' get one burst string
                  Next BtmkCount 'pull all 23 parameters within the n-th part of the j-loop and store in the array
                  Call ParseBtmBurst 'parse array into proper fields
                  If BtmWqError Then 'if we didn't get data
                    BtmWqBadData = true 'set a flag
                  Else
                    BtmWqBadData = false 'otherwise, we are good
                  EndIf
                  '                StdDevSpa(StdTurbFNU,MaxBurstCnt,BurstArray(1,WqLocTurb))
                  '                Delay(1,30,msec)
                  BtmBurstCount = BtmBurstCount+1 'burst count increase
                  If BtmWqError Then 'an error occured while trying to read a burst value (in "ParseBurst" sub)
                    BtmBurstErrCnt = BtmBurstErrCnt + 1 'count up if the error occurs
                  EndIf
                  If BtmBurstErrCnt > BtmBurstMaxErrCnt Then 'if we have more errors than the threshold
                    TotalBurstVals = BtmjCount - BtmBurstErrCnt 'the total number of values used for the burst should be jCount - number of errors
                    SerialOut (WqSerialPort,"0" + CHR(13) + CHR(10),"#",3,50) 'send a "0" out to stop the SOA from attempting to burst
                    ExitFor 'if error occurs more than a threshold, exit the loop
                  EndIf

                  If BtmBurstCount >= MaxBurstCnt Then 'if our burst count has reached our threshold
                    TotalBurstVals = BtmjCount - BtmBurstErrCnt 'if there's an interuption during the burst but it comes back online, we need to subtract how many times error happened to calculate a total number of values
                    BtmBurstMissed = False 'we had good values coming in, so Make sure disable variable is set to false so the values get processed
                    RecBurstFlag = True 'set our output flag to true
                    CallTable BtmSecBurst 'call the table that stores individual 1sec values
                    CallTable BtmBurst 'call the burst table
                  ElseIf BtmBurstCount < MaxBurstCnt AND BtmWqError = True Then
                    BtmBurstMissed = False 'we have good values
                    RecBurstFlag = False 'don't set the output flag because we haven't reached our threshold
                    CallTable BtmSecBurst 'store the next 1sec value
                  ElseIf BtmBurstCount < MaxBurstCnt AND BtmWqError = False Then
                    BtmBurstMissed = False
                    RecBurstFlag = False
                    CallTable BtmSecBurst
                    CallTable BtmBurst 'Need to call table to store the values in the table memory until the output flag (RecBurstFlag) is true
                  EndIf
                  Delay(1,1,msec)
                Next jCount 'restart the loop until we reach max burst count
                If BtmBurstCount < MaxBurstCnt Then 'didn't reach our burst threshold, so let's Call and output SecBurst and Burst Tables
                  BtmBurstMissed = True 'Disable processing of Median values in burst table
                  RecBurstFlag = True 'set the output flag to true
                  CallTable BtmSecBurst 'store the final value in the SecBurst table
                  CallTable BtmBurst 'Call the burst table to output median values no with however many 1sec values were collected
                EndIf

                If TotalBurstVals >= MinBurstVals Then 'if we reached our minimum threshold for 1sec values
                  Call CopyBtmMedBurstVals 'copy the values from the burst table to the "Med..." values to be sampled into the AQ table
                Else
                  Call ResetBtmBurstVals 'we didn't reach our minimum threshold, NAN all values to be sampled into AQ table
                EndIf
                SerialFlush (WqSerialPort) 'flush the port to ensure nothing gets inadvertantly populated
                BtmBurstCount = 0 'reset our burst count back to 0
              #EndIf 'burst
            EndIf 'getburst and not redeploy
            '      EndIf 'Redeploy = true
          #EndIf

          If (WqParamOrder(1) = BadDataIndicator) OR (WqError = True) Then'unable to initialize or bad data
            #If DWRSonde = False Then
              Call WQ_Mark_Bad
              Erase WqData()
            #EndIf
            If WqDead AND WqPwrCycleCnt >= WQDeadCntMax Then 'cycle power to the both Sondes if one sonde has a WQdead flag
              Call CycleWQPower
            EndIf
            WqErrCount = WqErrCount + 1'this will continue until there is no error
            WqPwrCycleCnt = WqPwrCycleCnt + 1 'this gets reset to zero when there is a power cycle to avoid having non-stop power cycles
            If WqErrCount >= WQDeadCntMax Then
              WqDead = True
              'WqDeadCnt = WqDeadCnt + 1
            EndIf
          EndIf 'error
        #EndIf

        #If TopBottom Then 'need to conditional compile here to determine if the correct chunks are removed if not topbottom
          If (BtmWqParamOrder(1) = BadDataIndicator) OR (BtmWqError = True) Then'unable to initialize or bad data
            If BtmWqDead AND BtmWqPwrCycleCnt >= WQDeadCntMax Then 'cycle power to the both Sondes if one sonde has a WQdead flag
              Call CycleWQPower
            EndIf
            BtmWqErrCount = BtmWqErrCount + 1'this will continue until there is no error
            BtmWqPwrCycleCnt = BtmWqPwrCycleCnt + 1 'this gets reset to zero when there is a power cycle to avoid having non-stop power cycles
            If BtmWqErrCount >= WQDeadCntMax Then 'if the error is above the threshold switch the dead flag to true
              BtmWqDead = True
            EndIf
          EndIf 'error
        #EndIf
        AfterBurst = Timer(DebugTimer,msec,4)
        AfterBurst = AfterBurst/1000

        #If WqSonde <>"NONE" Then
          TempDiff = WqTempC - VMtempC
          If WqError = true Then
            WqBadData = True
          Else
            WqBadData = False
          EndIf
        #EndIf
        If SetEXOTimeFlg = True Then
          Call SetEXOTime
        EndIf
        If WqManualCycle = true Then
          Call CycleWQpower
        EndIf
      #EndIf
      #If HasVM Then
        If VMdataIn = Yes Then 'only process data if we have it
          VmDeadCount = 0
          MainDecodeStart = Timer(DebugTimer,msec,4)
          MainDecodeStart = MainDecodeStart/1000
          Call MainDecode
          MainDecodeEnd = Timer(DebugTimer,msec,4)
          MainDecodeEnd = MainDecodeEnd/1000
          MainDecodeTotTime = MainDecodeEnd-MainDecodeStart
          #If UseAutoRange = true
            CalcRangeStart = Timer(DebugTimer,msec,4)
            CalcRangeStart = CalcRangeStart/1000
            Call CalcRangebin
            EndBin = RangedBin
            CalcRangeEnd = Timer(DebugTimer,msec,4)
            CalcRangeEnd = CalcRangeEnd/1000
            CalcRangeTotTime = CalcRangeEnd - CalcRangeStart
          #EndIf
          '      Call LastGoodBinCheck
          OneMinCalcStart = Timer(DebugTimer,msec,4)
          OneMinCalcStart = OneMinCalcStart/1000
          Call OneMinuteCalcs
          OneMinCalcEnd = Timer(DebugTimer,msec,4)
          OneMinCalcEnd = OneMinCalcEnd/1000
          OneMinCalcTotTime = OneMinCalcEnd - OneMinCalcStart
          CalcQStart = Timer(DebugTimer,msec,4)
          CalcQStart = CalcQStart/1000
          Call SubCalcQ
          CalcQEnd = Timer(DebugTimer,msec,4)
          CalcQEnd = CalcQEnd/1000
          CalcQTotTime = CalcQEnd-CalcQStart
          GetVMMemStart = Timer(DebugTimer,msec,4)
          GetVMMemStart = GetVMMemStart/1000
          Call GetVMFreeMem
          GetVMMemEnd = Timer(DebugTimer,msec,4)
          GetVMMemEnd = GetVMMemEnd/1000
          GetVMMemTotTime = GetVMMemEnd-GetVMMemStart

          'now call the DataOut tables (need to be seen on every scan)
          'if hasVM = False and we're getting vm data we need to disable these two tables because they are called later

          #If IsSpecStudy = Yes Then 'although the table is called, it will not record anything unless
            'vm is 3-4 beams and set to beam or earth coords or the RecordAll boolean is toggled
            CallTable VelData
          #EndIf
          RecAllVelFlag = false
          'Rec15minFlag = false 'turn data table flag back off
          'make sure spike stuff is not called if hasvm is false
          If ScanNo >= 20 Then 'fill fif0 buffer before checking but do check first incase we have to set disable variables
            ChkSpikeStart = Timer(DebugTimer,msec,4)
            ChkSpikeStart = ChkSpikeStart/1000
            Call CheckSpikes
            ChkSpikeEnd = Timer(DebugTimer,msec,4)
            ChkSpikeEnd = ChkSpikeEnd/1000
            ChkSpikeTotTime = ChkSpikeEnd - ChkSpikeStart
            #If StoreAllToCard Then
              StoreToCrdStart = Timer(DebugTimer,msec,4)
              StoreToCrdStart = StoreToCrdStart/1000
              Call StoreAllData
              StoreToCrdEnd = Timer(DebugTimer,msec,4)
              StoreToCrdEnd = StoreToCrdEnd/1000
              StoreToCrdTotTime = StoreToCrdEnd-StoreToCrdStart
            #EndIf
          EndIf
          AddSpikeStart = Timer(DebugTimer,msec,4)
          AddSpikeStart = AddSpikeStart/1000
          Call AddSpikes 'make sure buffer is full before checking
          AddSpikeEnd = Timer(DebugTimer,msec,4)
          AddSpikeEnd = AddSpikeEnd/1000
          AddSpikeTotTime = AddSpikeEnd-AddSpikeStart

        Else 'if no vm data in
          VmDeadCount = VmDeadCount + 1
        EndIf 'if vm data in
        If VmDeadCount >= VMDeadCntMax Then
          WakeUpVM = True
        EndIf
        Call StageDiff
        Call ResetMeasFlags
        Call GetSN
        If SetVMTimeFlg Then
          Call SetVMTime
        EndIf
      #EndIf
      'Call All Data Tables (time them to make sure nothing is being hung up.
      DataTabsStart = Timer(DebugTimer,msec,4)
      DataTabsStart = DataTabsStart/1000
      CallTable DataOut
      DataOutCount = DataOutCount + 1
      DataOutEnd = Timer (DebugTimer,msec,4)
      DataOutEnd = DataOutEnd/1000
      DataOutTotTime = DataOutEnd - DataOutStart
      Data1mStart = Timer (DebugTimer,msec,4)
      Data1mStart = Data1mStart/1000
      CallTable Data1m
      Data1mCount = Data1mCount + 1
      Data1mEnd = Timer(DebugTimer,msec,4)
      Data1mEnd = Data1mEnd/1000
      Data1mTotTime = Data1mEnd - Data1mStart
      DataTabsEnd = Timer(DebugTimer,msec,4)
      DataTabsEnd = DataTabsEnd/1000
      DataTabsTotTime = DataTabsEnd - DataTabsStart
      CallBmChkStart = Timer(DebugTimer,msec,4)
      CallBmChkStart = CallBmChkStart/1000
      CallTable BeamCheck
      CallBmChkEnd = Timer(DebugTimer,msec,4)
      CallBmChkEnd = CallBmChkEnd/1000
      CallBmChkTotTime = CallBmChkEnd-CallBmChkStart
      #If WqSonde = "WQ_SERIAL_BURST" Then
        RecBurstFlag = False
        '        Call ClearBurstVars
      #EndIf
      RecAQFlag = False

      #If RadioNetwork = True Then 'only compile if it's in a radio network
        If ReadRadSettings = True Then 'if user wants to store radio settings
          Call ReadRF 'read in settings
          Call StoreRadSettings 'store in USR drive
        EndIf
        #If IsMaster = True Then 'if it's the master
          Call CheckLinks 'call the subroutine that checks multiple links
          If SetRadSettings = True OR ResetMaster = True AND ResetTryOK = True Then 'If link failed and enough time has passed to try reset again or user wants a manual reset
            Call ResetRadDefault 'first, let's set radio back to factory defaults
            Call ReadRF 'read in the settings after setting to default to make sure it did what it's supposed to
            Delay (1,1,Sec) 'delay, so user can see the change (maybe call/store a 1 record table here to minimize processing delay?)
            Call SetRadSetting 'set radio settings to the what's stored on USR
            Call ReadRF 'read in the new settings
            Call StoreRadSettings 'store the new settings
            ResetTried = True 'flag to indicate a reset was tried
            NextTryCnt = 0 'reset the counter to zero so we can wait X amount of time before retrying
            RadResetAttempts = RadResetAttempts + 1 'count how many attempts has been made (will reset if a link is re-established)
          EndIf
          If ResetMaster = True AND ResetTried = False Then 'if the reset master flag is still set and we didn't try to reset on this scan
            NextTryCnt = NextTryCnt + 1 'increase NextTryCnt
          EndIf
          If NextTryCnt >= MaxNextTryCnt Then 'If NextTryCnt is greater that threshold
            ResetTryOK = True 'it's ok to try the reset
          Else
            ResetTryOK = False 'otherwise, not enough time has passed since previous attempt
          EndIf
        #Else 'if it's a slave
          Call CheckSlaveLink 'only check the single link to the master
          If SetRadSettings = True OR ResetSlave = True AND ResetTryOK = True Then 'if link failed and enough time has passed to try again or user wants manual reset
            Call ResetRadDefault 'reset radio to defaults
            Call ReadRF 'read in settings to verify it did it correctly
            Delay (1,1,Sec) 'delay, so user has opportunity to see that it worked
            Call SetRadSetting 'set radio to settings stored in USR
            Call ReadRF 'read in the new settings
            Call StoreRadSettings 'store the new radio settings
            ResetTried = True 'a reset was attempted
            NextTryCnt = 0 'reset counter to 0
            RadResetAttempts = RadResetAttempts + 1 'count how many attempts has been made (will reset if a link is re-established)
          EndIf
          If ResetSlave = True AND ResetTried = False Then 'if the ResetSlave flag is still set and we didn't try a reset on this scan
            NextTryCnt = NextTryCnt + 1 'increase counter
          EndIf
          If NextTryCnt >= MaxNextTryCnt Then 'if counter is greater than threshold
            ResetTryOK = True 'then enough time has passed since previous attempt, it is ok to try the reset again
          Else
            ResetTryOK = False 'not enough time has passed, let's wait to try again.
          EndIf
        #EndIf
        If SetRadToDefault = True Then 'if user wants to set radio to defaults/turn off radio
          Call ResetRadDefault 'reset to default
          Call ReadRF 'read in new settings, but don't store settings to USR because these settings are established as Constants and don't need to be stored.
          SetRadToDefault = False 'reset flag to false
        EndIf
        ResetTried = False 'set flag to false to start counter (if necessary)
        CallTable RadioStatus
      #EndIf
      If StoreVariablesFlg = true Then Call StoreVariables
      #If HasSuna Then 'if there's a suna
        If WipeSuna = True Then 'if wipe flag was set to true based on the Mod15Min
          Do 'Start a Do/Loop
            WipeStart = Timer(SunaWipeTimer,mSec,4) 'read the timer in
            WipeStart = WipeStart/1000 'convert mSec to Seconds
            If WipeStart >= 55 Then 'If we are at least 55seconds into the scan
              StartWipe = True 'set trigger to true
              ExitDo
            Else
              StartWipe = False 'otherwise, keep false
            EndIf
            Delay(1,250,mSec) 'Delay 0.25sec between loops
          Loop
          If StartWipe = True Then 'if we've completed the loop
            PortSet(SunaWipeSwitch,1) 'send signal to wiper
            Delay(1,250,mSec) 'delay 0.25sec
            PortSet(SunaWipeSwitch,0) 'turn signal off
            StartWipe = False 'set flag back to false
            WipeEnd = Timer(SunaWipeTimer,mSec,4) 'store time of wiper end
            WipeEnd = WipeEnd/1000 'convert mSec to Sec
            SunaWipeTotTime = WipeEnd - WipeStart 'record total time of wiper trigger being "ON"
          EndIf
        EndIf
        If SampleSuna = True Then 'if it's time to sample the Suna based on the Mod15Min
          Do 'start Do/Loop
            SunaTimer = Timer(SunaSampleTimer,mSec,4) 'read sampling timer
            SunaTimer = SunaTimer/1000 'convert from mSec to Sec
            If SunaTimer >= 15 Then 'if the Suna has been on for at least 15 seconds (warm up)
              SunaReady = True 'we are ready to actually read in data
              ExitDo 'Exit the loop
            Else
              SunaReady = False 'otherwise, we aren't ready
            EndIf
            Delay (1,250,mSec) 'delay 0.25 sec before checking time again
          Loop 'continue loop until we are ready
          If SunaReady = True Then 'now that we're ready
            SerialOpen(SunaPort,115200,0,0,6000) 'open the serial port with enough buffer to hold 3 full strings
            oCount = 1 'start a counter at 1
            SunaSampleStart = Timer (SunaSampleTimer,mSec,4)
            SunaSampleStart = SunaSampleStart/1000
            For Lcount = 1 To MaxSunaBurst 'start For/Next loop to continue for "MaxSunaBurst" times
              SunaMissedCnt = 0 'set the missed count to 0
              Do 'start Do/Loop
                SerialIn(SunaBurstIn,SunaPort,50,CHR(13)+CHR(10),2000) 'read data into SunaBurstIn string
                SunaStringLen = Len(SunaBurstIn) 'get the length of the string
                If SunaStringLen <> 0 Then 'if the string is longer than 0 bytes (maybe play with this?)
                  LocLF = InStr (1,SunaBurstIn,"L",2) 'search the string for an L (only want to store LightFrames)
                  Delay (1,50,mSec) 'delay 50 millisec
                  If LocLF = 5 Then 'if the L is found at byte 5
                    LFrame = True 'we know it's a LightFrame
                  Else
                    LFrame = False 'otherwise it's something other than a LightFrame (NANs or DarkFrame)
                  EndIf
                Else 'if no bytes came through
                  SunaMissedCnt = SunaMissedCnt + 1 'we missed data
                  If SunaMissedCnt >= 3 Then 'if we miss data for 3 consecutive seconds
                    SunaMissed = True 'set a flag
                  Else
                    SunaMissed = False 'otherwise, don't set flag
                  EndIf
                EndIf
              Loop Until LFrame = True OR SunaMissed = True 'continue looping until we find a LightFrame or we've missed the data/no data are coming in
              If SunaMissed = True Then 'if we missed the data
                ExitFor 'leave the For loop
              EndIf
              Delay (1,200,mSec) 'delay 0.2 sec
              SplitStr(SunaBurstArray(oCount,1),SunaBurstIn,&H0D0A,282,0) 'we have data, let's split the string into the multi-dimensioned array based on the counter
              'Start at oCount (seconds), at the first parameter. continue to parse for 282 repetitions
              SplitStr(SunaHeader,SunaBurstIn,"",1,1)
              If SunaBurstArray(oCount,1) < 1000 Then
                SunaHeader = SunaHeader + "0"
              Else
                SunaHeader = SunaHeader
              EndIf
              Delay(1,500,mSec) 'delay to wait for next value
              Erase(SunaBurstIn) 'erase the string
              SerialFlush(SunaPort) 'flush the port
              oCount=oCount+1 'increase the counter by 1
              Delay (1,200,mSec) 'delay another 0.2sec
            Next Lcount 'go back to the to top of the For Loop
            Delay (1,100,mSec) 'delay 0.1sec
            SerialClose(SunaPort) 'close the port
            PortSet (SunaSwitch,0) 'turn off the Suna
            SunaTimer = Timer(SunaSampleTimer,mSec,4) 'read the timer for how long the Suna was powered
            SunaOnTime = SunaTimer/1000 'convert timer from mSec to Sec
            SunaProcessStart = Timer(DebugTimer,mSec,4) 'read a timer for the start of the processing
            SunaProcessStart = SunaProcessStart/1000 'convert from mSec to Sec
            If SunaMissed = False Then 'if we didn't miss data
              For mCount = 1 To MaxSunaBurst 'start For/Next loop to parse data, mCount loop is for number of seconds
                For nCount = 1 To 282 'start loop for number of columns
                  SunaBurstData(nCount) = SunaBurstArray(mCount,nCount) 'parse columns into the Burst Data array from the multi-dimensioned array built above
                Next nCount
                If SunaBurstData(1) <> "NAN" Then 'if first value in array isn't NAN, we have data
                  If SunaBurstData(1) < 255 Then 'if SUNA SN is less than 255
                    SSN = 1 'set locations for parameters
                    SST = 2
                    SNuM = 3
                    SNmgL = 4
                    SFR = 5
                    STL = 6
                    STS = 7
                    SLT = 8
                    SH = 9
                    SSA = 13
                    SDA = 14
                    SVL = 10
                    SVM = 12
                    SA254 = 90
                  Else  'otherwise, it's a SUNAV2
                    SSN = 1 'set locations for parameters
                    SST = 3
                    SNuM = 4
                    SNmgL = 5
                    SFR = 281
                    STL = 270
                    STS = 269
                    SLT = 271
                    SH = 272 'Check this- value is 0.137 and doesnt look right!
                    SSA = 9
                    SDA = 10
                    SVL = 274
                    SVM = 273
                    SA254 = 6
                  EndIf
                EndIf
                SunaSN = SunaBurstData(SSN) 'parse data into appropriate columns
                SunaSampleTime = SunaBurstData(SST)'ASCII FLOAT 5..11
                SunaNitrateuM = SunaBurstData(SNuM)'AF 4..9
                SunaNitratemgL = SunaBurstData(SNmgL)'AF 6..11
                SunaFittingResult = SunaBurstData(SFR)
                TLamp = SunaBurstData(STL)
                TSpec = SunaBurstData(STS)
                SunaLampTime = SunaBurstData(SLT)
                SunaHumid = SunaBurstData(SH)'AF 3..5 Case Is
                SunaSpecAve = SunaBurstData(SSA) 'AI 1..5
                SunaDarkAve = SunaBurstData(SDA)'ASCII INTEGER 1.3
                SunaVoltLamp = SunaBurstData(SVL) 'AI 1..5
                SunaVoltMain = SunaBurstData(SVM)'ASCII INTEGER 1.3ta(),256,SunaBurstData(12),256)
                A254 = SunaBurstData(SA254)
                If mCount >= MaxSunaBurst Then 'if we've reached our sampling total time
                  RecSunaData = True 'set the table trigger flag to true
                Else
                  RecSunaData = False 'otherwise, we aren't ready to record the table
                EndIf
                Move (SpectrumData(),256,SunaBurstData(12),256) 'parse Spectrum data from burst array
                CallTable SecSunaData 'store raw 1 second data
                CallTable RawSpectrum 'store raw 1 second Spectrum data
                CallTable SunaStats 'store values into stats table, then record them when we've reached our count threshold
              Next mCount
            EndIf
          EndIf
          SunaBurstData() = BadDataIndicator 'reset all arrays to NANs, so they don't populate duplicate values if no data are present next time
          SunaBurstArray() = BadDataIndicator
          SpectrumData() = BadDataIndicator
          Call CopySunaStats 'copy the stats from the "SunaStats" table to new variables to be sampled by the AQ table
          SunaProcessEnd = Timer(DebugTimer,mSec,4) 'store the end time
          SunaProcessEnd = SunaProcessEnd/1000 'convert from mSec to Sec
          SunaProcessTotTime = SunaProcessEnd-SunaProcessStart 'calculate total time it took to process data
        EndIf
      #EndIf
      AQTabStart = Timer(DebugTimer,msec,4) 'read timer for start time of the AQ table
      AQTabStart = AQTabStart/1000 'convert
      AvgIndexVel = DataOut.IndexVel_Avg 'copy discharge data to new variables to sample in the AQ table
      AvgVMTemp = DataOut.VMtempC_Avg
      AvgVMPitch = DataOut.VMpitch_Avg
      AvgVMRoll = DataOut.VMroll_Avg
      AvgPS1Stg = DataOut.PS1Stg_Avg
      AvgPS2Stg = DataOut.PS2Stg_Avg
      AvgUpBeamStg = DataOut.UpBeamStg_Avg
      '      AvgLoggerQcfs = DataOut.Qcfs_Avg
      '      AvgStagePrime = Dataout.StagePrime_Avg
      '      AvgStageSec = Dataout.StageSecnd_Avg
      Delay(1,50,mSec)
      CallTable Aquarius 'call the table, if Rec15MinFlag is true, record it. Otherwise, store data in background until we are ready to record the data
      AQcount = AQcount + 1 'debug counter
      AQTabEnd = Timer (DebugTimer,msec,4) 'end time of AQ table
      AQTabEnd = AQTabEnd/1000 'convert
      AQTabTotTime = AQTabEnd - AQTabStart   'total time to write to AQ
      #If WqSonde = "WQ_SERIAL_BURST" Then
        If Rec15minFlag = True Then 'if we recorded our 15min mark
          Call ResetBurstVars 'reset the WQ burst variables
        EndIf
      #EndIf
      #If HasSuna Then
        If Rec15minFlag = True Then
          Call ResetSunaStats 'reset the Suna Stats variables
        EndIf
      #EndIf
      Rec15minFlag = false 'turn off data table trigger flags (until they get triggered in the program above at the next appropriate interval)
      ScanEnd = Timer(DebugTimer,mSec,4) 'read timer for end of scan
      ScanEnd = ScanEnd/1000 'convert
      ProcessTime = ScanEnd - ScanStart 'calculate total time
      CallTable Debugger 'call/store debugging info
      CallTable SVMaq 'call SVMaq table
    NextScan
  EndProg
